{"mappings":"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","sources":["<anon>","node_modules/@newrelic/browser-agent/dist/esm/features/ajax/aggregate/index.js","node_modules/@newrelic/browser-agent/dist/esm/features/ajax/aggregate/gql.js","node_modules/@newrelic/browser-agent/dist/esm/common/util/type-check.js","node_modules/@newrelic/browser-agent/dist/esm/common/serialize/bel-serializer.js"],"sourcesContent":["(function () {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire5e30\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"bcUwE\", function(module, exports) {\n\n$parcel$export(module.exports, \"Aggregate\", function () { return $828ca97d7e83cb9f$export$b9601df20779e14a; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $8auZx = parcelRequire(\"8auZx\");\n\nvar $gSI6b = parcelRequire(\"gSI6b\");\n\nvar $dpdfa = parcelRequire(\"dpdfa\");\n\nvar $hnkUQ = parcelRequire(\"hnkUQ\");\n\nvar $kq96H = parcelRequire(\"kq96H\");\n\nvar $gUmiN = parcelRequire(\"gUmiN\");\n\nvar $6Lc7k = parcelRequire(\"6Lc7k\");\n\nvar $kPXiP = parcelRequire(\"kPXiP\");\n\nvar $huGOm = parcelRequire(\"huGOm\");\nclass $828ca97d7e83cb9f$export$b9601df20779e14a extends (0, $6Lc7k.AggregateBase) {\n    static featureName = (0, $kq96H.FEATURE_NAME);\n    constructor(agentRef){\n        super(agentRef, (0, $kq96H.FEATURE_NAME));\n        (0, $hnkUQ.setDenyList)(agentRef.runtime.denyList);\n        this.underSpaEvents = {};\n        const classThis = this;\n        // --- v Used by old spa feature\n        this.ee.on('interactionDone', (interaction, wasSaved)=>{\n            if (!this.underSpaEvents[interaction.id]) return;\n            if (!wasSaved) // if the ixn was saved, then its ajax reqs are part of the payload whereas if it was discarded, it should still be harvested in the ajax feature itself\n            this.underSpaEvents[interaction.id].forEach((item)=>this.events.add(item));\n            delete this.underSpaEvents[interaction.id];\n        });\n        // --- ^\n        // --- v Used by new soft nav\n        (0, $8auZx.registerHandler)('returnAjax', (event)=>this.events.add(event), this.featureName, this.ee);\n        // --- ^\n        (0, $8auZx.registerHandler)('xhr', function() {\n            // the EE-drain system not only switches \"this\" but also passes a new EventContext with info. Should consider platform refactor to another system which passes a mutable context around separately and predictably to avoid problems like this.\n            classThis.storeXhr(...arguments, this); // this switches the context back to the class instance while passing the NR context as an argument -- see \"ctx\" in storeXhr\n        }, this.featureName, this.ee);\n        this.waitForFlags([]).then(()=>this.drain());\n    }\n    storeXhr(params, metrics, startTime, endTime, type, ctx) {\n        metrics.time = startTime;\n        // send to session traces\n        let hash;\n        if (params.cat) hash = (0, $gSI6b.stringify)([\n            params.status,\n            params.cat\n        ]);\n        else hash = (0, $gSI6b.stringify)([\n            params.status,\n            params.host,\n            params.pathname\n        ]);\n        const shouldCollect = (0, $hnkUQ.shouldCollectEvent)(params);\n        const shouldOmitAjaxMetrics = this.agentRef.init.feature_flags?.includes('ajax_metrics_deny_list');\n        const jserrorsInUse = Boolean(this.agentRef.features?.[(0, $gUmiN.FEATURE_NAMES).jserrors]);\n        // Report ajax timeslice metric (to be harvested by jserrors feature, but only if it's running).\n        if (jserrorsInUse && (shouldCollect || !shouldOmitAjaxMetrics)) this.agentRef.sharedAggregator?.add([\n            'xhr',\n            hash,\n            params,\n            metrics\n        ]);\n        if (!shouldCollect) {\n            if (params.hostname === this.agentRef.info.errorBeacon || this.agentRef.init.proxy?.beacon && params.hostname === this.agentRef.init.proxy.beacon) {\n                // This doesn't make a distinction if the same-domain request is going to a different port or path...\n                this.reportSupportabilityMetric('Ajax/Events/Excluded/Agent');\n                if (shouldOmitAjaxMetrics) this.reportSupportabilityMetric('Ajax/Metrics/Excluded/Agent');\n            } else {\n                this.reportSupportabilityMetric('Ajax/Events/Excluded/App');\n                if (shouldOmitAjaxMetrics) this.reportSupportabilityMetric('Ajax/Metrics/Excluded/App');\n            }\n            return; // do not send this ajax as an event\n        }\n        (0, $dpdfa.handle)('bstXhrAgg', [\n            'xhr',\n            hash,\n            params,\n            metrics\n        ], undefined, (0, $gUmiN.FEATURE_NAMES).sessionTrace, this.ee); // have trace feature harvest AjaxNode\n        const event = {\n            method: params.method,\n            status: params.status,\n            domain: params.host,\n            path: params.pathname,\n            requestSize: metrics.txSize,\n            responseSize: metrics.rxSize,\n            type: type,\n            startTime: startTime,\n            endTime: endTime,\n            callbackDuration: metrics.cbTime\n        };\n        if (ctx.dt) {\n            event.spanId = ctx.dt.spanId;\n            event.traceId = ctx.dt.traceId;\n            event.spanTimestamp = Math.floor(this.agentRef.runtime.timeKeeper.correctAbsoluteTimestamp(ctx.dt.timestamp));\n        }\n        // parsed from the AJAX body, looking for operationName param & parsing query for operationType\n        event.gql = params.gql = (0, $kPXiP.parseGQL)({\n            body: ctx.body,\n            query: ctx.parsedOrigin?.search\n        });\n        if (event.gql) this.reportSupportabilityMetric('Ajax/Events/GraphQL/Bytes-Added', (0, $gSI6b.stringify)(event.gql).length);\n        const softNavInUse = Boolean(this.agentRef.features?.[(0, $gUmiN.FEATURE_NAMES).softNav]);\n        if (softNavInUse) // For newer soft nav (when running), pass the event to it for evaluation -- either part of an interaction or is given back\n        (0, $dpdfa.handle)('ajax', [\n            event\n        ], undefined, (0, $gUmiN.FEATURE_NAMES).softNav, this.ee);\n        else if (ctx.spaNode) {\n            // For old spa (when running), if the ajax happened inside an interaction, hold it until the interaction finishes\n            const interactionId = ctx.spaNode.interaction.id;\n            this.underSpaEvents[interactionId] ??= [];\n            this.underSpaEvents[interactionId].push(event);\n        } else this.events.add(event);\n    }\n    serializer(eventBuffer) {\n        if (!eventBuffer.length) return;\n        const addString = (0, $huGOm.getAddStringContext)(this.agentRef.runtime.obfuscator);\n        let payload = 'bel.7;';\n        for(let i = 0; i < eventBuffer.length; i++){\n            const event = eventBuffer[i];\n            const fields = [\n                (0, $huGOm.numeric)(event.startTime),\n                (0, $huGOm.numeric)(event.endTime - event.startTime),\n                (0, $huGOm.numeric)(0),\n                // callbackEnd\n                (0, $huGOm.numeric)(0),\n                // no callbackDuration for non-SPA events\n                addString(event.method),\n                (0, $huGOm.numeric)(event.status),\n                addString(event.domain),\n                addString(event.path),\n                (0, $huGOm.numeric)(event.requestSize),\n                (0, $huGOm.numeric)(event.responseSize),\n                event.type === 'fetch' ? 1 : '',\n                addString(0),\n                // nodeId\n                (0, $huGOm.nullable)(event.spanId, addString, true) + // guid\n                (0, $huGOm.nullable)(event.traceId, addString, true) + // traceId\n                (0, $huGOm.nullable)(event.spanTimestamp, (0, $huGOm.numeric), false) // timestamp\n            ];\n            let insert = '2,';\n            // Since configuration objects (like info) are created new each time they are set, we have to grab the current pointer to the attr object here.\n            const jsAttributes = this.agentRef.info.jsAttributes;\n            // add custom attributes\n            // gql decorators are added as custom attributes to alleviate need for new BEL schema\n            const attrParts = (0, $huGOm.addCustomAttributes)({\n                ...jsAttributes || {},\n                ...event.gql || {}\n            }, addString);\n            fields.unshift((0, $huGOm.numeric)(attrParts.length));\n            insert += fields.join(',');\n            if (attrParts && attrParts.length > 0) insert += ';' + attrParts.join(';');\n            if (i + 1 < eventBuffer.length) insert += ';';\n            payload += insert;\n        }\n        return payload;\n    }\n}\n\n});\nparcelRegister(\"kPXiP\", function(module, exports) {\n\n$parcel$export(module.exports, \"parseGQL\", function () { return $f2b692583923a411$export$c889eb85a212cc45; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $hFfWt = parcelRequire(\"hFfWt\");\nfunction $f2b692583923a411$export$c889eb85a212cc45({ body: body, query: query } = {}) {\n    if (!body && !query) return;\n    try {\n        const gqlBody = $f2b692583923a411$var$parseBatchGQL($f2b692583923a411$var$parseGQLContents(body));\n        if (gqlBody) return gqlBody;\n        const gqlQuery = $f2b692583923a411$var$parseSingleGQL($f2b692583923a411$var$parseGQLQueryString(query));\n        if (gqlQuery) return gqlQuery;\n    } catch (err) {\n    // parsing failed, return undefined\n    }\n}\n/**\n * @param {string|Object} gql The GraphQL object body sent to a GQL server\n * @returns {GQLMetadata}\n */ function $f2b692583923a411$var$parseSingleGQL(contents) {\n    if (typeof contents !== 'object' || !contents.query || typeof contents.query !== 'string') return;\n    /** parses gql query string and returns [fullmatch, type match, name match] */ const matches = contents.query.trim().match(/^(query|mutation|subscription)\\s?(\\w*)/);\n    const operationType = matches?.[1];\n    if (!operationType) return;\n    const operationName = contents.operationName || matches?.[2] || 'Anonymous';\n    return {\n        operationName: operationName,\n        operationType: // the operation name of the indiv query\n        operationType,\n        // query, mutation, or subscription,\n        operationFramework: 'GraphQL'\n    };\n}\nfunction $f2b692583923a411$var$parseBatchGQL(contents) {\n    if (!contents) return;\n    if (!Array.isArray(contents)) contents = [\n        contents\n    ];\n    const opNames = [];\n    const opTypes = [];\n    for (let content of contents){\n        const operation = $f2b692583923a411$var$parseSingleGQL(content);\n        if (!operation) continue;\n        opNames.push(operation.operationName);\n        opTypes.push(operation.operationType);\n    }\n    if (!opTypes.length) return;\n    return {\n        operationName: opNames.join(','),\n        // the operation name of the indiv query -- joined by ',' for batched results\n        operationType: opTypes.join(','),\n        // query, mutation, or subscription -- joined by ',' for batched results\n        operationFramework: 'GraphQL'\n    };\n}\nfunction $f2b692583923a411$var$parseGQLContents(gqlContents) {\n    let contents;\n    if (!gqlContents || typeof gqlContents !== 'string' && typeof gqlContents !== 'object') return;\n    else if (typeof gqlContents === 'string') contents = JSON.parse(gqlContents);\n    else contents = gqlContents;\n    if (!(0, $hFfWt.isPureObject)(contents) && !Array.isArray(contents)) return;\n    let isValid = false;\n    if (Array.isArray(contents)) isValid = contents.some((x)=>$f2b692583923a411$var$validateGQLObject(x));\n    else isValid = $f2b692583923a411$var$validateGQLObject(contents);\n    if (!isValid) return;\n    return contents;\n}\nfunction $f2b692583923a411$var$parseGQLQueryString(gqlQueryString) {\n    if (!gqlQueryString || typeof gqlQueryString !== 'string') return;\n    const params = new URLSearchParams(gqlQueryString);\n    return $f2b692583923a411$var$parseGQLContents(Object.fromEntries(params));\n}\nfunction $f2b692583923a411$var$validateGQLObject(obj) {\n    return !(typeof obj !== 'object' || !obj.query || typeof obj.query !== 'string');\n}\n\n});\nparcelRegister(\"hFfWt\", function(module, exports) {\n\n$parcel$export(module.exports, \"isPureObject\", function () { return $cdc2a1c6a9e06f46$export$e219791d2b49856; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Tests a passed object to see if it is a pure object or not. All non-primatives in JS\n * are technically objects and would pass a `typeof` check.\n * @param {*} obj Input object to be tested\n**/ function $cdc2a1c6a9e06f46$export$e219791d2b49856(obj) {\n    return obj?.constructor === ({}).constructor;\n}\n\n});\n\n\nparcelRegister(\"huGOm\", function(module, exports) {\n\n$parcel$export(module.exports, \"nullable\", function () { return $cbc6726960b79399$export$133fc36489ac9add; });\n$parcel$export(module.exports, \"numeric\", function () { return $cbc6726960b79399$export$b7a508fa8dae59fc; });\n$parcel$export(module.exports, \"getAddStringContext\", function () { return $cbc6726960b79399$export$71f03e17b83cbe02; });\n$parcel$export(module.exports, \"addCustomAttributes\", function () { return $cbc6726960b79399$export$b7f14f78b59de5aa; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $gSI6b = parcelRequire(\"gSI6b\");\nvar $cbc6726960b79399$var$hasOwnProp = Object.prototype.hasOwnProperty;\nvar $cbc6726960b79399$var$MAX_ATTRIBUTES = 64;\nfunction $cbc6726960b79399$export$133fc36489ac9add(val, fn, comma) {\n    return val || val === 0 || val === '' ? fn(val) + (comma ? ',' : '') : '!';\n}\nfunction $cbc6726960b79399$export$b7a508fa8dae59fc(n, noDefault) {\n    if (noDefault) return Math.floor(n).toString(36);\n    return n === undefined || n === 0 ? '' : Math.floor(n).toString(36);\n}\nfunction $cbc6726960b79399$export$71f03e17b83cbe02(obfuscator) {\n    let stringTableIdx = 0;\n    const stringTable = Object.prototype.hasOwnProperty.call(Object, 'create') ? Object.create(null) : {};\n    return addString;\n    function addString(str) {\n        if (typeof str === 'undefined' || str === '') return '';\n        str = obfuscator.obfuscateString(String(str));\n        if ($cbc6726960b79399$var$hasOwnProp.call(stringTable, str)) return $cbc6726960b79399$export$b7a508fa8dae59fc(stringTable[str], true);\n        else {\n            stringTable[str] = stringTableIdx++;\n            return $cbc6726960b79399$var$quoteString(str);\n        }\n    }\n}\nfunction $cbc6726960b79399$export$b7f14f78b59de5aa(attrs, addString) {\n    var attrParts = [];\n    Object.entries(attrs || {}).forEach(([key, val])=>{\n        if (attrParts.length >= $cbc6726960b79399$var$MAX_ATTRIBUTES) return;\n        var type = 5;\n        var serializedValue;\n        // add key to string table first\n        key = addString(key);\n        switch(typeof val){\n            case 'object':\n                if (val) // serialize objects to strings\n                serializedValue = addString((0, $gSI6b.stringify)(val));\n                else // null attribute type\n                type = 9;\n                break;\n            case 'number':\n                type = 6;\n                // make sure numbers contain a `.` so they are parsed as doubles\n                serializedValue = val % 1 ? val : val + '.';\n                break;\n            case 'boolean':\n                type = val ? 7 : 8;\n                break;\n            case 'undefined':\n                // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n                type = 9;\n                break;\n            default:\n                serializedValue = addString(val);\n        }\n        attrParts.push([\n            type,\n            key + (serializedValue ? ',' + serializedValue : '')\n        ]);\n    });\n    return attrParts;\n}\nvar $cbc6726960b79399$var$escapable = /([,\\\\;])/g;\nfunction $cbc6726960b79399$var$quoteString(str) {\n    return \"'\" + str.replace($cbc6726960b79399$var$escapable, '\\\\$1');\n}\n\n});\n\n\n})();\n//# sourceMappingURL=aggregate.d2d440ba.js.map\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { stringify } from '../../../common/util/stringify';\nimport { handle } from '../../../common/event-emitter/handle';\nimport { setDenyList, shouldCollectEvent } from '../../../common/deny-list/deny-list';\nimport { FEATURE_NAME } from '../constants';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { parseGQL } from './gql';\nimport { nullable, numeric, getAddStringContext, addCustomAttributes } from '../../../common/serialize/bel-serializer';\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentRef) {\n    super(agentRef, FEATURE_NAME);\n    setDenyList(agentRef.runtime.denyList);\n    this.underSpaEvents = {};\n    const classThis = this;\n\n    // --- v Used by old spa feature\n    this.ee.on('interactionDone', (interaction, wasSaved) => {\n      if (!this.underSpaEvents[interaction.id]) return;\n      if (!wasSaved) {\n        // if the ixn was saved, then its ajax reqs are part of the payload whereas if it was discarded, it should still be harvested in the ajax feature itself\n        this.underSpaEvents[interaction.id].forEach(item => this.events.add(item));\n      }\n      delete this.underSpaEvents[interaction.id];\n    });\n    // --- ^\n    // --- v Used by new soft nav\n    registerHandler('returnAjax', event => this.events.add(event), this.featureName, this.ee);\n    // --- ^\n    registerHandler('xhr', function () {\n      // the EE-drain system not only switches \"this\" but also passes a new EventContext with info. Should consider platform refactor to another system which passes a mutable context around separately and predictably to avoid problems like this.\n      classThis.storeXhr(...arguments, this); // this switches the context back to the class instance while passing the NR context as an argument -- see \"ctx\" in storeXhr\n    }, this.featureName, this.ee);\n    this.waitForFlags([]).then(() => this.drain());\n  }\n  storeXhr(params, metrics, startTime, endTime, type, ctx) {\n    metrics.time = startTime;\n\n    // send to session traces\n    let hash;\n    if (params.cat) {\n      hash = stringify([params.status, params.cat]);\n    } else {\n      hash = stringify([params.status, params.host, params.pathname]);\n    }\n    const shouldCollect = shouldCollectEvent(params);\n    const shouldOmitAjaxMetrics = this.agentRef.init.feature_flags?.includes('ajax_metrics_deny_list');\n    const jserrorsInUse = Boolean(this.agentRef.features?.[FEATURE_NAMES.jserrors]);\n\n    // Report ajax timeslice metric (to be harvested by jserrors feature, but only if it's running).\n    if (jserrorsInUse && (shouldCollect || !shouldOmitAjaxMetrics)) {\n      this.agentRef.sharedAggregator?.add(['xhr', hash, params, metrics]);\n    }\n    if (!shouldCollect) {\n      if (params.hostname === this.agentRef.info.errorBeacon || this.agentRef.init.proxy?.beacon && params.hostname === this.agentRef.init.proxy.beacon) {\n        // This doesn't make a distinction if the same-domain request is going to a different port or path...\n        this.reportSupportabilityMetric('Ajax/Events/Excluded/Agent');\n        if (shouldOmitAjaxMetrics) this.reportSupportabilityMetric('Ajax/Metrics/Excluded/Agent');\n      } else {\n        this.reportSupportabilityMetric('Ajax/Events/Excluded/App');\n        if (shouldOmitAjaxMetrics) this.reportSupportabilityMetric('Ajax/Metrics/Excluded/App');\n      }\n      return; // do not send this ajax as an event\n    }\n    handle('bstXhrAgg', ['xhr', hash, params, metrics], undefined, FEATURE_NAMES.sessionTrace, this.ee); // have trace feature harvest AjaxNode\n\n    const event = {\n      method: params.method,\n      status: params.status,\n      domain: params.host,\n      path: params.pathname,\n      requestSize: metrics.txSize,\n      responseSize: metrics.rxSize,\n      type,\n      startTime,\n      endTime,\n      callbackDuration: metrics.cbTime\n    };\n    if (ctx.dt) {\n      event.spanId = ctx.dt.spanId;\n      event.traceId = ctx.dt.traceId;\n      event.spanTimestamp = Math.floor(this.agentRef.runtime.timeKeeper.correctAbsoluteTimestamp(ctx.dt.timestamp));\n    }\n\n    // parsed from the AJAX body, looking for operationName param & parsing query for operationType\n    event.gql = params.gql = parseGQL({\n      body: ctx.body,\n      query: ctx.parsedOrigin?.search\n    });\n    if (event.gql) this.reportSupportabilityMetric('Ajax/Events/GraphQL/Bytes-Added', stringify(event.gql).length);\n    const softNavInUse = Boolean(this.agentRef.features?.[FEATURE_NAMES.softNav]);\n    if (softNavInUse) {\n      // For newer soft nav (when running), pass the event to it for evaluation -- either part of an interaction or is given back\n      handle('ajax', [event], undefined, FEATURE_NAMES.softNav, this.ee);\n    } else if (ctx.spaNode) {\n      // For old spa (when running), if the ajax happened inside an interaction, hold it until the interaction finishes\n      const interactionId = ctx.spaNode.interaction.id;\n      this.underSpaEvents[interactionId] ??= [];\n      this.underSpaEvents[interactionId].push(event);\n    } else {\n      this.events.add(event);\n    }\n  }\n  serializer(eventBuffer) {\n    if (!eventBuffer.length) return;\n    const addString = getAddStringContext(this.agentRef.runtime.obfuscator);\n    let payload = 'bel.7;';\n    for (let i = 0; i < eventBuffer.length; i++) {\n      const event = eventBuffer[i];\n      const fields = [numeric(event.startTime), numeric(event.endTime - event.startTime), numeric(0),\n      // callbackEnd\n      numeric(0),\n      // no callbackDuration for non-SPA events\n      addString(event.method), numeric(event.status), addString(event.domain), addString(event.path), numeric(event.requestSize), numeric(event.responseSize), event.type === 'fetch' ? 1 : '', addString(0),\n      // nodeId\n      nullable(event.spanId, addString, true) +\n      // guid\n      nullable(event.traceId, addString, true) +\n      // traceId\n      nullable(event.spanTimestamp, numeric, false) // timestamp\n      ];\n      let insert = '2,';\n\n      // Since configuration objects (like info) are created new each time they are set, we have to grab the current pointer to the attr object here.\n      const jsAttributes = this.agentRef.info.jsAttributes;\n\n      // add custom attributes\n      // gql decorators are added as custom attributes to alleviate need for new BEL schema\n      const attrParts = addCustomAttributes({\n        ...(jsAttributes || {}),\n        ...(event.gql || {})\n      }, addString);\n      fields.unshift(numeric(attrParts.length));\n      insert += fields.join(',');\n      if (attrParts && attrParts.length > 0) {\n        insert += ';' + attrParts.join(';');\n      }\n      if (i + 1 < eventBuffer.length) insert += ';';\n      payload += insert;\n    }\n    return payload;\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { isPureObject } from '../../../common/util/type-check';\n\n/**\n * @typedef {object} GQLMetadata\n * @property {string} operationName Name of the operation\n * @property {string} operationType Type of the operation\n * @property {string} operationFramework Framework responsible for the operation\n */\n\n/**\n * Parses and returns the graphql metadata from a network request. If the network\n * request is not a graphql call, undefined will be returned.\n * @param {object|string} body Ajax request body\n * @param {string} query Ajax request query param string\n * @returns {GQLMetadata | undefined}\n */\nexport function parseGQL({\n  body,\n  query\n} = {}) {\n  if (!body && !query) return;\n  try {\n    const gqlBody = parseBatchGQL(parseGQLContents(body));\n    if (gqlBody) return gqlBody;\n    const gqlQuery = parseSingleGQL(parseGQLQueryString(query));\n    if (gqlQuery) return gqlQuery;\n  } catch (err) {\n    // parsing failed, return undefined\n  }\n}\n\n/**\n * @param {string|Object} gql The GraphQL object body sent to a GQL server\n * @returns {GQLMetadata}\n */\nfunction parseSingleGQL(contents) {\n  if (typeof contents !== 'object' || !contents.query || typeof contents.query !== 'string') return;\n\n  /** parses gql query string and returns [fullmatch, type match, name match] */\n  const matches = contents.query.trim().match(/^(query|mutation|subscription)\\s?(\\w*)/);\n  const operationType = matches?.[1];\n  if (!operationType) return;\n  const operationName = contents.operationName || matches?.[2] || 'Anonymous';\n  return {\n    operationName,\n    // the operation name of the indiv query\n    operationType,\n    // query, mutation, or subscription,\n    operationFramework: 'GraphQL'\n  };\n}\nfunction parseBatchGQL(contents) {\n  if (!contents) return;\n  if (!Array.isArray(contents)) contents = [contents];\n  const opNames = [];\n  const opTypes = [];\n  for (let content of contents) {\n    const operation = parseSingleGQL(content);\n    if (!operation) continue;\n    opNames.push(operation.operationName);\n    opTypes.push(operation.operationType);\n  }\n  if (!opTypes.length) return;\n  return {\n    operationName: opNames.join(','),\n    // the operation name of the indiv query -- joined by ',' for batched results\n    operationType: opTypes.join(','),\n    // query, mutation, or subscription -- joined by ',' for batched results\n    operationFramework: 'GraphQL'\n  };\n}\nfunction parseGQLContents(gqlContents) {\n  let contents;\n  if (!gqlContents || typeof gqlContents !== 'string' && typeof gqlContents !== 'object') return;else if (typeof gqlContents === 'string') contents = JSON.parse(gqlContents);else contents = gqlContents;\n  if (!isPureObject(contents) && !Array.isArray(contents)) return;\n  let isValid = false;\n  if (Array.isArray(contents)) isValid = contents.some(x => validateGQLObject(x));else isValid = validateGQLObject(contents);\n  if (!isValid) return;\n  return contents;\n}\nfunction parseGQLQueryString(gqlQueryString) {\n  if (!gqlQueryString || typeof gqlQueryString !== 'string') return;\n  const params = new URLSearchParams(gqlQueryString);\n  return parseGQLContents(Object.fromEntries(params));\n}\nfunction validateGQLObject(obj) {\n  return !(typeof obj !== 'object' || !obj.query || typeof obj.query !== 'string');\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Tests a passed object to see if it is a pure object or not. All non-primatives in JS\n * are technically objects and would pass a `typeof` check.\n * @param {*} obj Input object to be tested\n**/\nexport function isPureObject(obj) {\n  return obj?.constructor === {}.constructor;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { stringify } from '../util/stringify';\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar MAX_ATTRIBUTES = 64;\nexport function nullable(val, fn, comma) {\n  return val || val === 0 || val === '' ? fn(val) + (comma ? ',' : '') : '!';\n}\nexport function numeric(n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36);\n  }\n  return n === undefined || n === 0 ? '' : Math.floor(n).toString(36);\n}\nexport function getAddStringContext(obfuscator) {\n  let stringTableIdx = 0;\n  const stringTable = Object.prototype.hasOwnProperty.call(Object, 'create') ? Object.create(null) : {};\n  return addString;\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return '';\n    str = obfuscator.obfuscateString(String(str));\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true);\n    } else {\n      stringTable[str] = stringTableIdx++;\n      return quoteString(str);\n    }\n  }\n}\nexport function addCustomAttributes(attrs, addString) {\n  var attrParts = [];\n  Object.entries(attrs || {}).forEach(([key, val]) => {\n    if (attrParts.length >= MAX_ATTRIBUTES) return;\n    var type = 5;\n    var serializedValue;\n    // add key to string table first\n    key = addString(key);\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val));\n        } else {\n          // null attribute type\n          type = 9;\n        }\n        break;\n      case 'number':\n        type = 6;\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.';\n        break;\n      case 'boolean':\n        type = val ? 7 : 8;\n        break;\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9;\n        break;\n      default:\n        serializedValue = addString(val);\n    }\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')]);\n  });\n  return attrParts;\n}\nvar escapable = /([,\\\\;])/g;\nfunction quoteString(str) {\n  return \"'\" + str.replace(escapable, '\\\\$1');\n}"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","self","window","global","parcelRegister","register","module","exports","$828ca97d7e83cb9f$export$b9601df20779e14a","$8auZx","$gSI6b","$dpdfa","$hnkUQ","$kq96H","$gUmiN","$6Lc7k","$kPXiP","$huGOm","AggregateBase","featureName","FEATURE_NAME","constructor","agentRef","setDenyList","runtime","denyList","underSpaEvents","classThis","ee","on","interaction","wasSaved","id","forEach","item","events","add","registerHandler","event","storeXhr","arguments","waitForFlags","then","drain","params","metrics","startTime","endTime","type","ctx","hash","time","cat","stringify","status","host","pathname","shouldCollect","shouldCollectEvent","shouldOmitAjaxMetrics","init","feature_flags","includes","jserrorsInUse","features","FEATURE_NAMES","jserrors","sharedAggregator","hostname","info","errorBeacon","proxy","beacon","reportSupportabilityMetric","handle","undefined","sessionTrace","method","domain","path","requestSize","txSize","responseSize","rxSize","callbackDuration","cbTime","dt","spanId","traceId","spanTimestamp","Math","floor","timeKeeper","correctAbsoluteTimestamp","timestamp","gql","parseGQL","body","query","parsedOrigin","search","length","softNav","spaNode","interactionId","push","serializer","eventBuffer","addString","getAddStringContext","obfuscator","payload","i","fields","numeric","nullable","insert","jsAttributes","attrParts","addCustomAttributes","unshift","join","$f2b692583923a411$export$c889eb85a212cc45","$hFfWt","gqlBody","$f2b692583923a411$var$parseBatchGQL","contents","Array","isArray","opNames","opTypes","content","operation","$f2b692583923a411$var$parseSingleGQL","operationName","operationType","operationFramework","$f2b692583923a411$var$parseGQLContents","gqlQuery","$f2b692583923a411$var$parseGQLQueryString","gqlQueryString","fromEntries","URLSearchParams","err","matches","trim","match","gqlContents","JSON","parse","isPureObject","isValid","some","x","$f2b692583923a411$var$validateGQLObject","obj","$cdc2a1c6a9e06f46$export$e219791d2b49856","$cbc6726960b79399$export$133fc36489ac9add","$cbc6726960b79399$export$b7a508fa8dae59fc","$cbc6726960b79399$export$71f03e17b83cbe02","$cbc6726960b79399$export$b7f14f78b59de5aa","$cbc6726960b79399$var$hasOwnProp","prototype","hasOwnProperty","val","fn","comma","noDefault","toString","stringTableIdx","stringTable","call","create","str","obfuscateString","String","replace","$cbc6726960b79399$var$escapable","attrs","entries","key","serializedValue"],"version":3,"file":"aggregate.d2d440ba.js.map"}
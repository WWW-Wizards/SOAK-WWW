{"mappings":"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","sources":["<anon>","node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/index.js","node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/canonical-function-name.js","node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/compute-stack-trace.js","node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/format-stack-trace.js","node_modules/@newrelic/browser-agent/dist/esm/common/url/canonicalize-url.js","node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/string-hash-code.js","node_modules/@newrelic/browser-agent/dist/esm/common/util/traverse.js","node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/internal-errors.js"],"sourcesContent":["(function () {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire5e30\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"hVBDy\", function(module, exports) {\n\n$parcel$export(module.exports, \"Aggregate\", function () { return $d0d4f473ea290e09$export$b9601df20779e14a; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $SbeVp = parcelRequire(\"SbeVp\");\n\nvar $5uIeW = parcelRequire(\"5uIeW\");\n\nvar $6ZO4b = parcelRequire(\"6ZO4b\");\n\nvar $fud0a = parcelRequire(\"fud0a\");\n\nvar $8auZx = parcelRequire(\"8auZx\");\n\nvar $gSI6b = parcelRequire(\"gSI6b\");\n\nvar $dpdfa = parcelRequire(\"dpdfa\");\n\nvar $7CBaz = parcelRequire(\"7CBaz\");\n\nvar $8g4Aw = parcelRequire(\"8g4Aw\");\n\nvar $gUmiN = parcelRequire(\"gUmiN\");\n\nvar $6Lc7k = parcelRequire(\"6Lc7k\");\n\nvar $7nvKd = parcelRequire(\"7nvKd\");\n\nvar $jHSql = parcelRequire(\"jHSql\");\n\nvar $cultZ = parcelRequire(\"cultZ\");\n\nvar $2cGfe = parcelRequire(\"2cGfe\");\n\nvar $73gWV = parcelRequire(\"73gWV\");\nclass $d0d4f473ea290e09$export$b9601df20779e14a extends (0, $6Lc7k.AggregateBase) {\n    static featureName = (0, $8g4Aw.FEATURE_NAME);\n    constructor(agentRef){\n        super(agentRef, (0, $8g4Aw.FEATURE_NAME));\n        this.stackReported = {};\n        this.observedAt = {};\n        this.pageviewReported = {};\n        this.bufferedErrorsUnderSpa = {};\n        this.errorOnPage = false;\n        // this will need to change to match whatever ee we use in the instrument\n        this.ee.on('interactionDone', (interaction, wasSaved)=>this.onInteractionDone(interaction, wasSaved));\n        (0, $8auZx.registerHandler)('err', (...args)=>this.storeError(...args), this.featureName, this.ee);\n        (0, $8auZx.registerHandler)('ierr', (...args)=>this.storeError(...args), this.featureName, this.ee);\n        (0, $8auZx.registerHandler)('softNavFlush', (interactionId, wasFinished, softNavAttrs)=>this.onSoftNavNotification(interactionId, wasFinished, softNavAttrs), this.featureName, this.ee); // when an ixn is done or cancelled\n        this.harvestOpts.aggregatorTypes = [\n            'err',\n            'ierr',\n            'xhr'\n        ]; // the types in EventAggregator this feature cares about\n        // 0 == off, 1 == on\n        this.waitForFlags([\n            'err'\n        ]).then(([errFlag])=>{\n            if (errFlag) this.drain();\n            else {\n                this.blocked = true; // if rum response determines that customer lacks entitlements for spa endpoint, this feature shouldn't harvest\n                this.deregisterDrain();\n            }\n        });\n    }\n    serializer(aggregatorTypeToBucketsMap) {\n        return (0, $jHSql.applyFnToProps)(aggregatorTypeToBucketsMap, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string');\n    }\n    queryStringsBuilder(aggregatorTakeReturnedData) {\n        const qs = {};\n        const releaseIds = (0, $gSI6b.stringify)(this.agentRef.runtime.releaseIds);\n        if (releaseIds !== '{}') qs.ri = releaseIds;\n        if (aggregatorTakeReturnedData?.err?.length) {\n            if (!this.errorOnPage) {\n                qs.pve = '1';\n                this.errorOnPage = true;\n            }\n            // For assurance, erase any `hasReplay` flag from all errors if replay is not recording, not-yet imported, or not running at all.\n            if (!this.agentRef.features?.[(0, $gUmiN.FEATURE_NAMES).sessionReplay]?.featAggregate?.replayIsActive()) aggregatorTakeReturnedData.err.forEach((error)=>delete error.params.hasReplay);\n        }\n        return qs;\n    }\n    /**\n   * Builds a standardized stack trace string from the frames in the given `stackInfo` object, with each frame separated\n   * by a newline character. Lines take the form `<functionName>@<url>:<lineNumber>`.\n   *\n   * @param {StackInfo} stackInfo - An object specifying a stack string and individual frames.\n   * @returns {string} A canonical stack string built from the URLs and function names in the given `stackInfo` object.\n   */ buildCanonicalStackString(stackInfo) {\n        var canonicalStackString = '';\n        for(var i = 0; i < stackInfo.frames.length; i++){\n            var frame = stackInfo.frames[i];\n            var func = (0, $SbeVp.canonicalFunctionName)(frame.func);\n            if (canonicalStackString) canonicalStackString += '\\n';\n            if (func) canonicalStackString += func + '@';\n            if (typeof frame.url === 'string') canonicalStackString += frame.url;\n            if (frame.line) canonicalStackString += ':' + frame.line;\n        }\n        return canonicalStackString;\n    }\n    /**\n   *\n   * @param {Error|UncaughtError} err The error instance to be processed\n   * @param {number} time the relative ms (to origin) timestamp of occurence\n   * @param {boolean=} internal if the error was \"caught\" and deemed \"internal\" before reporting to the jserrors feature\n   * @param {object=} customAttributes  any custom attributes to be included in the error payload\n   * @param {boolean=} hasReplay a flag indicating if the error occurred during a replay session\n   * @param {string=} swallowReason a string indicating pre-defined reason if swallowing the error.  Mainly used by the internal error SMs.\n   * @param {object=} target the target to buffer and harvest to, if undefined the default configuration target is used\n   * @returns\n   */ storeError(err, time, internal, customAttributes, hasReplay, swallowReason, targetEntityGuid) {\n        if (!err) return;\n        const target = this.agentRef.runtime.entityManager.get(targetEntityGuid);\n        if (!target) return (0, $73gWV.warn)(56, this.featureName);\n        // are we in an interaction\n        time = time || (0, $7nvKd.now)();\n        let filterOutput;\n        if (!internal && this.agentRef.runtime.onerror) {\n            filterOutput = this.agentRef.runtime.onerror(err);\n            if (filterOutput && !(typeof filterOutput.group === 'string' && filterOutput.group.length)) // All truthy values mean don't report (store) the error, per backwards-compatible usage,\n            // - EXCEPT if a fingerprinting label is returned, via an object with key of 'group' and value of non-empty string\n            return;\n        // Again as with previous usage, all falsey values would include the error.\n        }\n        var stackInfo = (0, $5uIeW.computeStackTrace)(err);\n        const { shouldSwallow: shouldSwallow, reason: reason } = (0, $cultZ.evaluateInternalError)(stackInfo, internal, swallowReason);\n        if (shouldSwallow) {\n            this.reportSupportabilityMetric('Internal/Error/' + reason);\n            return;\n        }\n        var canonicalStackString = this.buildCanonicalStackString(stackInfo);\n        const params = {\n            stackHash: (0, $6ZO4b.stringHashCode)(canonicalStackString),\n            exceptionClass: stackInfo.name,\n            request_uri: (0, $7CBaz.globalScope)?.location.pathname\n        };\n        if (stackInfo.message) params.message = '' + stackInfo.message;\n        // Notice if filterOutput isn't false|undefined OR our specified object, this func would've returned already (so it's unnecessary to req-check group).\n        // Do not modify the name ('errorGroup') of params without DEM approval!\n        if (filterOutput?.group) params.errorGroup = filterOutput.group;\n        // Should only decorate \"hasReplay\" for the container agent, so check if the target matches the config\n        if (hasReplay && (0, $2cGfe.isContainerAgentTarget)(target, this.agentRef)) params.hasReplay = hasReplay;\n        /**\n     * The bucketHash is different from the params.stackHash because the params.stackHash is based on the canonicalized\n     * stack trace and is used downstream in NR1 to attempt to group the same errors across different browsers. However,\n     * the canonical stack trace excludes items like the column number increasing the hit-rate of different errors potentially\n     * bucketing and ultimately resulting in the loss of data in NR1.\n     */ var bucketHash = (0, $6ZO4b.stringHashCode)(\"\".concat(stackInfo.name, \"_\").concat(stackInfo.message, \"_\").concat(stackInfo.stackString, \"_\").concat(params.hasReplay ? 1 : 0));\n        if (!this.stackReported[bucketHash]) {\n            this.stackReported[bucketHash] = true;\n            params.stack_trace = (0, $fud0a.truncateSize)(stackInfo.stackString);\n            this.observedAt[bucketHash] = Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(time));\n        } else params.browser_stack_hash = (0, $6ZO4b.stringHashCode)(stackInfo.stackString);\n        params.releaseIds = (0, $gSI6b.stringify)(this.agentRef.runtime.releaseIds);\n        // When debugging stack canonicalization/hashing, uncomment these lines for\n        // more output in the test logs\n        // params.origStack = err.stack\n        // params.canonicalStack = canonicalStack\n        if (!this.pageviewReported[bucketHash]) {\n            params.pageview = 1;\n            this.pageviewReported[bucketHash] = true;\n        }\n        params.firstOccurrenceTimestamp = this.observedAt[bucketHash];\n        params.timestamp = Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(time));\n        var type = 'err';\n        var newMetrics = {\n            time: time\n        };\n        // Trace sends the error in its payload, and both trace & replay simply listens for any error to occur.\n        const jsErrorEvent = [\n            type,\n            bucketHash,\n            params,\n            newMetrics,\n            customAttributes\n        ];\n        if (this.shouldAllowMainAgentToCapture(targetEntityGuid)) (0, $dpdfa.handle)('trace-jserror', jsErrorEvent, undefined, (0, $gUmiN.FEATURE_NAMES).sessionTrace, this.ee);\n        // still send EE events for other features such as above, but stop this one from aggregating internal data\n        if (this.blocked) return;\n        if (err?.__newrelic?.[this.agentIdentifier]) {\n            params._interactionId = err.__newrelic[this.agentIdentifier].interactionId;\n            params._interactionNodeId = err.__newrelic[this.agentIdentifier].interactionNodeId;\n        }\n        if (this.shouldAllowMainAgentToCapture(targetEntityGuid)) {\n            const softNavInUse = Boolean(this.agentRef.features?.[(0, $gUmiN.FEATURE_NAMES).softNav]);\n            // Note: the following are subject to potential race cond wherein if the other feature aren't fully initialized, it'll be treated as there being no associated interaction.\n            // They each will also tack on their respective properties to the params object as part of the decision flow.\n            if (softNavInUse) (0, $dpdfa.handle)('jserror', [\n                params,\n                time\n            ], undefined, (0, $gUmiN.FEATURE_NAMES).softNav, this.ee);\n            else (0, $dpdfa.handle)('spa-jserror', jsErrorEvent, undefined, (0, $gUmiN.FEATURE_NAMES).spa, this.ee);\n            if (params.browserInteractionId && !params._softNavFinished) {\n                // hold onto the error until the in-progress interaction is done, eithered saved or discarded\n                this.bufferedErrorsUnderSpa[params.browserInteractionId] ??= [];\n                this.bufferedErrorsUnderSpa[params.browserInteractionId].push(jsErrorEvent);\n            } else if (params._interactionId != null) {\n                // same as above, except tailored for the way old spa does it\n                this.bufferedErrorsUnderSpa[params._interactionId] = this.bufferedErrorsUnderSpa[params._interactionId] || [];\n                this.bufferedErrorsUnderSpa[params._interactionId].push(jsErrorEvent);\n            } else // Either there is no interaction (then all these params properties will be undefined) OR there's a related soft navigation that's already completed.\n            // The old spa does not look up completed interactions at all, so there's no need to consider it.\n            this.#storeJserrorForHarvest(jsErrorEvent, params.browserInteractionId !== undefined, params._softNavAttributes);\n        }\n        // always add directly if scoped to a sub-entity, the other pathways above will be deterministic if the main agent should procede\n        if (targetEntityGuid) this.#storeJserrorForHarvest([\n            ...jsErrorEvent,\n            targetEntityGuid\n        ], false, params._softNavAttributes);\n    }\n    #storeJserrorForHarvest(errorInfoArr, softNavOccurredFinished, softNavCustomAttrs = {}) {\n        let [type, bucketHash, params, newMetrics, localAttrs, targetEntityGuid] = errorInfoArr;\n        const allCustomAttrs = {};\n        if (softNavOccurredFinished) {\n            Object.entries(softNavCustomAttrs).forEach(([k, v])=>setCustom(k, v)); // when an ixn finishes, it'll include stuff in jsAttributes + attrs specific to the ixn\n            bucketHash += params.browserInteractionId;\n            delete params._softNavAttributes; // cleanup temp properties from synchronous evaluation; this is harmless when async from soft nav (properties DNE)\n            delete params._softNavFinished;\n        } else {\n            // interaction was cancelled -> error should not be associated OR there was no interaction\n            Object.entries(this.agentRef.info.jsAttributes).forEach(([k, v])=>setCustom(k, v));\n            delete params.browserInteractionId;\n        }\n        if (localAttrs) Object.entries(localAttrs).forEach(([k, v])=>setCustom(k, v)); // local custom attrs are applied in either case with the highest precedence\n        const jsAttributesHash = (0, $6ZO4b.stringHashCode)((0, $gSI6b.stringify)(allCustomAttrs));\n        const aggregateHash = bucketHash + ':' + jsAttributesHash;\n        this.events.add([\n            type,\n            aggregateHash,\n            params,\n            newMetrics,\n            allCustomAttrs\n        ], targetEntityGuid);\n        function setCustom(key, val) {\n            allCustomAttrs[key] = val && typeof val === 'object' ? (0, $gSI6b.stringify)(val) : val;\n        }\n    }\n    /**\n  * If the event lacks an entityGuid (the default behavior), the main agent should capture the data. If the data is assigned to a sub-entity target\n  * the main agent should not capture events unless it is configured to do so.\n  * @param {string} entityGuid - the context object for the event\n  * @returns {boolean} - whether the main agent should capture the event to its internal target\n  */ shouldAllowMainAgentToCapture(entityGuid) {\n        return !entityGuid || this.agentRef.init.api.duplicate_registered_data;\n    }\n    // TO-DO: Remove this function when old spa is taken out. #storeJserrorForHarvest handles the work with the softnav feature.\n    onInteractionDone(interaction, wasSaved) {\n        if (!this.bufferedErrorsUnderSpa[interaction.id] || this.blocked) return;\n        this.bufferedErrorsUnderSpa[interaction.id].forEach((item)=>{\n            var allCustomAttrs = {};\n            const localCustomAttrs = item[4];\n            Object.entries(interaction.root.attrs.custom || {}).forEach(setCustom); // tack on custom attrs from the interaction\n            Object.entries(localCustomAttrs || {}).forEach(setCustom);\n            var params = item[2];\n            if (wasSaved) {\n                params.browserInteractionId = interaction.root.attrs.id;\n                if (params._interactionNodeId) params.parentNodeId = params._interactionNodeId.toString();\n            }\n            delete params._interactionId;\n            delete params._interactionNodeId;\n            var hash = wasSaved ? item[1] + interaction.root.attrs.id : item[1];\n            var jsAttributesHash = (0, $6ZO4b.stringHashCode)((0, $gSI6b.stringify)(allCustomAttrs));\n            var aggregateHash = hash + ':' + jsAttributesHash;\n            this.events.add([\n                item[0],\n                aggregateHash,\n                params,\n                item[3],\n                allCustomAttrs\n            ], item[5]);\n            function setCustom([key, val]) {\n                allCustomAttrs[key] = val && typeof val === 'object' ? (0, $gSI6b.stringify)(val) : val;\n            }\n        });\n        delete this.bufferedErrorsUnderSpa[interaction.id];\n    }\n    onSoftNavNotification(interactionId, wasFinished, softNavAttrs) {\n        if (this.blocked) return;\n        this.bufferedErrorsUnderSpa[interactionId]?.forEach((jsErrorEvent)=>this.#storeJserrorForHarvest(jsErrorEvent, wasFinished, softNavAttrs) // this should not modify the re-used softNavAttrs contents\n        );\n        delete this.bufferedErrorsUnderSpa[interactionId]; // wipe the list of jserrors so they aren't duplicated by another call to the same id\n    }\n}\n\n});\nparcelRegister(\"SbeVp\", function(module, exports) {\n\n$parcel$export(module.exports, \"canonicalFunctionName\", function () { return $0a2dc33c654d6cf4$export$a7dccd2ca7386fa3; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ const $0a2dc33c654d6cf4$var$canonicalFunctionNameRe = /([a-z0-9]+)$/i;\nfunction $0a2dc33c654d6cf4$export$a7dccd2ca7386fa3(functionNameString) {\n    if (!functionNameString) return;\n    const match = functionNameString.match($0a2dc33c654d6cf4$var$canonicalFunctionNameRe);\n    if (match) return match[1];\n}\n\n});\n\nparcelRegister(\"5uIeW\", function(module, exports) {\n\n$parcel$export(module.exports, \"computeStackTrace\", function () { return $400212405f32dc1e$export$81296eded4f2ac09; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ /* eslint-disable no-useless-escape */ // computeStackTrace: cross-browser stack traces in JavaScript\n//\n// Syntax:\n//   s = computeStackTrace(exception) // consider using TraceKit.report instead\n// Returns:\n//   s.name              - exception name\n//   s.message           - exception message\n//   s.stack[i].url      - JavaScript or HTML file URL\n//   s.stack[i].func     - function name, or empty for anonymous functions\n//   s.stack[i].line     - line number, if known\n//   s.stack[i].column   - column number, if known\n//   s.stack[i].context  - an array of source code lines; the middle element corresponds to the correct line#\n//   s.mode              - 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace\n//\n// Supports:\n//   - Firefox:  full stack trace with line numbers and unreliable column\n//               number on top frame\n//   - Chrome:   full stack trace with line and column numbers\n//   - Safari:   line and column number for the topmost stacktrace element\n//               only\n//   - IE:       no line numbers whatsoever\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\n\nvar $fud0a = parcelRequire(\"fud0a\");\n\nvar $641GF = parcelRequire(\"641GF\");\nvar $400212405f32dc1e$var$debug = false;\nvar $400212405f32dc1e$var$classNameRegex = /function (.+?)\\s*\\(/;\nvar $400212405f32dc1e$var$chrome = /^\\s*at (?:((?:\\[object object\\])?(?:[^(]*\\([^)]*\\))*[^()]*(?: \\[as \\S+\\])?) )?\\(?((?:file|http|https|chrome-extension):.*?)?:(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nvar $400212405f32dc1e$var$gecko = /^\\s*(?:(\\S*|global code)(?:\\(.*?\\))?@)?((?:file|http|https|chrome|safari-extension).*?):(\\d+)(?::(\\d+))?\\s*$/i;\nvar $400212405f32dc1e$var$chromeEval = /^\\s*at .+ \\(eval at \\S+ \\((?:(?:file|http|https):[^)]+)?\\)(?:, [^:]*:\\d+:\\d+)?\\)$/i;\nvar $400212405f32dc1e$var$ieEval = /^\\s*at Function code \\(Function code:\\d+:\\d+\\)\\s*/i;\nfunction $400212405f32dc1e$export$81296eded4f2ac09(ex) {\n    var stack = null;\n    try {\n        stack = $400212405f32dc1e$var$computeStackTraceFromStackProp(ex);\n        if (stack) return stack;\n    } catch (e) {\n        if ($400212405f32dc1e$var$debug) throw e;\n    }\n    try {\n        stack = $400212405f32dc1e$var$computeStackTraceBySourceAndLine(ex);\n        if (stack) return stack;\n    } catch (e) {\n        if ($400212405f32dc1e$var$debug) throw e;\n    }\n    try {\n        stack = $400212405f32dc1e$var$computeStackTraceWithMessageOnly(ex);\n        if (stack) return stack;\n    } catch (e) {\n        if ($400212405f32dc1e$var$debug) throw e;\n    }\n    return {\n        mode: 'failed',\n        stackString: '',\n        frames: []\n    };\n}\n/**\n * Computes stack trace information from the stack property. Chrome and Gecko use this property.\n *\n * @param {Error} ex - The error object to compute the stack trace for.\n * @return {?Object.<string, *>} Stack trace information.\n */ function $400212405f32dc1e$var$computeStackTraceFromStackProp(ex) {\n    if (!ex.stack) return null;\n    var errorInfo = ex.stack.split('\\n').reduce($400212405f32dc1e$var$parseStackProp, {\n        frames: [],\n        stackLines: [],\n        wrapperSeen: false\n    });\n    if (!errorInfo.frames.length) return null;\n    return {\n        mode: 'stack',\n        name: ex.name || $400212405f32dc1e$var$getClassName(ex),\n        message: ex.message,\n        stackString: (0, $fud0a.formatStackTrace)(errorInfo.stackLines),\n        frames: errorInfo.frames\n    };\n}\n/**\n * Parses a line from a JavaScript error stack trace and adds it to the given `info` object.\n * Ignores all stack entries thrown from one of our wrapper functions.\n *\n * @param {object} info - The `info` object to add the parsed line to.\n * @param {string} line - The line to parse.\n * @returns {object} The `info` object with the parsed line added.\n */ function $400212405f32dc1e$var$parseStackProp(info, line) {\n    let element = $400212405f32dc1e$var$getStackElement(line);\n    // This catches lines that aren't frames (like the first line stating the error).\n    if (!element) {\n        info.stackLines.push(line);\n        return info;\n    }\n    // Once we've seen a wrapper, ignore all subsequent stack entries.\n    if ($400212405f32dc1e$var$isNrWrapper(element.func)) info.wrapperSeen = true;\n    if (!info.wrapperSeen) {\n        // Query strings and fragments should be removed, and URLs matching the loader's origin should be \"<inline>\".\n        let canonicalUrl = (0, $641GF.canonicalizeUrl)(element.url);\n        if (canonicalUrl !== element.url) {\n            line = line.replace(element.url, canonicalUrl);\n            element.url = canonicalUrl;\n        }\n        info.stackLines.push(line);\n        info.frames.push(element);\n    }\n    return info;\n}\n/**\n * Parses a line from a JavaScript error stack trace to extract information about a stack trace element, such as the\n * URL, function name, line number, and column number.\n *\n * @param {string} line - A single line from a JavaScript error stack trace.\n * @returns {object} An object containing information about the stack trace element, including the URL, function\n *     name, line number, and column number (if available).\n */ function $400212405f32dc1e$var$getStackElement(line) {\n    var parts = line.match($400212405f32dc1e$var$gecko);\n    if (!parts) parts = line.match($400212405f32dc1e$var$chrome);\n    if (parts) return {\n        url: parts[2],\n        func: parts[1] !== 'Anonymous function' && parts[1] !== 'global code' && parts[1] || null,\n        line: +parts[3],\n        column: parts[4] ? +parts[4] : null\n    };\n    if (line.match($400212405f32dc1e$var$chromeEval) || line.match($400212405f32dc1e$var$ieEval) || line === 'anonymous') return {\n        func: 'evaluated code'\n    };\n}\n/**\n * Computes a stack trace object from an error object, by extracting the source and line number from the error object,\n * and using them to create a single stack frame.\n *\n * @param {Error} ex - The error object to compute the stack trace for.\n * @returns {Object|null} - An object representing the computed stack trace, or null if the\n * input error object does not contain a line number.\n */ function $400212405f32dc1e$var$computeStackTraceBySourceAndLine(ex) {\n    if (!('line' in ex)) return null;\n    var className = ex.name || $400212405f32dc1e$var$getClassName(ex);\n    // Safari does not provide a URL for errors in eval'd code\n    if (!ex.sourceURL) return {\n        mode: 'sourceline',\n        name: className,\n        message: ex.message,\n        stackString: className + ': ' + ex.message + '\\n    in evaluated code',\n        frames: [\n            {\n                func: 'evaluated code'\n            }\n        ]\n    };\n    // Remove any query string and fragment\n    var canonicalUrl = (0, $641GF.canonicalizeUrl)(ex.sourceURL);\n    var stackString = className + ': ' + ex.message + '\\n    at ' + canonicalUrl;\n    if (ex.line) {\n        stackString += ':' + ex.line;\n        if (ex.column) stackString += ':' + ex.column;\n    }\n    return {\n        mode: 'sourceline',\n        name: className,\n        message: ex.message,\n        stackString: stackString,\n        frames: [\n            {\n                url: canonicalUrl,\n                line: ex.line,\n                column: ex.column\n            }\n        ]\n    };\n}\n/**\n * For exceptions with no stack and only a message, derives a stack trace by extracting the class name and message.\n *\n * @param {Error} ex - The exception for which to compute the stack trace.\n * @returns {StackTrace} A stack trace object containing the name and message of the exception.\n */ function $400212405f32dc1e$var$computeStackTraceWithMessageOnly(ex) {\n    var className = ex.name || $400212405f32dc1e$var$getClassName(ex);\n    if (!className) return null;\n    return {\n        mode: 'nameonly',\n        name: className,\n        message: ex.message,\n        stackString: className + ': ' + ex.message,\n        frames: []\n    };\n}\n/**\n * Attempts to extract the name of the constructor function (the class) of the given object.\n *\n * @param {Object} obj - The object for which to extract the constructor function name.\n * @returns {string} The name of the constructor function, or 'unknown' if the name cannot be determined.\n */ function $400212405f32dc1e$var$getClassName(obj) {\n    var results = $400212405f32dc1e$var$classNameRegex.exec(String(obj.constructor));\n    return results && results.length > 1 ? results[1] : 'unknown';\n}\n/**\n * Checks whether the given function name is a New Relic wrapper function.\n *\n * @param {string} functionName - The name of the function to check.\n * @returns {boolean} True if the function name includes the string 'nrWrapper', false otherwise.\n */ function $400212405f32dc1e$var$isNrWrapper(functionName) {\n    return functionName && functionName.indexOf('nrWrapper') >= 0;\n}\n\n});\nparcelRegister(\"fud0a\", function(module, exports) {\n\n$parcel$export(module.exports, \"formatStackTrace\", function () { return $b463be3de8b8c9d9$export$a4cdcea3164173b0; });\n$parcel$export(module.exports, \"truncateSize\", function () { return $b463be3de8b8c9d9$export$692afaca433b0093; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ var $b463be3de8b8c9d9$var$stripNewlinesRegex = /^\\n+|\\n+$/g;\nvar $b463be3de8b8c9d9$var$MAX_STACK_TRACE_LENGTH = 65530;\nfunction $b463be3de8b8c9d9$export$a4cdcea3164173b0(stackLines) {\n    return $b463be3de8b8c9d9$var$truncateStackLines(stackLines).replace($b463be3de8b8c9d9$var$stripNewlinesRegex, '');\n}\n// takes array of stack lines and returns string with top 50 and buttom 50 lines\nfunction $b463be3de8b8c9d9$var$truncateStackLines(stackLines) {\n    var stackString;\n    if (stackLines.length > 100) {\n        var truncatedLines = stackLines.length - 100;\n        stackString = stackLines.slice(0, 50).join('\\n');\n        stackString += '\\n< ...truncated ' + truncatedLines + ' lines... >\\n';\n        stackString += stackLines.slice(-50).join('\\n');\n    } else stackString = stackLines.join('\\n');\n    return stackString;\n}\nfunction $b463be3de8b8c9d9$export$692afaca433b0093(stackString) {\n    return stackString.length > $b463be3de8b8c9d9$var$MAX_STACK_TRACE_LENGTH ? stackString.substr(0, $b463be3de8b8c9d9$var$MAX_STACK_TRACE_LENGTH) : stackString;\n}\n\n});\n\nparcelRegister(\"641GF\", function(module, exports) {\n\n$parcel$export(module.exports, \"canonicalizeUrl\", function () { return $46a46cd856af29e9$export$b7d2688d7e4c584a; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $7CBaz = parcelRequire(\"7CBaz\");\n\nvar $8o3mY = parcelRequire(\"8o3mY\");\nfunction $46a46cd856af29e9$export$b7d2688d7e4c584a(url) {\n    if (typeof url !== 'string') return '';\n    const cleanedUrl = (0, $8o3mY.cleanURL)(url);\n    const cleanedGlobalScopeUrl = (0, $8o3mY.cleanURL)((0, $7CBaz.initialLocation));\n    // If the URL matches the origin URL of the loader, we assume it originated within an inline script.\n    if (cleanedUrl === cleanedGlobalScopeUrl) return '<inline>';\n    else return cleanedUrl;\n}\n\n});\n\n\nparcelRegister(\"6ZO4b\", function(module, exports) {\n\n$parcel$export(module.exports, \"stringHashCode\", function () { return $517f46bcb1f15bf4$export$e5c81cd7751fb774; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ function $517f46bcb1f15bf4$export$e5c81cd7751fb774(string) {\n    var hash = 0;\n    var charVal;\n    if (!string || !string.length) return hash;\n    for(var i = 0; i < string.length; i++){\n        charVal = string.charCodeAt(i);\n        hash = (hash << 5) - hash + charVal;\n        hash = hash | 0; // Convert to 32bit integer\n    }\n    return hash;\n}\n\n});\n\nparcelRegister(\"jHSql\", function(module, exports) {\n\n$parcel$export(module.exports, \"applyFnToProps\", function () { return $e58c3fe7deaf7d4d$export$1091a5f4e456a123; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Applies a function to properties of a specified type in an object, recursively.\n *\n * @param {Object} obj - The object to apply the function to.\n * @param {Function} fn - The function to apply to matching properties.\n * @param {string} [type='string'] - The type of properties to apply the function to.\n * @param {Array<string>} [ignoreKeys=[]] - The keys of properties to ignore and not modify.\n * @returns {Object} - The object with function recursively applied.\n */ function $e58c3fe7deaf7d4d$export$1091a5f4e456a123(obj, fn, type = 'string', ignoreKeys = []) {\n    if (!obj || typeof obj !== 'object') return obj;\n    Object.keys(obj).forEach((property)=>{\n        if (typeof obj[property] === 'object') $e58c3fe7deaf7d4d$export$1091a5f4e456a123(obj[property], fn, type, ignoreKeys);\n        else // eslint-disable-next-line valid-typeof\n        if (typeof obj[property] === type && !ignoreKeys.includes(property)) obj[property] = fn(obj[property]);\n    });\n    return obj;\n}\n\n});\n\nparcelRegister(\"cultZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"evaluateInternalError\", function () { return $9178f361e2ca7b12$export$7bd55fb5e3cd865b; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ const $9178f361e2ca7b12$var$REASON_RRWEB = 'Rrweb';\nconst $9178f361e2ca7b12$var$REASON_SECURITY_POLICY = 'Security-Policy';\nfunction $9178f361e2ca7b12$export$7bd55fb5e3cd865b(stackInfo, internal, reason) {\n    const output = {\n        shouldSwallow: internal || false,\n        reason: reason || 'Other'\n    };\n    const leadingFrame = stackInfo.frames?.[0];\n    /** If we cant otherwise determine from the frames and message, the default of internal + reason will be the fallback */ if (!leadingFrame || typeof stackInfo?.message !== 'string') return output;\n    // check if the error happened in expected modules or if messages match known patterns\n    const isNrRecorder = leadingFrame?.url?.match(/nr-(.*)-recorder.min.js/);\n    const isRrweb = leadingFrame?.url?.match(/rrweb/);\n    const isMaybeNrRecorder = leadingFrame?.url?.match(/recorder/);\n    const isSecurityPolicyAPIError = stackInfo.message.toLowerCase().match(/an attempt was made to break through the security policy of the user agent/);\n    // check if modules and patterns above fit known swallow cases\n    if (!!isNrRecorder || !!isRrweb) {\n        /** We know -for sure- that the error came from our recorder module or rrweb directly if these are true, so swallow it */ output.shouldSwallow = true;\n        output.reason = $9178f361e2ca7b12$var$REASON_RRWEB;\n        if (isSecurityPolicyAPIError) output.reason += '-' + $9178f361e2ca7b12$var$REASON_SECURITY_POLICY;\n    } else if (!!isMaybeNrRecorder && isSecurityPolicyAPIError) {\n        /** We -suspect- that the error came from NR, so if it matches the exact case we know about, swallow it */ output.shouldSwallow = true;\n        output.reason = $9178f361e2ca7b12$var$REASON_RRWEB + '-' + $9178f361e2ca7b12$var$REASON_SECURITY_POLICY;\n    }\n    // other swallow conditions could also be added here\n    return output;\n}\n\n});\n\n\n})();\n//# sourceMappingURL=aggregate.8a9fd67f.js.map\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { canonicalFunctionName } from './canonical-function-name';\nimport { computeStackTrace } from './compute-stack-trace';\nimport { stringHashCode } from './string-hash-code';\nimport { truncateSize } from './format-stack-trace';\nimport { registerHandler as register } from '../../../common/event-emitter/register-handler';\nimport { stringify } from '../../../common/util/stringify';\nimport { handle } from '../../../common/event-emitter/handle';\nimport { globalScope } from '../../../common/constants/runtime';\nimport { FEATURE_NAME } from '../constants';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { now } from '../../../common/timing/now';\nimport { applyFnToProps } from '../../../common/util/traverse';\nimport { evaluateInternalError } from './internal-errors';\nimport { isContainerAgentTarget } from '../../../common/util/target';\nimport { warn } from '../../../common/util/console';\n\n/**\n * @typedef {import('./compute-stack-trace.js').StackInfo} StackInfo\n */\n\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentRef) {\n    super(agentRef, FEATURE_NAME);\n    this.stackReported = {};\n    this.observedAt = {};\n    this.pageviewReported = {};\n    this.bufferedErrorsUnderSpa = {};\n    this.errorOnPage = false;\n\n    // this will need to change to match whatever ee we use in the instrument\n    this.ee.on('interactionDone', (interaction, wasSaved) => this.onInteractionDone(interaction, wasSaved));\n    register('err', (...args) => this.storeError(...args), this.featureName, this.ee);\n    register('ierr', (...args) => this.storeError(...args), this.featureName, this.ee);\n    register('softNavFlush', (interactionId, wasFinished, softNavAttrs) => this.onSoftNavNotification(interactionId, wasFinished, softNavAttrs), this.featureName, this.ee); // when an ixn is done or cancelled\n\n    this.harvestOpts.aggregatorTypes = ['err', 'ierr', 'xhr']; // the types in EventAggregator this feature cares about\n\n    // 0 == off, 1 == on\n    this.waitForFlags(['err']).then(([errFlag]) => {\n      if (errFlag) {\n        this.drain();\n      } else {\n        this.blocked = true; // if rum response determines that customer lacks entitlements for spa endpoint, this feature shouldn't harvest\n        this.deregisterDrain();\n      }\n    });\n  }\n  serializer(aggregatorTypeToBucketsMap) {\n    return applyFnToProps(aggregatorTypeToBucketsMap, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string');\n  }\n  queryStringsBuilder(aggregatorTakeReturnedData) {\n    const qs = {};\n    const releaseIds = stringify(this.agentRef.runtime.releaseIds);\n    if (releaseIds !== '{}') qs.ri = releaseIds;\n    if (aggregatorTakeReturnedData?.err?.length) {\n      if (!this.errorOnPage) {\n        qs.pve = '1';\n        this.errorOnPage = true;\n      }\n      // For assurance, erase any `hasReplay` flag from all errors if replay is not recording, not-yet imported, or not running at all.\n      if (!this.agentRef.features?.[FEATURE_NAMES.sessionReplay]?.featAggregate?.replayIsActive()) aggregatorTakeReturnedData.err.forEach(error => delete error.params.hasReplay);\n    }\n    return qs;\n  }\n\n  /**\n   * Builds a standardized stack trace string from the frames in the given `stackInfo` object, with each frame separated\n   * by a newline character. Lines take the form `<functionName>@<url>:<lineNumber>`.\n   *\n   * @param {StackInfo} stackInfo - An object specifying a stack string and individual frames.\n   * @returns {string} A canonical stack string built from the URLs and function names in the given `stackInfo` object.\n   */\n  buildCanonicalStackString(stackInfo) {\n    var canonicalStackString = '';\n    for (var i = 0; i < stackInfo.frames.length; i++) {\n      var frame = stackInfo.frames[i];\n      var func = canonicalFunctionName(frame.func);\n      if (canonicalStackString) canonicalStackString += '\\n';\n      if (func) canonicalStackString += func + '@';\n      if (typeof frame.url === 'string') canonicalStackString += frame.url;\n      if (frame.line) canonicalStackString += ':' + frame.line;\n    }\n    return canonicalStackString;\n  }\n\n  /**\n   *\n   * @param {Error|UncaughtError} err The error instance to be processed\n   * @param {number} time the relative ms (to origin) timestamp of occurence\n   * @param {boolean=} internal if the error was \"caught\" and deemed \"internal\" before reporting to the jserrors feature\n   * @param {object=} customAttributes  any custom attributes to be included in the error payload\n   * @param {boolean=} hasReplay a flag indicating if the error occurred during a replay session\n   * @param {string=} swallowReason a string indicating pre-defined reason if swallowing the error.  Mainly used by the internal error SMs.\n   * @param {object=} target the target to buffer and harvest to, if undefined the default configuration target is used\n   * @returns\n   */\n  storeError(err, time, internal, customAttributes, hasReplay, swallowReason, targetEntityGuid) {\n    if (!err) return;\n    const target = this.agentRef.runtime.entityManager.get(targetEntityGuid);\n    if (!target) return warn(56, this.featureName);\n    // are we in an interaction\n    time = time || now();\n    let filterOutput;\n    if (!internal && this.agentRef.runtime.onerror) {\n      filterOutput = this.agentRef.runtime.onerror(err);\n      if (filterOutput && !(typeof filterOutput.group === 'string' && filterOutput.group.length)) {\n        // All truthy values mean don't report (store) the error, per backwards-compatible usage,\n        // - EXCEPT if a fingerprinting label is returned, via an object with key of 'group' and value of non-empty string\n        return;\n      }\n      // Again as with previous usage, all falsey values would include the error.\n    }\n    var stackInfo = computeStackTrace(err);\n    const {\n      shouldSwallow,\n      reason\n    } = evaluateInternalError(stackInfo, internal, swallowReason);\n    if (shouldSwallow) {\n      this.reportSupportabilityMetric('Internal/Error/' + reason);\n      return;\n    }\n    var canonicalStackString = this.buildCanonicalStackString(stackInfo);\n    const params = {\n      stackHash: stringHashCode(canonicalStackString),\n      exceptionClass: stackInfo.name,\n      request_uri: globalScope?.location.pathname\n    };\n    if (stackInfo.message) params.message = '' + stackInfo.message;\n    // Notice if filterOutput isn't false|undefined OR our specified object, this func would've returned already (so it's unnecessary to req-check group).\n    // Do not modify the name ('errorGroup') of params without DEM approval!\n    if (filterOutput?.group) params.errorGroup = filterOutput.group;\n\n    // Should only decorate \"hasReplay\" for the container agent, so check if the target matches the config\n    if (hasReplay && isContainerAgentTarget(target, this.agentRef)) params.hasReplay = hasReplay;\n    /**\n     * The bucketHash is different from the params.stackHash because the params.stackHash is based on the canonicalized\n     * stack trace and is used downstream in NR1 to attempt to group the same errors across different browsers. However,\n     * the canonical stack trace excludes items like the column number increasing the hit-rate of different errors potentially\n     * bucketing and ultimately resulting in the loss of data in NR1.\n     */\n    var bucketHash = stringHashCode(\"\".concat(stackInfo.name, \"_\").concat(stackInfo.message, \"_\").concat(stackInfo.stackString, \"_\").concat(params.hasReplay ? 1 : 0));\n    if (!this.stackReported[bucketHash]) {\n      this.stackReported[bucketHash] = true;\n      params.stack_trace = truncateSize(stackInfo.stackString);\n      this.observedAt[bucketHash] = Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(time));\n    } else {\n      params.browser_stack_hash = stringHashCode(stackInfo.stackString);\n    }\n    params.releaseIds = stringify(this.agentRef.runtime.releaseIds);\n\n    // When debugging stack canonicalization/hashing, uncomment these lines for\n    // more output in the test logs\n    // params.origStack = err.stack\n    // params.canonicalStack = canonicalStack\n\n    if (!this.pageviewReported[bucketHash]) {\n      params.pageview = 1;\n      this.pageviewReported[bucketHash] = true;\n    }\n    params.firstOccurrenceTimestamp = this.observedAt[bucketHash];\n    params.timestamp = Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(time));\n    var type = 'err';\n    var newMetrics = {\n      time\n    };\n\n    // Trace sends the error in its payload, and both trace & replay simply listens for any error to occur.\n    const jsErrorEvent = [type, bucketHash, params, newMetrics, customAttributes];\n    if (this.shouldAllowMainAgentToCapture(targetEntityGuid)) handle('trace-jserror', jsErrorEvent, undefined, FEATURE_NAMES.sessionTrace, this.ee);\n    // still send EE events for other features such as above, but stop this one from aggregating internal data\n    if (this.blocked) return;\n    if (err?.__newrelic?.[this.agentIdentifier]) {\n      params._interactionId = err.__newrelic[this.agentIdentifier].interactionId;\n      params._interactionNodeId = err.__newrelic[this.agentIdentifier].interactionNodeId;\n    }\n    if (this.shouldAllowMainAgentToCapture(targetEntityGuid)) {\n      const softNavInUse = Boolean(this.agentRef.features?.[FEATURE_NAMES.softNav]);\n      // Note: the following are subject to potential race cond wherein if the other feature aren't fully initialized, it'll be treated as there being no associated interaction.\n      // They each will also tack on their respective properties to the params object as part of the decision flow.\n      if (softNavInUse) handle('jserror', [params, time], undefined, FEATURE_NAMES.softNav, this.ee);else handle('spa-jserror', jsErrorEvent, undefined, FEATURE_NAMES.spa, this.ee);\n      if (params.browserInteractionId && !params._softNavFinished) {\n        // hold onto the error until the in-progress interaction is done, eithered saved or discarded\n        this.bufferedErrorsUnderSpa[params.browserInteractionId] ??= [];\n        this.bufferedErrorsUnderSpa[params.browserInteractionId].push(jsErrorEvent);\n      } else if (params._interactionId != null) {\n        // same as above, except tailored for the way old spa does it\n        this.bufferedErrorsUnderSpa[params._interactionId] = this.bufferedErrorsUnderSpa[params._interactionId] || [];\n        this.bufferedErrorsUnderSpa[params._interactionId].push(jsErrorEvent);\n      } else {\n        // Either there is no interaction (then all these params properties will be undefined) OR there's a related soft navigation that's already completed.\n        // The old spa does not look up completed interactions at all, so there's no need to consider it.\n        this.#storeJserrorForHarvest(jsErrorEvent, params.browserInteractionId !== undefined, params._softNavAttributes);\n      }\n    }\n\n    // always add directly if scoped to a sub-entity, the other pathways above will be deterministic if the main agent should procede\n    if (targetEntityGuid) this.#storeJserrorForHarvest([...jsErrorEvent, targetEntityGuid], false, params._softNavAttributes);\n  }\n  #storeJserrorForHarvest(errorInfoArr, softNavOccurredFinished, softNavCustomAttrs = {}) {\n    let [type, bucketHash, params, newMetrics, localAttrs, targetEntityGuid] = errorInfoArr;\n    const allCustomAttrs = {};\n    if (softNavOccurredFinished) {\n      Object.entries(softNavCustomAttrs).forEach(([k, v]) => setCustom(k, v)); // when an ixn finishes, it'll include stuff in jsAttributes + attrs specific to the ixn\n      bucketHash += params.browserInteractionId;\n      delete params._softNavAttributes; // cleanup temp properties from synchronous evaluation; this is harmless when async from soft nav (properties DNE)\n      delete params._softNavFinished;\n    } else {\n      // interaction was cancelled -> error should not be associated OR there was no interaction\n      Object.entries(this.agentRef.info.jsAttributes).forEach(([k, v]) => setCustom(k, v));\n      delete params.browserInteractionId;\n    }\n    if (localAttrs) Object.entries(localAttrs).forEach(([k, v]) => setCustom(k, v)); // local custom attrs are applied in either case with the highest precedence\n\n    const jsAttributesHash = stringHashCode(stringify(allCustomAttrs));\n    const aggregateHash = bucketHash + ':' + jsAttributesHash;\n    this.events.add([type, aggregateHash, params, newMetrics, allCustomAttrs], targetEntityGuid);\n    function setCustom(key, val) {\n      allCustomAttrs[key] = val && typeof val === 'object' ? stringify(val) : val;\n    }\n  }\n\n  /**\n  * If the event lacks an entityGuid (the default behavior), the main agent should capture the data. If the data is assigned to a sub-entity target\n  * the main agent should not capture events unless it is configured to do so.\n  * @param {string} entityGuid - the context object for the event\n  * @returns {boolean} - whether the main agent should capture the event to its internal target\n  */\n  shouldAllowMainAgentToCapture(entityGuid) {\n    return !entityGuid || this.agentRef.init.api.duplicate_registered_data;\n  }\n\n  // TO-DO: Remove this function when old spa is taken out. #storeJserrorForHarvest handles the work with the softnav feature.\n  onInteractionDone(interaction, wasSaved) {\n    if (!this.bufferedErrorsUnderSpa[interaction.id] || this.blocked) return;\n    this.bufferedErrorsUnderSpa[interaction.id].forEach(item => {\n      var allCustomAttrs = {};\n      const localCustomAttrs = item[4];\n      Object.entries(interaction.root.attrs.custom || {}).forEach(setCustom); // tack on custom attrs from the interaction\n      Object.entries(localCustomAttrs || {}).forEach(setCustom);\n      var params = item[2];\n      if (wasSaved) {\n        params.browserInteractionId = interaction.root.attrs.id;\n        if (params._interactionNodeId) params.parentNodeId = params._interactionNodeId.toString();\n      }\n      delete params._interactionId;\n      delete params._interactionNodeId;\n      var hash = wasSaved ? item[1] + interaction.root.attrs.id : item[1];\n      var jsAttributesHash = stringHashCode(stringify(allCustomAttrs));\n      var aggregateHash = hash + ':' + jsAttributesHash;\n      this.events.add([item[0], aggregateHash, params, item[3], allCustomAttrs], item[5]);\n      function setCustom([key, val]) {\n        allCustomAttrs[key] = val && typeof val === 'object' ? stringify(val) : val;\n      }\n    });\n    delete this.bufferedErrorsUnderSpa[interaction.id];\n  }\n  onSoftNavNotification(interactionId, wasFinished, softNavAttrs) {\n    if (this.blocked) return;\n    this.bufferedErrorsUnderSpa[interactionId]?.forEach(jsErrorEvent => this.#storeJserrorForHarvest(jsErrorEvent, wasFinished, softNavAttrs) // this should not modify the re-used softNavAttrs contents\n    );\n    delete this.bufferedErrorsUnderSpa[interactionId]; // wipe the list of jserrors so they aren't duplicated by another call to the same id\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst canonicalFunctionNameRe = /([a-z0-9]+)$/i;\n\n/**\n * Given a function name string, extracts only an alphanumeric segment at the end of the string (if one exists).\n * This is useful for stack traces, where functions might not be named (e.g., anonymous, computed).\n *\n * @param {string} functionNameString - The original function name string.\n * @returns {string|undefined} The canonical function name, or undefined if the input is falsy or no alphanumeric segments are found.\n */\nexport function canonicalFunctionName(functionNameString) {\n  if (!functionNameString) return;\n  const match = functionNameString.match(canonicalFunctionNameRe);\n  if (match) return match[1];\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable no-useless-escape */\n\n// computeStackTrace: cross-browser stack traces in JavaScript\n//\n// Syntax:\n//   s = computeStackTrace(exception) // consider using TraceKit.report instead\n// Returns:\n//   s.name              - exception name\n//   s.message           - exception message\n//   s.stack[i].url      - JavaScript or HTML file URL\n//   s.stack[i].func     - function name, or empty for anonymous functions\n//   s.stack[i].line     - line number, if known\n//   s.stack[i].column   - column number, if known\n//   s.stack[i].context  - an array of source code lines; the middle element corresponds to the correct line#\n//   s.mode              - 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace\n//\n// Supports:\n//   - Firefox:  full stack trace with line numbers and unreliable column\n//               number on top frame\n//   - Chrome:   full stack trace with line and column numbers\n//   - Safari:   line and column number for the topmost stacktrace element\n//               only\n//   - IE:       no line numbers whatsoever\n\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\nimport { formatStackTrace } from './format-stack-trace';\nimport { canonicalizeUrl } from '../../../common/url/canonicalize-url';\nvar debug = false;\nvar classNameRegex = /function (.+?)\\s*\\(/;\nvar chrome = /^\\s*at (?:((?:\\[object object\\])?(?:[^(]*\\([^)]*\\))*[^()]*(?: \\[as \\S+\\])?) )?\\(?((?:file|http|https|chrome-extension):.*?)?:(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nvar gecko = /^\\s*(?:(\\S*|global code)(?:\\(.*?\\))?@)?((?:file|http|https|chrome|safari-extension).*?):(\\d+)(?::(\\d+))?\\s*$/i;\nvar chromeEval = /^\\s*at .+ \\(eval at \\S+ \\((?:(?:file|http|https):[^)]+)?\\)(?:, [^:]*:\\d+:\\d+)?\\)$/i;\nvar ieEval = /^\\s*at Function code \\(Function code:\\d+:\\d+\\)\\s*/i;\n\n/**\n * Represents an error with a stack trace.\n * @typedef {Object} StackInfo\n * @property {string} name - The name of the error (e.g. 'TypeError').\n * @property {string} message - The error message.\n * @property {string} stackString - The stack trace as a string.\n * @property {Array<Object>} frames - An array of frames in the stack trace.\n * @property {string} frames.url - The URL of the file containing the code for the frame.\n * @property {string} frames.func - The name of the function associated with the frame.\n * @property {number} frames.line - The line number of the code in the frame.\n */\n\n/**\n * Attempts to compute a stack trace for the given exception.\n * @param {Error} ex - The exception for which to compute the stack trace.\n * @returns {StackInfo} A stack trace object containing information about the frames on the stack.\n */\nexport function computeStackTrace(ex) {\n  var stack = null;\n  try {\n    stack = computeStackTraceFromStackProp(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n  try {\n    stack = computeStackTraceBySourceAndLine(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n  try {\n    stack = computeStackTraceWithMessageOnly(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n  return {\n    mode: 'failed',\n    stackString: '',\n    frames: []\n  };\n}\n\n/**\n * Computes stack trace information from the stack property. Chrome and Gecko use this property.\n *\n * @param {Error} ex - The error object to compute the stack trace for.\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStackProp(ex) {\n  if (!ex.stack) {\n    return null;\n  }\n  var errorInfo = ex.stack.split('\\n').reduce(parseStackProp, {\n    frames: [],\n    stackLines: [],\n    wrapperSeen: false\n  });\n  if (!errorInfo.frames.length) return null;\n  return {\n    mode: 'stack',\n    name: ex.name || getClassName(ex),\n    message: ex.message,\n    stackString: formatStackTrace(errorInfo.stackLines),\n    frames: errorInfo.frames\n  };\n}\n\n/**\n * Parses a line from a JavaScript error stack trace and adds it to the given `info` object.\n * Ignores all stack entries thrown from one of our wrapper functions.\n *\n * @param {object} info - The `info` object to add the parsed line to.\n * @param {string} line - The line to parse.\n * @returns {object} The `info` object with the parsed line added.\n */\nfunction parseStackProp(info, line) {\n  let element = getStackElement(line);\n\n  // This catches lines that aren't frames (like the first line stating the error).\n  if (!element) {\n    info.stackLines.push(line);\n    return info;\n  }\n\n  // Once we've seen a wrapper, ignore all subsequent stack entries.\n  if (isNrWrapper(element.func)) info.wrapperSeen = true;\n  if (!info.wrapperSeen) {\n    // Query strings and fragments should be removed, and URLs matching the loader's origin should be \"<inline>\".\n    let canonicalUrl = canonicalizeUrl(element.url);\n    if (canonicalUrl !== element.url) {\n      line = line.replace(element.url, canonicalUrl);\n      element.url = canonicalUrl;\n    }\n    info.stackLines.push(line);\n    info.frames.push(element);\n  }\n  return info;\n}\n\n/**\n * Parses a line from a JavaScript error stack trace to extract information about a stack trace element, such as the\n * URL, function name, line number, and column number.\n *\n * @param {string} line - A single line from a JavaScript error stack trace.\n * @returns {object} An object containing information about the stack trace element, including the URL, function\n *     name, line number, and column number (if available).\n */\nfunction getStackElement(line) {\n  var parts = line.match(gecko);\n  if (!parts) parts = line.match(chrome);\n  if (parts) {\n    return {\n      url: parts[2],\n      func: parts[1] !== 'Anonymous function' && parts[1] !== 'global code' && parts[1] || null,\n      line: +parts[3],\n      column: parts[4] ? +parts[4] : null\n    };\n  }\n  if (line.match(chromeEval) || line.match(ieEval) || line === 'anonymous') {\n    return {\n      func: 'evaluated code'\n    };\n  }\n}\n\n/**\n * Computes a stack trace object from an error object, by extracting the source and line number from the error object,\n * and using them to create a single stack frame.\n *\n * @param {Error} ex - The error object to compute the stack trace for.\n * @returns {Object|null} - An object representing the computed stack trace, or null if the\n * input error object does not contain a line number.\n */\nfunction computeStackTraceBySourceAndLine(ex) {\n  if (!('line' in ex)) return null;\n  var className = ex.name || getClassName(ex);\n\n  // Safari does not provide a URL for errors in eval'd code\n  if (!ex.sourceURL) {\n    return {\n      mode: 'sourceline',\n      name: className,\n      message: ex.message,\n      stackString: className + ': ' + ex.message + '\\n    in evaluated code',\n      frames: [{\n        func: 'evaluated code'\n      }]\n    };\n  }\n\n  // Remove any query string and fragment\n  var canonicalUrl = canonicalizeUrl(ex.sourceURL);\n  var stackString = className + ': ' + ex.message + '\\n    at ' + canonicalUrl;\n  if (ex.line) {\n    stackString += ':' + ex.line;\n    if (ex.column) {\n      stackString += ':' + ex.column;\n    }\n  }\n  return {\n    mode: 'sourceline',\n    name: className,\n    message: ex.message,\n    stackString,\n    frames: [{\n      url: canonicalUrl,\n      line: ex.line,\n      column: ex.column\n    }]\n  };\n}\n\n/**\n * For exceptions with no stack and only a message, derives a stack trace by extracting the class name and message.\n *\n * @param {Error} ex - The exception for which to compute the stack trace.\n * @returns {StackTrace} A stack trace object containing the name and message of the exception.\n */\nfunction computeStackTraceWithMessageOnly(ex) {\n  var className = ex.name || getClassName(ex);\n  if (!className) return null;\n  return {\n    mode: 'nameonly',\n    name: className,\n    message: ex.message,\n    stackString: className + ': ' + ex.message,\n    frames: []\n  };\n}\n\n/**\n * Attempts to extract the name of the constructor function (the class) of the given object.\n *\n * @param {Object} obj - The object for which to extract the constructor function name.\n * @returns {string} The name of the constructor function, or 'unknown' if the name cannot be determined.\n */\nfunction getClassName(obj) {\n  var results = classNameRegex.exec(String(obj.constructor));\n  return results && results.length > 1 ? results[1] : 'unknown';\n}\n\n/**\n * Checks whether the given function name is a New Relic wrapper function.\n *\n * @param {string} functionName - The name of the function to check.\n * @returns {boolean} True if the function name includes the string 'nrWrapper', false otherwise.\n */\nfunction isNrWrapper(functionName) {\n  return functionName && functionName.indexOf('nrWrapper') >= 0;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stripNewlinesRegex = /^\\n+|\\n+$/g;\nvar MAX_STACK_TRACE_LENGTH = 65530;\nexport function formatStackTrace(stackLines) {\n  return truncateStackLines(stackLines).replace(stripNewlinesRegex, '');\n}\n\n// takes array of stack lines and returns string with top 50 and buttom 50 lines\nfunction truncateStackLines(stackLines) {\n  var stackString;\n  if (stackLines.length > 100) {\n    var truncatedLines = stackLines.length - 100;\n    stackString = stackLines.slice(0, 50).join('\\n');\n    stackString += '\\n< ...truncated ' + truncatedLines + ' lines... >\\n';\n    stackString += stackLines.slice(-50).join('\\n');\n  } else {\n    stackString = stackLines.join('\\n');\n  }\n  return stackString;\n}\n\n// truncates stack string to limit what is sent to backend\nexport function truncateSize(stackString) {\n  return stackString.length > MAX_STACK_TRACE_LENGTH ? stackString.substr(0, MAX_STACK_TRACE_LENGTH) : stackString;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { initialLocation } from '../constants/runtime';\nimport { cleanURL } from './clean-url';\n\n/**\n * Converts a URL to its basic form without a query string or fragment. If the resulting URL is the same as the\n * loader's origin URL, returns '<inline>'.\n * @param {string} url - The URL to be canonicalized.\n * @param {string} loaderOriginUrl - The origin URL of the agent loader, used for inline detection.\n * @returns {string} The canonicalized URL, or '<inline>' if the URL matches the loader origin URL.\n */\nexport function canonicalizeUrl(url) {\n  if (typeof url !== 'string') return '';\n  const cleanedUrl = cleanURL(url);\n  const cleanedGlobalScopeUrl = cleanURL(initialLocation);\n\n  // If the URL matches the origin URL of the loader, we assume it originated within an inline script.\n  if (cleanedUrl === cleanedGlobalScopeUrl) {\n    return '<inline>';\n  } else {\n    return cleanedUrl;\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport function stringHashCode(string) {\n  var hash = 0;\n  var charVal;\n  if (!string || !string.length) return hash;\n  for (var i = 0; i < string.length; i++) {\n    charVal = string.charCodeAt(i);\n    hash = (hash << 5) - hash + charVal;\n    hash = hash | 0; // Convert to 32bit integer\n  }\n  return hash;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Applies a function to properties of a specified type in an object, recursively.\n *\n * @param {Object} obj - The object to apply the function to.\n * @param {Function} fn - The function to apply to matching properties.\n * @param {string} [type='string'] - The type of properties to apply the function to.\n * @param {Array<string>} [ignoreKeys=[]] - The keys of properties to ignore and not modify.\n * @returns {Object} - The object with function recursively applied.\n */\nexport function applyFnToProps(obj, fn, type = 'string', ignoreKeys = []) {\n  if (!obj || typeof obj !== 'object') return obj;\n  Object.keys(obj).forEach(property => {\n    if (typeof obj[property] === 'object') {\n      applyFnToProps(obj[property], fn, type, ignoreKeys);\n    } else {\n      // eslint-disable-next-line valid-typeof\n      if (typeof obj[property] === type && !ignoreKeys.includes(property)) obj[property] = fn(obj[property]);\n    }\n  });\n  return obj;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nconst REASON_RRWEB = 'Rrweb';\nconst REASON_SECURITY_POLICY = 'Security-Policy';\n/**\n * This function is responsible for determining if an error should be swallowed or not.\n * @param {Object} stackInfo - The error stack information.\n * @returns {boolean} - Whether the error should be swallowed or not.\n */\nexport function evaluateInternalError(stackInfo, internal, reason) {\n  const output = {\n    shouldSwallow: internal || false,\n    reason: reason || 'Other'\n  };\n  const leadingFrame = stackInfo.frames?.[0];\n  /** If we cant otherwise determine from the frames and message, the default of internal + reason will be the fallback */\n  if (!leadingFrame || typeof stackInfo?.message !== 'string') return output;\n\n  // check if the error happened in expected modules or if messages match known patterns\n  const isNrRecorder = leadingFrame?.url?.match(/nr-(.*)-recorder.min.js/);\n  const isRrweb = leadingFrame?.url?.match(/rrweb/);\n  const isMaybeNrRecorder = leadingFrame?.url?.match(/recorder/);\n  const isSecurityPolicyAPIError = stackInfo.message.toLowerCase().match(/an attempt was made to break through the security policy of the user agent/);\n\n  // check if modules and patterns above fit known swallow cases\n  if (!!isNrRecorder || !!isRrweb) {\n    /** We know -for sure- that the error came from our recorder module or rrweb directly if these are true, so swallow it */\n    output.shouldSwallow = true;\n    output.reason = REASON_RRWEB;\n    if (isSecurityPolicyAPIError) output.reason += '-' + REASON_SECURITY_POLICY;\n  } else if (!!isMaybeNrRecorder && isSecurityPolicyAPIError) {\n    /** We -suspect- that the error came from NR, so if it matches the exact case we know about, swallow it */\n    output.shouldSwallow = true;\n    output.reason = REASON_RRWEB + '-' + REASON_SECURITY_POLICY;\n  }\n  // other swallow conditions could also be added here\n  return output;\n}"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","self","window","global","parcelRegister","register","module","exports","$d0d4f473ea290e09$export$b9601df20779e14a","$SbeVp","$5uIeW","$6ZO4b","$fud0a","$8auZx","$gSI6b","$dpdfa","$7CBaz","$8g4Aw","$gUmiN","$6Lc7k","$7nvKd","$jHSql","$cultZ","$2cGfe","$73gWV","AggregateBase","featureName","FEATURE_NAME","constructor","agentRef","stackReported","observedAt","pageviewReported","bufferedErrorsUnderSpa","errorOnPage","ee","on","interaction","wasSaved","onInteractionDone","registerHandler","args","storeError","interactionId","wasFinished","softNavAttrs","onSoftNavNotification","harvestOpts","aggregatorTypes","waitForFlags","then","errFlag","drain","blocked","deregisterDrain","serializer","aggregatorTypeToBucketsMap","applyFnToProps","obfuscator","obfuscateString","bind","queryStringsBuilder","aggregatorTakeReturnedData","qs","releaseIds","stringify","runtime","ri","err","length","pve","features","FEATURE_NAMES","sessionReplay","featAggregate","replayIsActive","forEach","error","params","hasReplay","buildCanonicalStackString","stackInfo","canonicalStackString","i","frames","frame","func","canonicalFunctionName","url","line","time","internal","customAttributes","swallowReason","targetEntityGuid","filterOutput","target","entityManager","warn","now","onerror","group","computeStackTrace","shouldSwallow","reason","evaluateInternalError","reportSupportabilityMetric","stackHash","stringHashCode","exceptionClass","name","request_uri","globalScope","location","pathname","message","errorGroup","isContainerAgentTarget","bucketHash","concat","stackString","browser_stack_hash","stack_trace","truncateSize","Math","floor","timeKeeper","correctRelativeTimestamp","pageview","firstOccurrenceTimestamp","timestamp","jsErrorEvent","shouldAllowMainAgentToCapture","handle","undefined","sessionTrace","__newrelic","agentIdentifier","_interactionId","_interactionNodeId","interactionNodeId","softNav","spa","browserInteractionId","_softNavFinished","push","_softNavAttributes","errorInfoArr","softNavOccurredFinished","softNavCustomAttrs","type","newMetrics","localAttrs","allCustomAttrs","entries","k","setCustom","info","jsAttributes","aggregateHash","key","val","events","add","entityGuid","init","api","duplicate_registered_data","id","item","localCustomAttrs","root","attrs","custom","parentNodeId","toString","hash","jsAttributesHash","$0a2dc33c654d6cf4$export$a7dccd2ca7386fa3","$0a2dc33c654d6cf4$var$canonicalFunctionNameRe","functionNameString","match","$400212405f32dc1e$export$81296eded4f2ac09","$641GF","$400212405f32dc1e$var$classNameRegex","$400212405f32dc1e$var$chrome","$400212405f32dc1e$var$gecko","$400212405f32dc1e$var$chromeEval","$400212405f32dc1e$var$ieEval","ex","className","stack","$400212405f32dc1e$var$computeStackTraceFromStackProp","errorInfo","split","reduce","$400212405f32dc1e$var$parseStackProp","stackLines","wrapperSeen","mode","$400212405f32dc1e$var$getClassName","formatStackTrace","$400212405f32dc1e$var$computeStackTraceBySourceAndLine","sourceURL","canonicalUrl","canonicalizeUrl","column","parts","functionName","element","$400212405f32dc1e$var$isNrWrapper","indexOf","replace","obj","results","exec","String","$b463be3de8b8c9d9$export$a4cdcea3164173b0","$b463be3de8b8c9d9$export$692afaca433b0093","$b463be3de8b8c9d9$var$stripNewlinesRegex","$b463be3de8b8c9d9$var$truncateStackLines","truncatedLines","slice","join","substr","$46a46cd856af29e9$export$b7d2688d7e4c584a","$8o3mY","cleanedUrl","cleanURL","initialLocation","$517f46bcb1f15bf4$export$e5c81cd7751fb774","string","charCodeAt","$e58c3fe7deaf7d4d$export$1091a5f4e456a123","fn","ignoreKeys","keys","property","includes","$9178f361e2ca7b12$export$7bd55fb5e3cd865b","$9178f361e2ca7b12$var$REASON_RRWEB","$9178f361e2ca7b12$var$REASON_SECURITY_POLICY","output","leadingFrame","isNrRecorder","isRrweb","isMaybeNrRecorder","isSecurityPolicyAPIError","toLowerCase"],"version":3,"file":"aggregate.8a9fd67f.js.map"}
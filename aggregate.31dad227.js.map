{"mappings":"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","sources":["<anon>","node_modules/@newrelic/browser-agent/dist/esm/features/generic_events/aggregate/index.js","node_modules/@newrelic/browser-agent/dist/esm/common/util/traverse.js","node_modules/@newrelic/browser-agent/dist/esm/features/generic_events/aggregate/user-actions/user-actions-aggregator.js","node_modules/@newrelic/browser-agent/dist/esm/common/dom/selector-path.js","node_modules/@newrelic/browser-agent/dist/esm/features/generic_events/aggregate/user-actions/aggregated-user-action.js","node_modules/@newrelic/browser-agent/dist/esm/common/dom/iframe.js","node_modules/@newrelic/browser-agent/dist/esm/common/util/type-check.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire5e30\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"jBB2H\", function(module, exports) {\n\n$parcel$export(module.exports, \"Aggregate\", function () { return $e45e34e206901505$export$b9601df20779e14a; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $8KO5M = parcelRequire(\"8KO5M\");\n\nvar $jWywI = parcelRequire(\"jWywI\");\n\nvar $4UPGI = parcelRequire(\"4UPGI\");\n\nvar $9EKMI = parcelRequire(\"9EKMI\");\n\nvar $3DmF0 = parcelRequire(\"3DmF0\");\n\nvar $jkuUu = parcelRequire(\"jkuUu\");\n\nvar $1Z3KE = parcelRequire(\"1Z3KE\");\n\nvar $4he1m = parcelRequire(\"4he1m\");\n\nvar $bu0p3 = parcelRequire(\"bu0p3\");\n\nvar $hcIxM = parcelRequire(\"hcIxM\");\n\nvar $b7nLr = parcelRequire(\"b7nLr\");\n\nvar $e29aQ = parcelRequire(\"e29aQ\");\n\nvar $8tgg9 = parcelRequire(\"8tgg9\");\nclass $e45e34e206901505$export$b9601df20779e14a extends (0, $3DmF0.AggregateBase) {\n    static featureName = (0, $4UPGI.FEATURE_NAME);\n    constructor(agentRef){\n        super(agentRef, (0, $4UPGI.FEATURE_NAME));\n        this.eventsPerHarvest = 1000;\n        this.referrerUrl = (0, $9EKMI.isBrowserScope) && document.referrer ? (0, $jWywI.cleanURL)(document.referrer) : undefined;\n        this.waitForFlags([\n            'ins'\n        ]).then(([ins])=>{\n            if (!ins) {\n                this.blocked = true;\n                this.deregisterDrain();\n                return;\n            }\n            this.trackSupportabilityMetrics();\n            (0, $4he1m.registerHandler)('api-recordCustomEvent', (timestamp, eventType, attributes)=>{\n                if ((0, $4UPGI.RESERVED_EVENT_TYPES).includes(eventType)) return (0, $jkuUu.warn)(46);\n                this.addEvent({\n                    eventType: eventType,\n                    timestamp: this.toEpoch(timestamp),\n                    ...attributes\n                });\n            }, this.featureName, this.ee);\n            if (agentRef.init.page_action.enabled) (0, $4he1m.registerHandler)('api-addPageAction', (timestamp, name, attributes, targetEntityGuid)=>{\n                if (!this.agentRef.runtime.entityManager.get(targetEntityGuid)) return (0, $jkuUu.warn)(56, this.featureName);\n                this.addEvent({\n                    ...attributes,\n                    eventType: 'PageAction',\n                    timestamp: this.toEpoch(timestamp),\n                    timeSinceLoad: timestamp / 1000,\n                    actionName: name,\n                    referrerUrl: this.referrerUrl,\n                    ...(0, $9EKMI.isBrowserScope) && {\n                        browserWidth: window.document.documentElement?.clientWidth,\n                        browserHeight: window.document.documentElement?.clientHeight\n                    }\n                }, targetEntityGuid);\n            }, this.featureName, this.ee);\n            let addUserAction = ()=>{};\n            if ((0, $9EKMI.isBrowserScope) && agentRef.init.user_actions.enabled) {\n                this.userActionAggregator = new (0, $b7nLr.UserActionsAggregator)();\n                this.harvestOpts.beforeUnload = ()=>addUserAction?.(this.userActionAggregator.aggregationEvent);\n                addUserAction = (aggregatedUserAction)=>{\n                    try {\n                        /** The aggregator process only returns an event when it is \"done\" aggregating -\n             * so we still need to validate that an event was given to this method before we try to add */ if (aggregatedUserAction?.event) {\n                            const { target: target, timeStamp: timeStamp, type: type } = aggregatedUserAction.event;\n                            this.addEvent({\n                                eventType: 'UserAction',\n                                timestamp: this.toEpoch(timeStamp),\n                                action: type,\n                                actionCount: aggregatedUserAction.count,\n                                actionDuration: aggregatedUserAction.relativeMs[aggregatedUserAction.relativeMs.length - 1],\n                                actionMs: aggregatedUserAction.relativeMs,\n                                rageClick: aggregatedUserAction.rageClick,\n                                target: aggregatedUserAction.selectorPath,\n                                ...(0, $e29aQ.isIFrameWindow)(window) && {\n                                    iframe: true\n                                },\n                                ...this.agentRef.init.user_actions.elementAttributes.reduce((acc, field)=>{\n                                    /** prevent us from capturing an obscenely long value */ if (canTrustTargetAttribute(field)) acc[targetAttrName(field)] = String(target[field]).trim().slice(0, 128);\n                                    return acc;\n                                }, {}),\n                                ...aggregatedUserAction.nearestTargetFields\n                            });\n                            /**\n               * Returns the original target field name with `target` prepended and camelCased\n               * @param {string} originalFieldName\n               * @returns {string} the target field name\n               */ function targetAttrName(originalFieldName) {\n                                /** preserve original renaming structure for pre-existing field maps */ if (originalFieldName === 'tagName') originalFieldName = 'tag';\n                                if (originalFieldName === 'className') originalFieldName = 'class';\n                                /** return the original field name, cap'd and prepended with target to match formatting */ return \"target\".concat(originalFieldName.charAt(0).toUpperCase() + originalFieldName.slice(1));\n                            }\n                            /**\n               * Only trust attributes that exist on HTML element targets, which excludes the window and the document targets\n               * @param {string} attribute The attribute to check for on the target element\n               * @returns {boolean} Whether the target element has the attribute and can be trusted\n               */ function canTrustTargetAttribute(attribute) {\n                                return !!(aggregatedUserAction.selectorPath !== 'window' && aggregatedUserAction.selectorPath !== 'document' && target instanceof HTMLElement && target?.[attribute]);\n                            }\n                        }\n                    } catch (e) {\n                    // do nothing for now\n                    }\n                };\n                (0, $4he1m.registerHandler)('ua', (evt)=>{\n                    /** the processor will return the previously aggregated event if it has been completed by processing the current event */ addUserAction(this.userActionAggregator.process(evt, this.agentRef.init.user_actions.elementAttributes));\n                }, this.featureName, this.ee);\n            }\n            /**\n       * is it worth complicating the agent and skipping the POs for single repeating queries? maybe,\n       * but right now it was less desirable simply because it is a nice benefit of populating the event buffer\n       * immediately as events happen for payload evaluation purposes and that becomes a little more chaotic\n       * with an arbitrary query method. note: eventTypes: [...types] does not support the 'buffered' flag so we have\n       * to create up to two PO's here.\n       */ const performanceTypesToCapture = [\n                ...agentRef.init.performance.capture_marks ? [\n                    'mark'\n                ] : [],\n                ...agentRef.init.performance.capture_measures ? [\n                    'measure'\n                ] : []\n            ];\n            if (performanceTypesToCapture.length) try {\n                performanceTypesToCapture.forEach((type)=>{\n                    if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n                        const observer = new PerformanceObserver((list)=>{\n                            list.getEntries().forEach((entry)=>{\n                                try {\n                                    this.reportSupportabilityMetric('Generic/Performance/' + type + '/Seen');\n                                    const detailObj = agentRef.init.performance.capture_detail ? createDetailAttrs(entry.detail) : {};\n                                    this.addEvent({\n                                        ...detailObj,\n                                        eventType: 'BrowserPerformance',\n                                        timestamp: this.toEpoch(entry.startTime),\n                                        entryName: (0, $jWywI.cleanURL)(entry.name),\n                                        entryDuration: entry.duration,\n                                        entryType: type\n                                    });\n                                    function createDetailAttrs(detail) {\n                                        if (detail === null || detail === undefined) return {};\n                                        else if (!(0, $8tgg9.isPureObject)(detail)) return {\n                                            entryDetail: detail\n                                        };\n                                        else return flattenJSON(detail);\n                                        function flattenJSON(nestedJSON, parentKey = 'entryDetail') {\n                                            let items = {};\n                                            if (nestedJSON === null || nestedJSON === undefined) return items;\n                                            Object.keys(nestedJSON).forEach((key)=>{\n                                                let newKey = parentKey + '.' + key;\n                                                if ((0, $8tgg9.isPureObject)(nestedJSON[key])) Object.assign(items, flattenJSON(nestedJSON[key], newKey));\n                                                else if (nestedJSON[key] !== null && nestedJSON[key] !== undefined) items[newKey] = nestedJSON[key];\n                                            });\n                                            return items;\n                                        }\n                                    }\n                                } catch (err) {}\n                            });\n                        });\n                        observer.observe({\n                            buffered: true,\n                            type: type\n                        });\n                    }\n                });\n            } catch (err) {\n            // Something failed in our set up, likely the browser does not support PO's... do nothing\n            }\n            if ((0, $9EKMI.isBrowserScope) && agentRef.init.performance.resources.enabled) (0, $4he1m.registerHandler)('browserPerformance.resource', (entry)=>{\n                try {\n                    // convert the entry to a plain object and separate the name and duration from the object\n                    // you need to do this to be able to spread it into the addEvent call later, and name and duration\n                    // would be duplicative of entryName and entryDuration and are protected keys in NR1\n                    const { name: name, duration: duration, ...entryObject } = entry.toJSON();\n                    let firstParty = false;\n                    try {\n                        const entryDomain = new URL(name).hostname;\n                        const isNr = entryDomain.includes('newrelic.com') || entryDomain.includes('nr-data.net') || entryDomain.includes('nr-local.net');\n                        /** decide if we should ignore nr-specific assets */ if (this.agentRef.init.performance.resources.ignore_newrelic && isNr) return;\n                        /** decide if we should ignore the asset type (empty means allow everything, which is the default) */ if (this.agentRef.init.performance.resources.asset_types.length && !this.agentRef.init.performance.resources.asset_types.includes(entryObject.initiatorType)) return;\n                        /** decide if the entryDomain is a first party domain */ firstParty = entryDomain === (0, $9EKMI.globalScope)?.location.hostname || agentRef.init.performance.resources.first_party_domains.includes(entryDomain);\n                        if (firstParty) this.reportSupportabilityMetric('Generic/Performance/FirstPartyResource/Seen');\n                        if (isNr) this.reportSupportabilityMetric('Generic/Performance/NrResource/Seen');\n                    } catch (err) {\n                    // couldnt parse the URL, so firstParty will just default to false\n                    }\n                    this.reportSupportabilityMetric('Generic/Performance/Resource/Seen');\n                    const event = {\n                        ...entryObject,\n                        eventType: 'BrowserPerformance',\n                        timestamp: Math.floor(agentRef.runtime.timeKeeper.correctRelativeTimestamp(entryObject.startTime)),\n                        entryName: name,\n                        entryDuration: duration,\n                        firstParty: firstParty\n                    };\n                    this.addEvent(event);\n                } catch (err) {\n                    this.ee.emit('internal-error', [\n                        err,\n                        'GenericEvents-Resource'\n                    ]);\n                }\n            }, this.featureName, this.ee);\n            agentRef.runtime.harvester.triggerHarvestFor(this);\n            this.drain();\n        });\n    }\n    // WARNING: Insights times are in seconds. EXCEPT timestamp, which is in ms.\n    /** Some keys are set by the query params or request headers sent with the harvest and override the body values, so check those before adding new standard body values...\n   * see harvest.js#baseQueryString for more info on the query params\n   * Notably:\n   * * name: set by the `t=` query param\n   * * appId: set by the `a=` query param\n   * * standalone: set by the `sa=` query param\n   * * session: set by the `s=` query param\n   * * sessionTraceId: set by the `ptid=` query param\n   * * userAgent*: set by the userAgent header\n   * @param {object=} obj the event object for storing in the event buffer\n   * @param {string=} targetEntityGuid the target entity guid for the event to scope buffering and harvesting. Defaults to agent config if undefined\n   * @returns void\n   */ addEvent(obj = {}, targetEntityGuid) {\n        if (!obj || !Object.keys(obj).length) return;\n        if (!obj.eventType) {\n            (0, $jkuUu.warn)(44);\n            return;\n        }\n        for(let key in obj){\n            let val = obj[key];\n            obj[key] = val && typeof val === 'object' ? (0, $8KO5M.stringify)(val) : val;\n        }\n        const defaultEventAttributes = {\n            /** should be overridden by the event-specific attributes, but just in case -- set it to now() */ timestamp: Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp((0, $1Z3KE.now)())),\n            /** all generic events require pageUrl(s) */ pageUrl: (0, $jWywI.cleanURL)('' + (0, $9EKMI.initialLocation)),\n            currentUrl: (0, $jWywI.cleanURL)('' + location)\n        };\n        const eventAttributes = {\n            /** Agent-level custom attributes */ ...this.agentRef.info.jsAttributes || {},\n            /** Fallbacks for required properties in-case the event did not supply them, should take precedence over agent-level custom attrs */ ...defaultEventAttributes,\n            /** Event-specific attributes take precedence over agent-level custom attributes and fallbacks */ ...obj\n        };\n        const addedEvent = this.events.add(eventAttributes, targetEntityGuid);\n        if (!addedEvent && !this.events.isEmpty(undefined, targetEntityGuid)) {\n            /** could not add the event because it pushed the buffer over the limit\n       * so we harvest early, and try to add it again now that the buffer is cleared\n       * if it fails again, we do nothing\n       */ this.ee.emit((0, $bu0p3.SUPPORTABILITY_METRIC_CHANNEL), [\n                'GenericEvents/Harvest/Max/Seen'\n            ]);\n            this.agentRef.runtime.harvester.triggerHarvestFor(this, {\n                targetEntityGuid: targetEntityGuid\n            });\n            this.events.add(eventAttributes);\n        }\n    }\n    serializer(eventBuffer) {\n        return (0, $hcIxM.applyFnToProps)({\n            ins: eventBuffer\n        }, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string');\n    }\n    queryStringsBuilder() {\n        return {\n            ua: this.agentRef.info.userAttributes,\n            at: this.agentRef.info.atts\n        };\n    }\n    toEpoch(timestamp) {\n        return Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(timestamp));\n    }\n    trackSupportabilityMetrics() {\n        /** track usage SMs to improve these experimental features */ const configPerfTag = 'Config/Performance/';\n        if (this.agentRef.init.performance.capture_marks) this.reportSupportabilityMetric(configPerfTag + 'CaptureMarks/Enabled');\n        if (this.agentRef.init.performance.capture_measures) this.reportSupportabilityMetric(configPerfTag + 'CaptureMeasures/Enabled');\n        if (this.agentRef.init.performance.resources.enabled) this.reportSupportabilityMetric(configPerfTag + 'Resources/Enabled');\n        if (this.agentRef.init.performance.resources.asset_types?.length !== 0) this.reportSupportabilityMetric(configPerfTag + 'Resources/AssetTypes/Changed');\n        if (this.agentRef.init.performance.resources.first_party_domains?.length !== 0) this.reportSupportabilityMetric(configPerfTag + 'Resources/FirstPartyDomains/Changed');\n        if (this.agentRef.init.performance.resources.ignore_newrelic === false) this.reportSupportabilityMetric(configPerfTag + 'Resources/IgnoreNewrelic/Changed');\n    }\n}\n\n});\nparcelRegister(\"hcIxM\", function(module, exports) {\n\n$parcel$export(module.exports, \"applyFnToProps\", function () { return $c8661c288403a270$export$1091a5f4e456a123; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Applies a function to properties of a specified type in an object, recursively.\n *\n * @param {Object} obj - The object to apply the function to.\n * @param {Function} fn - The function to apply to matching properties.\n * @param {string} [type='string'] - The type of properties to apply the function to.\n * @param {Array<string>} [ignoreKeys=[]] - The keys of properties to ignore and not modify.\n * @returns {Object} - The object with function recursively applied.\n */ function $c8661c288403a270$export$1091a5f4e456a123(obj, fn, type = 'string', ignoreKeys = []) {\n    if (!obj || typeof obj !== 'object') return obj;\n    Object.keys(obj).forEach((property)=>{\n        if (typeof obj[property] === 'object') $c8661c288403a270$export$1091a5f4e456a123(obj[property], fn, type, ignoreKeys);\n        else // eslint-disable-next-line valid-typeof\n        if (typeof obj[property] === type && !ignoreKeys.includes(property)) obj[property] = fn(obj[property]);\n    });\n    return obj;\n}\n\n});\n\nparcelRegister(\"b7nLr\", function(module, exports) {\n\n$parcel$export(module.exports, \"UserActionsAggregator\", function () { return $8182c838139d24dc$export$fec0411341f88df1; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $kFzvb = parcelRequire(\"kFzvb\");\n\nvar $4UPGI = parcelRequire(\"4UPGI\");\n\nvar $biMpD = parcelRequire(\"biMpD\");\nclass $8182c838139d24dc$export$fec0411341f88df1 {\n    /** @type {AggregatedUserAction=} */ #aggregationEvent = undefined;\n    #aggregationKey = '';\n    get aggregationEvent() {\n        // if this is accessed externally, we need to be done aggregating on it\n        // to prevent potential mutability and duplication issues, so the state is cleared upon returning.\n        // This value may need to be accessed during an unload harvest.\n        const finishedEvent = this.#aggregationEvent;\n        this.#aggregationKey = '';\n        this.#aggregationEvent = undefined;\n        return finishedEvent;\n    }\n    /**\n   * Process the event and determine if a new aggregation set should be made or if it should increment the current aggregation\n   * @param {Event} evt The event supplied by the addEventListener callback\n   * @returns {AggregatedUserAction|undefined} The previous aggregation set if it has been completed by processing the current event\n   */ process(evt, targetFields) {\n        if (!evt) return;\n        const { selectorPath: selectorPath, nearestTargetFields: nearestTargetFields } = $8182c838139d24dc$var$getSelectorPath(evt, targetFields);\n        const aggregationKey = $8182c838139d24dc$var$getAggregationKey(evt, selectorPath);\n        if (!!aggregationKey && aggregationKey === this.#aggregationKey) // an aggregation exists already, so lets just continue to increment\n        this.#aggregationEvent.aggregate(evt);\n        else {\n            // return the prev existing one (if there is one)\n            const finishedEvent = this.#aggregationEvent;\n            // then set as this new event aggregation\n            this.#aggregationKey = aggregationKey;\n            this.#aggregationEvent = new (0, $biMpD.AggregatedUserAction)(evt, selectorPath, nearestTargetFields);\n            return finishedEvent;\n        }\n    }\n}\n/**\n * Generates a selector path for the event, starting with simple cases like window or document and getting more complex for dom-tree traversals as needed.\n * Will return a random selector path value if no other path can be determined, to force the aggregator to skip aggregation for this event.\n * @param {Event} evt\n * @returns {string}\n */ function $8182c838139d24dc$var$getSelectorPath(evt, targetFields) {\n    let selectorPath;\n    let nearestTargetFields = {};\n    if ((0, $4UPGI.OBSERVED_WINDOW_EVENTS).includes(evt.type) || evt.target === window) selectorPath = 'window';\n    else if (evt.target === document) selectorPath = 'document';\n    else {\n        const { path: path, nearestFields: nearestFields } = (0, $kFzvb.generateSelectorPath)(evt.target, targetFields);\n        selectorPath = path;\n        nearestTargetFields = nearestFields;\n    }\n    // if STILL no selectorPath, it will return undefined which will skip aggregation for this event\n    return {\n        selectorPath: selectorPath,\n        nearestTargetFields: nearestTargetFields\n    };\n}\n/**\n * Returns an aggregation key based on the event type and the selector path of the event's target.\n * Scrollend events are aggregated into one set, no matter what.\n * @param {Event} evt\n * @param {string} selectorPath\n * @returns {string}\n */ function $8182c838139d24dc$var$getAggregationKey(evt, selectorPath) {\n    let aggregationKey = evt.type;\n    /** aggregate all scrollends into one set (if sequential), no matter what their target is\n   * the aggregation group's selector path with be reflected as the first one observed\n   * due to the way the aggregation logic works (by storing the initial value and aggregating it) */ if (evt.type !== 'scrollend') aggregationKey += '-' + selectorPath;\n    return aggregationKey;\n}\n\n});\nparcelRegister(\"kFzvb\", function(module, exports) {\n\n$parcel$export(module.exports, \"generateSelectorPath\", function () { return $f0c32cf28c0aa93e$export$5541770411fa294; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Generates a CSS selector path for the given element, if possible\n * @param {HTMLElement} elem\n * @param {boolean} includeId\n * @param {boolean} includeClass\n * @returns {string|undefined}\n */ const $f0c32cf28c0aa93e$export$5541770411fa294 = (elem, targetFields = [])=>{\n    if (!elem) return {\n        path: undefined,\n        nearestFields: {}\n    };\n    const getNthOfTypeIndex = (node)=>{\n        try {\n            let i = 1;\n            const { tagName: tagName } = node;\n            while(node.previousElementSibling){\n                if (node.previousElementSibling.tagName === tagName) i++;\n                node = node.previousElementSibling;\n            }\n            return i;\n        } catch (err) {\n        // do nothing for now.  An invalid child count will make the path selector not return a nth-of-type selector statement\n        }\n    };\n    let pathSelector = '';\n    let index = getNthOfTypeIndex(elem);\n    const nearestFields = {};\n    try {\n        while(elem?.tagName){\n            const { id: id, localName: localName } = elem;\n            targetFields.forEach((field)=>{\n                nearestFields[nearestAttrName(field)] ||= elem[field]?.baseVal || elem[field];\n            });\n            const selector = [\n                localName,\n                id ? \"#\".concat(id) : '',\n                pathSelector ? \">\".concat(pathSelector) : ''\n            ].join('');\n            pathSelector = selector;\n            elem = elem.parentNode;\n        }\n    } catch (err) {\n    // do nothing for now\n    }\n    const path = pathSelector ? index ? \"\".concat(pathSelector, \":nth-of-type(\").concat(index, \")\") : pathSelector : undefined;\n    return {\n        path: path,\n        nearestFields: nearestFields\n    };\n    function nearestAttrName(originalFieldName) {\n        /** preserve original renaming structure for pre-existing field maps */ if (originalFieldName === 'tagName') originalFieldName = 'tag';\n        if (originalFieldName === 'className') originalFieldName = 'class';\n        return \"nearest\".concat(originalFieldName.charAt(0).toUpperCase() + originalFieldName.slice(1));\n    }\n};\n\n});\n\nparcelRegister(\"biMpD\", function(module, exports) {\n\n$parcel$export(module.exports, \"AggregatedUserAction\", function () { return $83a6edd5700e1f7d$export$5d5f7e95dfe139dd; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $4UPGI = parcelRequire(\"4UPGI\");\nclass $83a6edd5700e1f7d$export$5d5f7e95dfe139dd {\n    constructor(evt, selectorPath, nearestTargetFields){\n        this.event = evt;\n        this.count = 1;\n        this.originMs = Math.floor(evt.timeStamp);\n        this.relativeMs = [\n            0\n        ];\n        this.selectorPath = selectorPath;\n        this.rageClick = undefined;\n        this.nearestTargetFields = nearestTargetFields;\n    }\n    /**\n   * Aggregates the count and maintains the relative MS array for matching events\n   * Will determine if a rage click was observed as part of the aggregation\n   * @param {Event} evt\n   * @returns {void}\n   */ aggregate(evt) {\n        this.count++;\n        this.relativeMs.push(Math.floor(evt.timeStamp - this.originMs));\n        if (this.isRageClick()) this.rageClick = true;\n    }\n    /**\n   * Determines if the current set of relative ms values constitutes a rage click\n   * @returns {boolean}\n   */ isRageClick() {\n        const len = this.relativeMs.length;\n        return this.event.type === 'click' && len >= (0, $4UPGI.RAGE_CLICK_THRESHOLD_EVENTS) && this.relativeMs[len - 1] - this.relativeMs[len - (0, $4UPGI.RAGE_CLICK_THRESHOLD_EVENTS)] < (0, $4UPGI.RAGE_CLICK_THRESHOLD_MS);\n    }\n}\n\n});\n\n\nparcelRegister(\"e29aQ\", function(module, exports) {\n\n$parcel$export(module.exports, \"isIFrameWindow\", function () { return $a3785e5345bd4698$export$6cb21386b9b5d84e; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ function $a3785e5345bd4698$export$6cb21386b9b5d84e(windowObject) {\n    if (!windowObject) return false;\n    return windowObject.self !== windowObject.top;\n}\n\n});\n\nparcelRegister(\"8tgg9\", function(module, exports) {\n\n$parcel$export(module.exports, \"isPureObject\", function () { return $62ada4f1ea4a44f5$export$e219791d2b49856; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Tests a passed object to see if it is a pure object or not. All non-primatives in JS\n * are technically objects and would pass a `typeof` check.\n * @param {*} obj Input object to be tested\n**/ function $62ada4f1ea4a44f5$export$e219791d2b49856(obj) {\n    return obj?.constructor === ({}).constructor;\n}\n\n});\n\n\n\n//# sourceMappingURL=aggregate.31dad227.js.map\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { stringify } from '../../../common/util/stringify';\nimport { cleanURL } from '../../../common/url/clean-url';\nimport { FEATURE_NAME, RESERVED_EVENT_TYPES } from '../constants';\nimport { globalScope, initialLocation, isBrowserScope } from '../../../common/constants/runtime';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { warn } from '../../../common/util/console';\nimport { now } from '../../../common/timing/now';\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../metrics/constants';\nimport { applyFnToProps } from '../../../common/util/traverse';\nimport { UserActionsAggregator } from './user-actions/user-actions-aggregator';\nimport { isIFrameWindow } from '../../../common/dom/iframe';\nimport { isPureObject } from '../../../common/util/type-check';\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentRef) {\n    super(agentRef, FEATURE_NAME);\n    this.eventsPerHarvest = 1000;\n    this.referrerUrl = isBrowserScope && document.referrer ? cleanURL(document.referrer) : undefined;\n    this.waitForFlags(['ins']).then(([ins]) => {\n      if (!ins) {\n        this.blocked = true;\n        this.deregisterDrain();\n        return;\n      }\n      this.trackSupportabilityMetrics();\n      registerHandler('api-recordCustomEvent', (timestamp, eventType, attributes) => {\n        if (RESERVED_EVENT_TYPES.includes(eventType)) return warn(46);\n        this.addEvent({\n          eventType,\n          timestamp: this.toEpoch(timestamp),\n          ...attributes\n        });\n      }, this.featureName, this.ee);\n      if (agentRef.init.page_action.enabled) {\n        registerHandler('api-addPageAction', (timestamp, name, attributes, targetEntityGuid) => {\n          if (!this.agentRef.runtime.entityManager.get(targetEntityGuid)) return warn(56, this.featureName);\n          this.addEvent({\n            ...attributes,\n            eventType: 'PageAction',\n            timestamp: this.toEpoch(timestamp),\n            timeSinceLoad: timestamp / 1000,\n            actionName: name,\n            referrerUrl: this.referrerUrl,\n            ...(isBrowserScope && {\n              browserWidth: window.document.documentElement?.clientWidth,\n              browserHeight: window.document.documentElement?.clientHeight\n            })\n          }, targetEntityGuid);\n        }, this.featureName, this.ee);\n      }\n      let addUserAction = () => {/** no-op */};\n      if (isBrowserScope && agentRef.init.user_actions.enabled) {\n        this.userActionAggregator = new UserActionsAggregator();\n        this.harvestOpts.beforeUnload = () => addUserAction?.(this.userActionAggregator.aggregationEvent);\n        addUserAction = aggregatedUserAction => {\n          try {\n            /** The aggregator process only returns an event when it is \"done\" aggregating -\n             * so we still need to validate that an event was given to this method before we try to add */\n            if (aggregatedUserAction?.event) {\n              const {\n                target,\n                timeStamp,\n                type\n              } = aggregatedUserAction.event;\n              this.addEvent({\n                eventType: 'UserAction',\n                timestamp: this.toEpoch(timeStamp),\n                action: type,\n                actionCount: aggregatedUserAction.count,\n                actionDuration: aggregatedUserAction.relativeMs[aggregatedUserAction.relativeMs.length - 1],\n                actionMs: aggregatedUserAction.relativeMs,\n                rageClick: aggregatedUserAction.rageClick,\n                target: aggregatedUserAction.selectorPath,\n                ...(isIFrameWindow(window) && {\n                  iframe: true\n                }),\n                ...this.agentRef.init.user_actions.elementAttributes.reduce((acc, field) => {\n                  /** prevent us from capturing an obscenely long value */\n                  if (canTrustTargetAttribute(field)) acc[targetAttrName(field)] = String(target[field]).trim().slice(0, 128);\n                  return acc;\n                }, {}),\n                ...aggregatedUserAction.nearestTargetFields\n              });\n\n              /**\n               * Returns the original target field name with `target` prepended and camelCased\n               * @param {string} originalFieldName\n               * @returns {string} the target field name\n               */\n              function targetAttrName(originalFieldName) {\n                /** preserve original renaming structure for pre-existing field maps */\n                if (originalFieldName === 'tagName') originalFieldName = 'tag';\n                if (originalFieldName === 'className') originalFieldName = 'class';\n                /** return the original field name, cap'd and prepended with target to match formatting */\n                return \"target\".concat(originalFieldName.charAt(0).toUpperCase() + originalFieldName.slice(1));\n              }\n\n              /**\n               * Only trust attributes that exist on HTML element targets, which excludes the window and the document targets\n               * @param {string} attribute The attribute to check for on the target element\n               * @returns {boolean} Whether the target element has the attribute and can be trusted\n               */\n              function canTrustTargetAttribute(attribute) {\n                return !!(aggregatedUserAction.selectorPath !== 'window' && aggregatedUserAction.selectorPath !== 'document' && target instanceof HTMLElement && target?.[attribute]);\n              }\n            }\n          } catch (e) {\n            // do nothing for now\n          }\n        };\n        registerHandler('ua', evt => {\n          /** the processor will return the previously aggregated event if it has been completed by processing the current event */\n          addUserAction(this.userActionAggregator.process(evt, this.agentRef.init.user_actions.elementAttributes));\n        }, this.featureName, this.ee);\n      }\n\n      /**\n       * is it worth complicating the agent and skipping the POs for single repeating queries? maybe,\n       * but right now it was less desirable simply because it is a nice benefit of populating the event buffer\n       * immediately as events happen for payload evaluation purposes and that becomes a little more chaotic\n       * with an arbitrary query method. note: eventTypes: [...types] does not support the 'buffered' flag so we have\n       * to create up to two PO's here.\n       */\n      const performanceTypesToCapture = [...(agentRef.init.performance.capture_marks ? ['mark'] : []), ...(agentRef.init.performance.capture_measures ? ['measure'] : [])];\n      if (performanceTypesToCapture.length) {\n        try {\n          performanceTypesToCapture.forEach(type => {\n            if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n              const observer = new PerformanceObserver(list => {\n                list.getEntries().forEach(entry => {\n                  try {\n                    this.reportSupportabilityMetric('Generic/Performance/' + type + '/Seen');\n                    const detailObj = agentRef.init.performance.capture_detail ? createDetailAttrs(entry.detail) : {};\n                    this.addEvent({\n                      ...detailObj,\n                      eventType: 'BrowserPerformance',\n                      timestamp: this.toEpoch(entry.startTime),\n                      entryName: cleanURL(entry.name),\n                      entryDuration: entry.duration,\n                      entryType: type\n                    });\n                    function createDetailAttrs(detail) {\n                      if (detail === null || detail === undefined) return {};else if (!isPureObject(detail)) return {\n                        entryDetail: detail\n                      };else return flattenJSON(detail);\n                      function flattenJSON(nestedJSON, parentKey = 'entryDetail') {\n                        let items = {};\n                        if (nestedJSON === null || nestedJSON === undefined) return items;\n                        Object.keys(nestedJSON).forEach(key => {\n                          let newKey = parentKey + '.' + key;\n                          if (isPureObject(nestedJSON[key])) {\n                            Object.assign(items, flattenJSON(nestedJSON[key], newKey));\n                          } else {\n                            if (nestedJSON[key] !== null && nestedJSON[key] !== undefined) items[newKey] = nestedJSON[key];\n                          }\n                        });\n                        return items;\n                      }\n                    }\n                  } catch (err) {}\n                });\n              });\n              observer.observe({\n                buffered: true,\n                type\n              });\n            }\n          });\n        } catch (err) {\n          // Something failed in our set up, likely the browser does not support PO's... do nothing\n        }\n      }\n      if (isBrowserScope && agentRef.init.performance.resources.enabled) {\n        registerHandler('browserPerformance.resource', entry => {\n          try {\n            // convert the entry to a plain object and separate the name and duration from the object\n            // you need to do this to be able to spread it into the addEvent call later, and name and duration\n            // would be duplicative of entryName and entryDuration and are protected keys in NR1\n            const {\n              name,\n              duration,\n              ...entryObject\n            } = entry.toJSON();\n            let firstParty = false;\n            try {\n              const entryDomain = new URL(name).hostname;\n              const isNr = entryDomain.includes('newrelic.com') || entryDomain.includes('nr-data.net') || entryDomain.includes('nr-local.net');\n              /** decide if we should ignore nr-specific assets */\n              if (this.agentRef.init.performance.resources.ignore_newrelic && isNr) return;\n              /** decide if we should ignore the asset type (empty means allow everything, which is the default) */\n              if (this.agentRef.init.performance.resources.asset_types.length && !this.agentRef.init.performance.resources.asset_types.includes(entryObject.initiatorType)) return;\n              /** decide if the entryDomain is a first party domain */\n              firstParty = entryDomain === globalScope?.location.hostname || agentRef.init.performance.resources.first_party_domains.includes(entryDomain);\n              if (firstParty) this.reportSupportabilityMetric('Generic/Performance/FirstPartyResource/Seen');\n              if (isNr) this.reportSupportabilityMetric('Generic/Performance/NrResource/Seen');\n            } catch (err) {\n              // couldnt parse the URL, so firstParty will just default to false\n            }\n            this.reportSupportabilityMetric('Generic/Performance/Resource/Seen');\n            const event = {\n              ...entryObject,\n              eventType: 'BrowserPerformance',\n              timestamp: Math.floor(agentRef.runtime.timeKeeper.correctRelativeTimestamp(entryObject.startTime)),\n              entryName: name,\n              entryDuration: duration,\n              firstParty\n            };\n            this.addEvent(event);\n          } catch (err) {\n            this.ee.emit('internal-error', [err, 'GenericEvents-Resource']);\n          }\n        }, this.featureName, this.ee);\n      }\n      agentRef.runtime.harvester.triggerHarvestFor(this);\n      this.drain();\n    });\n  }\n\n  // WARNING: Insights times are in seconds. EXCEPT timestamp, which is in ms.\n  /** Some keys are set by the query params or request headers sent with the harvest and override the body values, so check those before adding new standard body values...\n   * see harvest.js#baseQueryString for more info on the query params\n   * Notably:\n   * * name: set by the `t=` query param\n   * * appId: set by the `a=` query param\n   * * standalone: set by the `sa=` query param\n   * * session: set by the `s=` query param\n   * * sessionTraceId: set by the `ptid=` query param\n   * * userAgent*: set by the userAgent header\n   * @param {object=} obj the event object for storing in the event buffer\n   * @param {string=} targetEntityGuid the target entity guid for the event to scope buffering and harvesting. Defaults to agent config if undefined\n   * @returns void\n   */\n  addEvent(obj = {}, targetEntityGuid) {\n    if (!obj || !Object.keys(obj).length) return;\n    if (!obj.eventType) {\n      warn(44);\n      return;\n    }\n    for (let key in obj) {\n      let val = obj[key];\n      obj[key] = val && typeof val === 'object' ? stringify(val) : val;\n    }\n    const defaultEventAttributes = {\n      /** should be overridden by the event-specific attributes, but just in case -- set it to now() */\n      timestamp: Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(now())),\n      /** all generic events require pageUrl(s) */\n      pageUrl: cleanURL('' + initialLocation),\n      currentUrl: cleanURL('' + location)\n    };\n    const eventAttributes = {\n      /** Agent-level custom attributes */\n      ...(this.agentRef.info.jsAttributes || {}),\n      /** Fallbacks for required properties in-case the event did not supply them, should take precedence over agent-level custom attrs */\n      ...defaultEventAttributes,\n      /** Event-specific attributes take precedence over agent-level custom attributes and fallbacks */\n      ...obj\n    };\n    const addedEvent = this.events.add(eventAttributes, targetEntityGuid);\n    if (!addedEvent && !this.events.isEmpty(undefined, targetEntityGuid)) {\n      /** could not add the event because it pushed the buffer over the limit\n       * so we harvest early, and try to add it again now that the buffer is cleared\n       * if it fails again, we do nothing\n       */\n      this.ee.emit(SUPPORTABILITY_METRIC_CHANNEL, ['GenericEvents/Harvest/Max/Seen']);\n      this.agentRef.runtime.harvester.triggerHarvestFor(this, {\n        targetEntityGuid\n      });\n      this.events.add(eventAttributes);\n    }\n  }\n  serializer(eventBuffer) {\n    return applyFnToProps({\n      ins: eventBuffer\n    }, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string');\n  }\n  queryStringsBuilder() {\n    return {\n      ua: this.agentRef.info.userAttributes,\n      at: this.agentRef.info.atts\n    };\n  }\n  toEpoch(timestamp) {\n    return Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(timestamp));\n  }\n  trackSupportabilityMetrics() {\n    /** track usage SMs to improve these experimental features */\n    const configPerfTag = 'Config/Performance/';\n    if (this.agentRef.init.performance.capture_marks) this.reportSupportabilityMetric(configPerfTag + 'CaptureMarks/Enabled');\n    if (this.agentRef.init.performance.capture_measures) this.reportSupportabilityMetric(configPerfTag + 'CaptureMeasures/Enabled');\n    if (this.agentRef.init.performance.resources.enabled) this.reportSupportabilityMetric(configPerfTag + 'Resources/Enabled');\n    if (this.agentRef.init.performance.resources.asset_types?.length !== 0) this.reportSupportabilityMetric(configPerfTag + 'Resources/AssetTypes/Changed');\n    if (this.agentRef.init.performance.resources.first_party_domains?.length !== 0) this.reportSupportabilityMetric(configPerfTag + 'Resources/FirstPartyDomains/Changed');\n    if (this.agentRef.init.performance.resources.ignore_newrelic === false) this.reportSupportabilityMetric(configPerfTag + 'Resources/IgnoreNewrelic/Changed');\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Applies a function to properties of a specified type in an object, recursively.\n *\n * @param {Object} obj - The object to apply the function to.\n * @param {Function} fn - The function to apply to matching properties.\n * @param {string} [type='string'] - The type of properties to apply the function to.\n * @param {Array<string>} [ignoreKeys=[]] - The keys of properties to ignore and not modify.\n * @returns {Object} - The object with function recursively applied.\n */\nexport function applyFnToProps(obj, fn, type = 'string', ignoreKeys = []) {\n  if (!obj || typeof obj !== 'object') return obj;\n  Object.keys(obj).forEach(property => {\n    if (typeof obj[property] === 'object') {\n      applyFnToProps(obj[property], fn, type, ignoreKeys);\n    } else {\n      // eslint-disable-next-line valid-typeof\n      if (typeof obj[property] === type && !ignoreKeys.includes(property)) obj[property] = fn(obj[property]);\n    }\n  });\n  return obj;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { generateSelectorPath } from '../../../../common/dom/selector-path';\nimport { OBSERVED_WINDOW_EVENTS } from '../../constants';\nimport { AggregatedUserAction } from './aggregated-user-action';\nexport class UserActionsAggregator {\n  /** @type {AggregatedUserAction=} */\n  #aggregationEvent = undefined;\n  #aggregationKey = '';\n  get aggregationEvent() {\n    // if this is accessed externally, we need to be done aggregating on it\n    // to prevent potential mutability and duplication issues, so the state is cleared upon returning.\n    // This value may need to be accessed during an unload harvest.\n    const finishedEvent = this.#aggregationEvent;\n    this.#aggregationKey = '';\n    this.#aggregationEvent = undefined;\n    return finishedEvent;\n  }\n\n  /**\n   * Process the event and determine if a new aggregation set should be made or if it should increment the current aggregation\n   * @param {Event} evt The event supplied by the addEventListener callback\n   * @returns {AggregatedUserAction|undefined} The previous aggregation set if it has been completed by processing the current event\n   */\n  process(evt, targetFields) {\n    if (!evt) return;\n    const {\n      selectorPath,\n      nearestTargetFields\n    } = getSelectorPath(evt, targetFields);\n    const aggregationKey = getAggregationKey(evt, selectorPath);\n    if (!!aggregationKey && aggregationKey === this.#aggregationKey) {\n      // an aggregation exists already, so lets just continue to increment\n      this.#aggregationEvent.aggregate(evt);\n    } else {\n      // return the prev existing one (if there is one)\n      const finishedEvent = this.#aggregationEvent;\n      // then set as this new event aggregation\n      this.#aggregationKey = aggregationKey;\n      this.#aggregationEvent = new AggregatedUserAction(evt, selectorPath, nearestTargetFields);\n      return finishedEvent;\n    }\n  }\n}\n\n/**\n * Generates a selector path for the event, starting with simple cases like window or document and getting more complex for dom-tree traversals as needed.\n * Will return a random selector path value if no other path can be determined, to force the aggregator to skip aggregation for this event.\n * @param {Event} evt\n * @returns {string}\n */\nfunction getSelectorPath(evt, targetFields) {\n  let selectorPath;\n  let nearestTargetFields = {};\n  if (OBSERVED_WINDOW_EVENTS.includes(evt.type) || evt.target === window) selectorPath = 'window';else if (evt.target === document) selectorPath = 'document';\n  // if still no selectorPath, generate one from target tree that includes elem ids\n  else {\n    const {\n      path,\n      nearestFields\n    } = generateSelectorPath(evt.target, targetFields);\n    selectorPath = path;\n    nearestTargetFields = nearestFields;\n  }\n  // if STILL no selectorPath, it will return undefined which will skip aggregation for this event\n  return {\n    selectorPath,\n    nearestTargetFields\n  };\n}\n\n/**\n * Returns an aggregation key based on the event type and the selector path of the event's target.\n * Scrollend events are aggregated into one set, no matter what.\n * @param {Event} evt\n * @param {string} selectorPath\n * @returns {string}\n */\nfunction getAggregationKey(evt, selectorPath) {\n  let aggregationKey = evt.type;\n  /** aggregate all scrollends into one set (if sequential), no matter what their target is\n   * the aggregation group's selector path with be reflected as the first one observed\n   * due to the way the aggregation logic works (by storing the initial value and aggregating it) */\n  if (evt.type !== 'scrollend') aggregationKey += '-' + selectorPath;\n  return aggregationKey;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Generates a CSS selector path for the given element, if possible\n * @param {HTMLElement} elem\n * @param {boolean} includeId\n * @param {boolean} includeClass\n * @returns {string|undefined}\n */\nexport const generateSelectorPath = (elem, targetFields = []) => {\n  if (!elem) return {\n    path: undefined,\n    nearestFields: {}\n  };\n  const getNthOfTypeIndex = node => {\n    try {\n      let i = 1;\n      const {\n        tagName\n      } = node;\n      while (node.previousElementSibling) {\n        if (node.previousElementSibling.tagName === tagName) i++;\n        node = node.previousElementSibling;\n      }\n      return i;\n    } catch (err) {\n      // do nothing for now.  An invalid child count will make the path selector not return a nth-of-type selector statement\n    }\n  };\n  let pathSelector = '';\n  let index = getNthOfTypeIndex(elem);\n  const nearestFields = {};\n  try {\n    while (elem?.tagName) {\n      const {\n        id,\n        localName\n      } = elem;\n      targetFields.forEach(field => {\n        nearestFields[nearestAttrName(field)] ||= elem[field]?.baseVal || elem[field];\n      });\n      const selector = [localName, id ? \"#\".concat(id) : '', pathSelector ? \">\".concat(pathSelector) : ''].join('');\n      pathSelector = selector;\n      elem = elem.parentNode;\n    }\n  } catch (err) {\n    // do nothing for now\n  }\n  const path = pathSelector ? index ? \"\".concat(pathSelector, \":nth-of-type(\").concat(index, \")\") : pathSelector : undefined;\n  return {\n    path,\n    nearestFields\n  };\n  function nearestAttrName(originalFieldName) {\n    /** preserve original renaming structure for pre-existing field maps */\n    if (originalFieldName === 'tagName') originalFieldName = 'tag';\n    if (originalFieldName === 'className') originalFieldName = 'class';\n    return \"nearest\".concat(originalFieldName.charAt(0).toUpperCase() + originalFieldName.slice(1));\n  }\n};","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { RAGE_CLICK_THRESHOLD_EVENTS, RAGE_CLICK_THRESHOLD_MS } from '../../constants';\nexport class AggregatedUserAction {\n  constructor(evt, selectorPath, nearestTargetFields) {\n    this.event = evt;\n    this.count = 1;\n    this.originMs = Math.floor(evt.timeStamp);\n    this.relativeMs = [0];\n    this.selectorPath = selectorPath;\n    this.rageClick = undefined;\n    this.nearestTargetFields = nearestTargetFields;\n  }\n\n  /**\n   * Aggregates the count and maintains the relative MS array for matching events\n   * Will determine if a rage click was observed as part of the aggregation\n   * @param {Event} evt\n   * @returns {void}\n   */\n  aggregate(evt) {\n    this.count++;\n    this.relativeMs.push(Math.floor(evt.timeStamp - this.originMs));\n    if (this.isRageClick()) this.rageClick = true;\n  }\n\n  /**\n   * Determines if the current set of relative ms values constitutes a rage click\n   * @returns {boolean}\n   */\n  isRageClick() {\n    const len = this.relativeMs.length;\n    return this.event.type === 'click' && len >= RAGE_CLICK_THRESHOLD_EVENTS && this.relativeMs[len - 1] - this.relativeMs[len - RAGE_CLICK_THRESHOLD_EVENTS] < RAGE_CLICK_THRESHOLD_MS;\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nexport function isIFrameWindow(windowObject) {\n  if (!windowObject) return false;\n  return windowObject.self !== windowObject.top;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Tests a passed object to see if it is a pure object or not. All non-primatives in JS\n * are technically objects and would pass a `typeof` check.\n * @param {*} obj Input object to be tested\n**/\nexport function isPureObject(obj) {\n  return obj?.constructor === {}.constructor;\n}"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","self","window","global","parcelRegister","register","module","exports","$e45e34e206901505$export$b9601df20779e14a","$8KO5M","$jWywI","$4UPGI","$9EKMI","$3DmF0","$jkuUu","$1Z3KE","$4he1m","$bu0p3","$hcIxM","$b7nLr","$e29aQ","$8tgg9","AggregateBase","featureName","FEATURE_NAME","constructor","agentRef","eventsPerHarvest","referrerUrl","isBrowserScope","document","referrer","cleanURL","undefined","waitForFlags","then","ins","blocked","deregisterDrain","trackSupportabilityMetrics","registerHandler","timestamp","eventType","attributes","RESERVED_EVENT_TYPES","includes","warn","addEvent","toEpoch","ee","init","page_action","enabled","name","targetEntityGuid","runtime","entityManager","timeSinceLoad","actionName","browserWidth","documentElement","clientWidth","browserHeight","clientHeight","addUserAction","user_actions","userActionAggregator","UserActionsAggregator","harvestOpts","beforeUnload","aggregationEvent","aggregatedUserAction","event","target","timeStamp","type","action","actionCount","count","actionDuration","relativeMs","length","actionMs","rageClick","selectorPath","isIFrameWindow","iframe","elementAttributes","reduce","acc","field","attribute","originalFieldName","HTMLElement","concat","charAt","toUpperCase","slice","String","trim","nearestTargetFields","evt","process","performanceTypesToCapture","performance","capture_marks","capture_measures","forEach","PerformanceObserver","supportedEntryTypes","observer","list","getEntries","entry","detail","reportSupportabilityMetric","detailObj","capture_detail","isPureObject","flattenJSON","nestedJSON","parentKey","items","keys","key","newKey","assign","entryDetail","startTime","entryName","entryDuration","duration","entryType","err","observe","buffered","resources","entryObject","toJSON","firstParty","entryDomain","URL","hostname","isNr","ignore_newrelic","asset_types","initiatorType","globalScope","location","first_party_domains","Math","floor","timeKeeper","correctRelativeTimestamp","emit","harvester","triggerHarvestFor","drain","obj","val","stringify","defaultEventAttributes","now","pageUrl","initialLocation","currentUrl","eventAttributes","info","jsAttributes","events","add","isEmpty","SUPPORTABILITY_METRIC_CHANNEL","serializer","eventBuffer","applyFnToProps","obfuscator","obfuscateString","bind","queryStringsBuilder","ua","userAttributes","at","atts","configPerfTag","$c8661c288403a270$export$1091a5f4e456a123","fn","ignoreKeys","property","$8182c838139d24dc$export$fec0411341f88df1","$kFzvb","$biMpD","finishedEvent","targetFields","aggregationKey","$8182c838139d24dc$var$getSelectorPath","OBSERVED_WINDOW_EVENTS","path","nearestFields","generateSelectorPath","aggregate","AggregatedUserAction","$f0c32cf28c0aa93e$export$5541770411fa294","elem","pathSelector","index","getNthOfTypeIndex","node","i","tagName","previousElementSibling","id","localName","baseVal","join","parentNode","$83a6edd5700e1f7d$export$5d5f7e95dfe139dd","originMs","push","isRageClick","len","RAGE_CLICK_THRESHOLD_EVENTS","RAGE_CLICK_THRESHOLD_MS","$a3785e5345bd4698$export$6cb21386b9b5d84e","windowObject","top","$62ada4f1ea4a44f5$export$e219791d2b49856"],"version":3,"file":"aggregate.31dad227.js.map"}
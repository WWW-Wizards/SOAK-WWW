{"mappings":"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","sources":["<anon>","node_modules/@newrelic/browser-agent/dist/esm/features/soft_navigations/aggregate/index.js","node_modules/@newrelic/browser-agent/dist/esm/common/vitals/time-to-first-byte.js","node_modules/@newrelic/browser-agent/dist/esm/features/soft_navigations/aggregate/ajax-node.js","node_modules/@newrelic/browser-agent/dist/esm/common/serialize/bel-serializer.js","node_modules/@newrelic/browser-agent/dist/esm/features/soft_navigations/aggregate/bel-node.js","node_modules/@newrelic/browser-agent/dist/esm/features/soft_navigations/aggregate/initial-page-load-interaction.js","node_modules/@newrelic/browser-agent/dist/esm/common/timing/nav-timing.js","node_modules/@newrelic/browser-agent/dist/esm/features/soft_navigations/aggregate/interaction.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire5e30\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"bEFXe\", function(module, exports) {\n\n$parcel$export(module.exports, \"Aggregate\", function () { return $87c3f9698a4c2d00$export$b9601df20779e14a; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $gy0pT = parcelRequire(\"gy0pT\");\n\nvar $4he1m = parcelRequire(\"4he1m\");\n\nvar $letnH = parcelRequire(\"letnH\");\n\nvar $kkmY2 = parcelRequire(\"kkmY2\");\n\nvar $3R40a = parcelRequire(\"3R40a\");\n\nvar $3DmF0 = parcelRequire(\"3DmF0\");\n\nvar $1ZAXp = parcelRequire(\"1ZAXp\");\n\nvar $gtRNT = parcelRequire(\"gtRNT\");\n\nvar $l3aTe = parcelRequire(\"l3aTe\");\n\nvar $jStS4 = parcelRequire(\"jStS4\");\nclass $87c3f9698a4c2d00$export$b9601df20779e14a extends (0, $3DmF0.AggregateBase) {\n    static featureName = (0, $1ZAXp.FEATURE_NAME);\n    constructor(agentRef, { domObserver: domObserver }){\n        super(agentRef, (0, $1ZAXp.FEATURE_NAME));\n        this.interactionsToHarvest = this.events;\n        this.domObserver = domObserver;\n        this.initialPageLoadInteraction = new (0, $l3aTe.InitialPageLoadInteraction)(agentRef);\n        this.initialPageLoadInteraction.onDone.push(()=>{\n            // this ensures the .end() method also works with iPL\n            if (agentRef.runtime.session?.isNew) this.initialPageLoadInteraction.customAttributes.isFirstOfSession = true; // mark the hard page load as first of its session\n            this.initialPageLoadInteraction.forceSave = true; // unless forcibly ignored, iPL always finish by default\n            const ixn = this.initialPageLoadInteraction;\n            this.interactionsToHarvest.add(ixn);\n            this.initialPageLoadInteraction = null;\n        });\n        (0, $kkmY2.timeToFirstByte).subscribe(({ attrs: attrs })=>{\n            const loadEventTime = attrs.navigationEntry.loadEventEnd;\n            this.initialPageLoadInteraction.done(loadEventTime);\n            // Report metric on the initial page load time\n            this.reportSupportabilityMetric('SoftNav/Interaction/InitialPageLoad/Duration/Ms', Math.round(loadEventTime));\n        });\n        this.latestRouteSetByApi = null;\n        this.interactionInProgress = null; // aside from the \"page load\" interaction, there can only ever be 1 ongoing at a time\n        this.latestHistoryUrl = null;\n        this.harvestOpts.beforeUnload = ()=>this.interactionInProgress?.done(); // return any withheld ajax or jserr events so they can be sent with EoL harvest\n        this.waitForFlags([\n            'spa'\n        ]).then(([spaOn])=>{\n            if (spaOn) {\n                this.drain();\n                setTimeout(()=>agentRef.runtime.harvester.triggerHarvestFor(this), 0); // send the IPL ixn on next tick, giving some time for any ajax to finish; we may want to just remove this?\n            } else {\n                this.blocked = true; // if rum response determines that customer lacks entitlements for spa endpoint, this feature shouldn't harvest\n                this.deregisterDrain();\n            }\n        });\n        // By default, a complete UI driven interaction requires event -> URL change -> DOM mod in that exact order.\n        (0, $4he1m.registerHandler)('newUIEvent', (event)=>this.startUIInteraction(event.type, Math.floor(event.timeStamp), event.target), this.featureName, this.ee);\n        (0, $4he1m.registerHandler)('newURL', (timestamp, url)=>{\n            // In the case of 'popstate' trigger, by the time the event fires, the URL has already changed, so we need to store what-will-be the *previous* URL for oldURL of next popstate ixn.\n            this.latestHistoryUrl = url;\n            this.interactionInProgress?.updateHistory(timestamp, url);\n        }, this.featureName, this.ee);\n        (0, $4he1m.registerHandler)('newDom', (timestamp)=>{\n            this.interactionInProgress?.updateDom(timestamp);\n            if (this.interactionInProgress?.seenHistoryAndDomChange()) this.interactionInProgress.done();\n        }, this.featureName, this.ee);\n        this.#registerApiHandlers();\n        (0, $4he1m.registerHandler)('ajax', this.#handleAjaxEvent.bind(this), this.featureName, this.ee);\n        (0, $4he1m.registerHandler)('jserror', this.#handleJserror.bind(this), this.featureName, this.ee);\n    }\n    serializer(eventBuffer) {\n        // The payload depacker takes the first ixn of a payload (if there are multiple ixns) and positively offset the subsequent ixns timestamps by that amount.\n        // In order to accurately portray the real start & end times of the 2nd & onward ixns, we hence need to negatively offset their start timestamps with that of the 1st ixn.\n        let firstIxnStartTime;\n        const serializedIxnList = [];\n        for (const interaction of eventBuffer){\n            serializedIxnList.push(interaction.serialize(firstIxnStartTime));\n            if (firstIxnStartTime === undefined) firstIxnStartTime = Math.floor(interaction.start); // careful not to match or overwrite on 0 value!\n        }\n        return \"bel.7;\".concat(serializedIxnList.join(';'));\n    }\n    startUIInteraction(eventName, startedAt, sourceElem) {\n        // this is throttled by instrumentation so that it isn't excessively called\n        if (this.interactionInProgress?.createdByApi) return; // api-started interactions cannot be disrupted aka cancelled by UI events (and the vice versa applies as well)\n        if (this.interactionInProgress?.done() === false) return; // current in-progress is blocked from closing, e.g. by 'waitForEnd' api option\n        const oldURL = eventName === (0, $1ZAXp.INTERACTION_TRIGGERS)[3] ? this.latestHistoryUrl : undefined; // see related comment in 'newURL' handler above, 'popstate'\n        this.interactionInProgress = new (0, $jStS4.Interaction)(this.agentRef, eventName, startedAt, this.latestRouteSetByApi, oldURL);\n        if (eventName === (0, $1ZAXp.INTERACTION_TRIGGERS)[0]) {\n            // 'click'\n            const sourceElemText = $87c3f9698a4c2d00$var$getActionText(sourceElem);\n            if (sourceElemText) this.interactionInProgress.customAttributes.actionText = sourceElemText;\n        }\n        this.interactionInProgress.cancellationTimer = setTimeout(()=>{\n            this.interactionInProgress.done();\n            // Report metric on frequency of cancellation due to timeout for UI ixn\n            this.reportSupportabilityMetric('SoftNav/Interaction/TimeOut');\n        }, 30000); // UI ixn are disregarded after 30 seconds if it's not completed by then\n        this.setClosureHandlers();\n    }\n    setClosureHandlers() {\n        this.interactionInProgress.on('finished', ()=>{\n            const ref = this.interactionInProgress;\n            this.interactionsToHarvest.add(this.interactionInProgress);\n            this.interactionInProgress = null;\n            this.domObserver.disconnect(); // can stop observing whenever our interaction logic completes a cycle\n            // Report metric on the ixn duration\n            this.reportSupportabilityMetric(\"SoftNav/Interaction/\".concat(ref.newURL !== ref.oldURL ? 'RouteChange' : 'Custom', \"/Duration/Ms\"), Math.round(ref.end - ref.start));\n        });\n        this.interactionInProgress.on('cancelled', ()=>{\n            this.interactionInProgress = null;\n            this.domObserver.disconnect();\n        });\n    }\n    /**\n   * Find the active interaction (current or past) for a given timestamp. Note that historic lookups mostly only go as far back as the last harvest for this feature.\n   * Also, the caller should check the status of the interaction returned if found via {@link Interaction.status}, if that's pertinent.\n   * TIP: Cancelled (status) interactions are NOT returned!\n   * IMPORTANT: Finished interactions are in queue for next harvest! It's highly recommended that consumer logic be synchronous for safe reference.\n   * @param {DOMHighResTimeStamp} timestamp\n   * @returns An {@link Interaction} or undefined, if no active interaction was found.\n   */ getInteractionFor(timestamp) {\n        /* In the sole case wherein there can be two \"interactions\" overlapping (initialPageLoad + regular route-change),\n      the regular interaction should get precedence in being assigned the \"active\" interaction in regards to our one-at-a-time model.\n    */ if (this.interactionInProgress?.isActiveDuring(timestamp)) return this.interactionInProgress;\n        let saveIxn;\n        const [{ data: interactionsBuffer }] = this.interactionsToHarvest.get();\n        for(let idx = interactionsBuffer.length - 1; idx >= 0; idx--){\n            // reverse search for the latest completed interaction for efficiency\n            const finishedInteraction = interactionsBuffer[idx];\n            if (finishedInteraction.isActiveDuring(timestamp)) {\n                if (finishedInteraction.trigger !== (0, $1ZAXp.IPL_TRIGGER_NAME)) return finishedInteraction;\n                else saveIxn = finishedInteraction;\n            }\n        }\n        if (saveIxn) return saveIxn; // if an iPL was determined to be active and no route-change was found active for the same time, then iPL is deemed the one\n        if (this.initialPageLoadInteraction?.isActiveDuring(timestamp)) return this.initialPageLoadInteraction; // lowest precedence and also only if it's still in-progress\n    // Time must be when no interaction is happening, so return undefined.\n    }\n    /**\n   * Handles or redirect ajax event based on the interaction, if any, that it's tied to.\n   * @param {Object} event see Ajax feature's storeXhr function for object definition\n   */ #handleAjaxEvent(event) {\n        const associatedInteraction = this.getInteractionFor(event.startTime);\n        if (!associatedInteraction) // no interaction was happening when this ajax started, so give it back to Ajax feature for processing\n        (0, $gy0pT.handle)('returnAjax', [\n            event\n        ], undefined, (0, $3R40a.FEATURE_NAMES).ajax, this.ee);\n        else if (associatedInteraction.status === (0, $1ZAXp.INTERACTION_STATUS).FIN) processAjax(this.agentRef, event, associatedInteraction); // tack ajax onto the ixn object awaiting harvest\n        else {\n            // same thing as above, just at a later time -- if the interaction in progress is cancelled, just send the event back to ajax feat unmodified\n            associatedInteraction.on('finished', ()=>processAjax(this.agentRef, event, associatedInteraction));\n            associatedInteraction.on('cancelled', ()=>(0, $gy0pT.handle)('returnAjax', [\n                    event\n                ], undefined, (0, $3R40a.FEATURE_NAMES).ajax, this.ee));\n        }\n        function processAjax(agent, event, parentInteraction) {\n            const newNode = new (0, $gtRNT.AjaxNode)(agent, event);\n            parentInteraction.addChild(newNode);\n        }\n    }\n    /**\n   * Decorate the passed-in params obj with properties relating to any associated interaction at the time of the timestamp.\n   * @param {Object} params reference to the local var instance in Jserrors feature's storeError\n   * @param {DOMHighResTimeStamp} timestamp time the jserror occurred\n   */ #handleJserror(params, timestamp) {\n        const associatedInteraction = this.getInteractionFor(timestamp);\n        if (!associatedInteraction) return; // do not need to decorate this jserror params\n        // Whether the interaction is in-progress or already finished, the id will let jserror buffer it under its index, until it gets the next step instruction.\n        params.browserInteractionId = associatedInteraction.id;\n        if (associatedInteraction.status === (0, $1ZAXp.INTERACTION_STATUS).FIN) {\n            // This information cannot be relayed back via handle() that flushes buffered errs because this is being called by a jserror's handle() per se and before the err is buffered.\n            params._softNavFinished = true; // instead, signal that this err can be processed right away without needing to be buffered aka wait for an in-progress ixn\n            params._softNavAttributes = associatedInteraction.customAttributes;\n        } else {\n            // These callbacks may be added multiple times for an ixn, but just a single run will deal with all jserrors associated with the interaction.\n            // As such, be cautious not to use the params object since that's tied to one specific jserror and won't affect the rest of them.\n            associatedInteraction.on('finished', (0, $letnH.single)(()=>(0, $gy0pT.handle)('softNavFlush', [\n                    associatedInteraction.id,\n                    true,\n                    associatedInteraction.customAttributes\n                ], undefined, (0, $3R40a.FEATURE_NAMES).jserrors, this.ee)));\n            associatedInteraction.on('cancelled', (0, $letnH.single)(()=>(0, $gy0pT.handle)('softNavFlush', [\n                    associatedInteraction.id,\n                    false,\n                    undefined\n                ], undefined, (0, $3R40a.FEATURE_NAMES).jserrors, this.ee))); // don't take custom attrs from cancelled ixns\n        }\n    }\n    #registerApiHandlers() {\n        const INTERACTION_API = 'api-ixn-';\n        const thisClass = this;\n        (0, $4he1m.registerHandler)(INTERACTION_API + 'get', function(time, { waitForEnd: waitForEnd } = {}) {\n            // In here, 'this' refers to the EventContext specific to per InteractionHandle instance spawned by each .interaction() api call.\n            // Each api call aka IH instance would therefore retain a reference to either the in-progress interaction *at the time of the call* OR a new api-started interaction.\n            this.associatedInteraction = thisClass.getInteractionFor(time);\n            if (this.associatedInteraction?.trigger === (0, $1ZAXp.IPL_TRIGGER_NAME)) this.associatedInteraction = null; // the api get-interaction method cannot target IPL\n            if (!this.associatedInteraction) {\n                // This new api-driven interaction will be the target of any subsequent .interaction() call, until it is closed by EITHER .end() OR the regular seenHistoryAndDomChange process.\n                this.associatedInteraction = thisClass.interactionInProgress = new (0, $jStS4.Interaction)(thisClass.agentRef, (0, $1ZAXp.API_TRIGGER_NAME), time, thisClass.latestRouteSetByApi);\n                thisClass.domObserver.observe(document.body, {\n                    attributes: true,\n                    childList: true,\n                    subtree: true,\n                    characterData: true\n                }); // start observing for DOM changes like a regular UI-driven interaction\n                thisClass.setClosureHandlers();\n            }\n            if (waitForEnd === true) this.associatedInteraction.keepOpenUntilEndApi = true;\n        }, thisClass.featureName, thisClass.ee);\n        (0, $4he1m.registerHandler)(INTERACTION_API + 'end', function(timeNow) {\n            this.associatedInteraction.done(timeNow);\n        }, thisClass.featureName, thisClass.ee);\n        (0, $4he1m.registerHandler)(INTERACTION_API + 'save', function() {\n            this.associatedInteraction.forceSave = true;\n        }, thisClass.featureName, thisClass.ee);\n        (0, $4he1m.registerHandler)(INTERACTION_API + 'ignore', function() {\n            this.associatedInteraction.forceIgnore = true;\n        }, thisClass.featureName, thisClass.ee);\n        (0, $4he1m.registerHandler)(INTERACTION_API + 'getContext', function(time, callback) {\n            if (typeof callback !== 'function') return;\n            setTimeout(()=>callback(this.associatedInteraction.customDataByApi), 0);\n        }, thisClass.featureName, thisClass.ee);\n        (0, $4he1m.registerHandler)(INTERACTION_API + 'onEnd', function(time, callback) {\n            if (typeof callback !== 'function') return;\n            this.associatedInteraction.onDone.push(callback);\n        }, thisClass.featureName, thisClass.ee);\n        (0, $4he1m.registerHandler)(INTERACTION_API + 'actionText', function(time, newActionText) {\n            if (newActionText) this.associatedInteraction.customAttributes.actionText = newActionText;\n        }, thisClass.featureName, thisClass.ee);\n        (0, $4he1m.registerHandler)(INTERACTION_API + 'setName', function(time, name, trigger) {\n            if (name) this.associatedInteraction.customName = name;\n            if (trigger) this.associatedInteraction.trigger = trigger;\n        }, thisClass.featureName, thisClass.ee);\n        (0, $4he1m.registerHandler)(INTERACTION_API + 'setAttribute', function(time, key, value) {\n            this.associatedInteraction.customAttributes[key] = value;\n        }, thisClass.featureName, thisClass.ee);\n        (0, $4he1m.registerHandler)(INTERACTION_API + 'routeName', function(time, newRouteName) {\n            // notice that this fn tampers with the ixn IP, not with the linked ixn\n            thisClass.latestRouteSetByApi = newRouteName;\n            if (thisClass.interactionInProgress) thisClass.interactionInProgress.newRoute = newRouteName;\n        }, thisClass.featureName, thisClass.ee);\n    }\n}\nfunction $87c3f9698a4c2d00$var$getActionText(elem) {\n    const tagName = elem.tagName.toLowerCase();\n    const elementsOfInterest = [\n        'a',\n        'button',\n        'input'\n    ];\n    if (elementsOfInterest.includes(tagName)) return elem.title || elem.value || elem.innerText;\n}\n\n});\nparcelRegister(\"kkmY2\", function(module, exports) {\n\n$parcel$export(module.exports, \"timeToFirstByte\", function () { return $ecc77dc229fa9811$export$55966f8361587cf3; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $9EKMI = parcelRequire(\"9EKMI\");\n\nvar $dYojd = parcelRequire(\"dYojd\");\n\nvar $bDCBv = parcelRequire(\"bDCBv\");\n\nvar $8683F = parcelRequire(\"8683F\");\nconst $ecc77dc229fa9811$export$55966f8361587cf3 = new (0, $bDCBv.VitalMetric)((0, $dYojd.VITAL_NAMES).TIME_TO_FIRST_BYTE);\n/**\n * onTTFB is not supported in the following scenarios:\n * - in a non-browser scope\n * - in browsers that do not support PerformanceNavigationTiming API\n * - in an iOS browser\n * - cross-origin iframes specifically in firefox and safari\n */ if ((0, $9EKMI.isBrowserScope) && typeof PerformanceNavigationTiming !== 'undefined' && !(0, $9EKMI.isiOS) && window === window.parent) (0, $8683F.onTTFB)(({ value: value, attribution: attribution })=>{\n    if ($ecc77dc229fa9811$export$55966f8361587cf3.isValid) return;\n    $ecc77dc229fa9811$export$55966f8361587cf3.update({\n        value: value,\n        attrs: {\n            navigationEntry: attribution.navigationEntry\n        }\n    });\n});\nelse if (!$ecc77dc229fa9811$export$55966f8361587cf3.isValid) {\n    const entry = {};\n    // convert real timestamps to relative timestamps to match web-vitals behavior\n    for(let key in (0, $9EKMI.globalScope)?.performance?.timing || {})entry[key] = Math.max((0, $9EKMI.globalScope)?.performance?.timing[key] - (0, $9EKMI.originTime), 0);\n    // ttfb is equiv to document's responseStart property in timing API --> https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming/responseStart\n    $ecc77dc229fa9811$export$55966f8361587cf3.update({\n        value: entry.responseStart,\n        attrs: {\n            navigationEntry: entry\n        }\n    });\n}\n\n});\n\nparcelRegister(\"gtRNT\", function(module, exports) {\n\n$parcel$export(module.exports, \"AjaxNode\", function () { return $bff9171740061c30$export$f41bb0f2470b8df8; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $ewyxt = parcelRequire(\"ewyxt\");\n\nvar $1ZAXp = parcelRequire(\"1ZAXp\");\n\nvar $525mw = parcelRequire(\"525mw\");\nclass $bff9171740061c30$export$f41bb0f2470b8df8 extends (0, $525mw.BelNode) {\n    constructor(agentRef, ajaxEvent){\n        super(agentRef);\n        this.belType = (0, $1ZAXp.NODE_TYPE).AJAX;\n        this.method = ajaxEvent.method;\n        this.status = ajaxEvent.status;\n        this.domain = ajaxEvent.domain;\n        this.path = ajaxEvent.path;\n        this.txSize = ajaxEvent.requestSize;\n        this.rxSize = ajaxEvent.responseSize;\n        this.requestedWith = ajaxEvent.type === 'fetch' ? 1 : ''; // 'xhr' and 'beacon' types get the empty string\n        this.spanId = ajaxEvent.spanId;\n        this.traceId = ajaxEvent.traceId;\n        this.spanTimestamp = ajaxEvent.spanTimestamp;\n        this.gql = ajaxEvent.gql;\n        this.start = ajaxEvent.startTime; // 5000 --- 5500 --> 10500\n        this.end = ajaxEvent.endTime;\n    }\n    serialize(parentStartTimestamp) {\n        const addString = (0, $ewyxt.getAddStringContext)(this.obfuscator);\n        const nodeList = [];\n        // IMPORTANT: The order in which addString is called matters and correlates to the order in which string shows up in the harvest payload. Do not re-order the following code.\n        const fields = [\n            (0, $ewyxt.numeric)(this.belType),\n            0,\n            // this will be overwritten below with number of attached nodes\n            (0, $ewyxt.numeric)(this.start - parentStartTimestamp),\n            // start relative to parent start (if part of first node in payload) or first parent start\n            (0, $ewyxt.numeric)(this.end - this.start),\n            // end is relative to start\n            (0, $ewyxt.numeric)(this.callbackEnd),\n            (0, $ewyxt.numeric)(this.callbackDuration),\n            addString(this.method),\n            (0, $ewyxt.numeric)(this.status),\n            addString(this.domain),\n            addString(this.path),\n            (0, $ewyxt.numeric)(this.txSize),\n            (0, $ewyxt.numeric)(this.rxSize),\n            this.requestedWith,\n            addString(this.nodeId),\n            (0, $ewyxt.nullable)(this.spanId, addString, true) + (0, $ewyxt.nullable)(this.traceId, addString, true) + (0, $ewyxt.nullable)(this.spanTimestamp, (0, $ewyxt.numeric))\n        ];\n        let allAttachedNodes = [];\n        if (typeof this.gql === 'object') allAttachedNodes = (0, $ewyxt.addCustomAttributes)(this.gql, addString);\n        this.children.forEach((node)=>allAttachedNodes.push(node.serialize())); // no children is expected under ajax nodes at this time\n        fields[1] = (0, $ewyxt.numeric)(allAttachedNodes.length);\n        nodeList.push(fields);\n        if (allAttachedNodes.length) nodeList.push(allAttachedNodes.join(';'));\n        return nodeList.join(';');\n    }\n}\n\n});\nparcelRegister(\"ewyxt\", function(module, exports) {\n\n$parcel$export(module.exports, \"nullable\", function () { return $a92ed88948900b2c$export$133fc36489ac9add; });\n$parcel$export(module.exports, \"numeric\", function () { return $a92ed88948900b2c$export$b7a508fa8dae59fc; });\n$parcel$export(module.exports, \"getAddStringContext\", function () { return $a92ed88948900b2c$export$71f03e17b83cbe02; });\n$parcel$export(module.exports, \"addCustomAttributes\", function () { return $a92ed88948900b2c$export$b7f14f78b59de5aa; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $8KO5M = parcelRequire(\"8KO5M\");\nvar $a92ed88948900b2c$var$hasOwnProp = Object.prototype.hasOwnProperty;\nvar $a92ed88948900b2c$var$MAX_ATTRIBUTES = 64;\nfunction $a92ed88948900b2c$export$133fc36489ac9add(val, fn, comma) {\n    return val || val === 0 || val === '' ? fn(val) + (comma ? ',' : '') : '!';\n}\nfunction $a92ed88948900b2c$export$b7a508fa8dae59fc(n, noDefault) {\n    if (noDefault) return Math.floor(n).toString(36);\n    return n === undefined || n === 0 ? '' : Math.floor(n).toString(36);\n}\nfunction $a92ed88948900b2c$export$71f03e17b83cbe02(obfuscator) {\n    let stringTableIdx = 0;\n    const stringTable = Object.prototype.hasOwnProperty.call(Object, 'create') ? Object.create(null) : {};\n    return addString;\n    function addString(str) {\n        if (typeof str === 'undefined' || str === '') return '';\n        str = obfuscator.obfuscateString(String(str));\n        if ($a92ed88948900b2c$var$hasOwnProp.call(stringTable, str)) return $a92ed88948900b2c$export$b7a508fa8dae59fc(stringTable[str], true);\n        else {\n            stringTable[str] = stringTableIdx++;\n            return $a92ed88948900b2c$var$quoteString(str);\n        }\n    }\n}\nfunction $a92ed88948900b2c$export$b7f14f78b59de5aa(attrs, addString) {\n    var attrParts = [];\n    Object.entries(attrs || {}).forEach(([key, val])=>{\n        if (attrParts.length >= $a92ed88948900b2c$var$MAX_ATTRIBUTES) return;\n        var type = 5;\n        var serializedValue;\n        // add key to string table first\n        key = addString(key);\n        switch(typeof val){\n            case 'object':\n                if (val) // serialize objects to strings\n                serializedValue = addString((0, $8KO5M.stringify)(val));\n                else // null attribute type\n                type = 9;\n                break;\n            case 'number':\n                type = 6;\n                // make sure numbers contain a `.` so they are parsed as doubles\n                serializedValue = val % 1 ? val : val + '.';\n                break;\n            case 'boolean':\n                type = val ? 7 : 8;\n                break;\n            case 'undefined':\n                // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n                type = 9;\n                break;\n            default:\n                serializedValue = addString(val);\n        }\n        attrParts.push([\n            type,\n            key + (serializedValue ? ',' + serializedValue : '')\n        ]);\n    });\n    return attrParts;\n}\nvar $a92ed88948900b2c$var$escapable = /([,\\\\;])/g;\nfunction $a92ed88948900b2c$var$quoteString(str) {\n    return \"'\" + str.replace($a92ed88948900b2c$var$escapable, '\\\\$1');\n}\n\n});\n\nparcelRegister(\"525mw\", function(module, exports) {\n\n$parcel$export(module.exports, \"BelNode\", function () { return $3aa14c7a4b8be17c$export$3dbc0e1afe2e0da8; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ let $3aa14c7a4b8be17c$var$nodesSeen = 0;\nclass $3aa14c7a4b8be17c$export$3dbc0e1afe2e0da8 {\n    belType;\n    /** List of other BelNode derivatives. Each children should be of a subclass that implements its own 'serialize' function. */ children = [];\n    start;\n    end;\n    callbackEnd = 0;\n    callbackDuration = 0;\n    nodeId = ++$3aa14c7a4b8be17c$var$nodesSeen;\n    constructor(agentRef){\n        this.obfuscator = agentRef.runtime.obfuscator;\n        this.info = agentRef.info;\n    }\n    addChild(child) {\n        this.children.push(child);\n    }\n    /** Virtual fn for stringifying an instance. */ serialize() {}\n}\n\n});\n\n\nparcelRegister(\"l3aTe\", function(module, exports) {\n\n$parcel$export(module.exports, \"InitialPageLoadInteraction\", function () { return $f532534ce76998cd$export$a4acef8db8d90afa; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $8aXHb = parcelRequire(\"8aXHb\");\n\nvar $jStS4 = parcelRequire(\"jStS4\");\n\nvar $ewyxt = parcelRequire(\"ewyxt\");\n\nvar $gDw2s = parcelRequire(\"gDw2s\");\n\nvar $ifld8 = parcelRequire(\"ifld8\");\n\nvar $1ZAXp = parcelRequire(\"1ZAXp\");\nclass $f532534ce76998cd$export$a4acef8db8d90afa extends (0, $jStS4.Interaction) {\n    constructor(agentRef){\n        super(agentRef, (0, $1ZAXp.IPL_TRIGGER_NAME), 0, null);\n        this.queueTime = agentRef.info.queueTime;\n        this.appTime = agentRef.info.applicationTime;\n    }\n    get firstPaint() {\n        return (0, $gDw2s.firstPaint).current.value;\n    }\n    get firstContentfulPaint() {\n        return (0, $ifld8.firstContentfulPaint).current.value;\n    }\n    /**\n   * Build the navTiming node. This assumes the navTimingValues array in nav-timing.js has already been filled with values via the PageViewEvent feature having\n   * executed the addPT function first and foremost.\n   */ get navTiming() {\n        if (!(0, $8aXHb.navTimingValues).length) return;\n        /*\n    1. we initialize the seperator to ',' (seperates the nodeType id from the first value)\n    2. we initialize the navTiming node to 'b' (the nodeType id)\n    3. if the value is present, we add the seperator followed by the value;\n       otherwise:\n        - we add null seperator ('!') to the navTimingNode\n        - we set the seperator to an empty string since we already wrote it above\n      the reason for writing the null seperator instead of setting the seperator\n      is to ensure we still write it if the null is the last navTiming value.\n    */ let seperator = ',';\n        let navTimingNode = 'b';\n        let prev = 0;\n        // Get all navTiming values except offset aka timeOrigin since we just consider that (this.start) 0.\n        // These are the latter 20 of the 21 timings appended by addPT:\n        (0, $8aXHb.navTimingValues).slice(1, 21).forEach((v)=>{\n            if (v !== undefined) {\n                navTimingNode += seperator + (0, $ewyxt.numeric)(v - prev);\n                seperator = ',';\n                prev = v;\n            } else {\n                navTimingNode += seperator + '!';\n                seperator = '';\n            }\n        });\n        return navTimingNode;\n    }\n}\n\n});\nparcelRegister(\"8aXHb\", function(module, exports) {\n\n$parcel$export(module.exports, \"navTimingValues\", function () { return $5f3d902af6b1b508$export$2f44a866b65eb89b; });\n$parcel$export(module.exports, \"addPT\", function () { return $5f3d902af6b1b508$export$4eecd77d9102a9b2; });\n$parcel$export(module.exports, \"addPN\", function () { return $5f3d902af6b1b508$export$a47612ea3c40772d; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ // We don't use JSON.stringify directly on the performance timing data for these reasons:\n// * Chrome has extra data in the performance object that we don't want to send all the time (wasteful)\n// * Firefox fails to stringify the native object due to - http://code.google.com/p/v8/issues/detail?id=1223\n// * The variable names are long and wasteful to transmit\n// Add Performance Timing values to the given object.\n// * Values are written relative to an offset to reduce their length (i.e. number of characters).\n// * The offset is sent with the data\n// * 0's are not included unless the value is a 'relative zero'\n//\nvar $5f3d902af6b1b508$var$START = 'Start';\nvar $5f3d902af6b1b508$var$END = 'End';\nvar $5f3d902af6b1b508$var$UNLOAD_EVENT = 'unloadEvent';\nvar $5f3d902af6b1b508$var$REDIRECT = 'redirect';\nvar $5f3d902af6b1b508$var$DOMAIN_LOOKUP = 'domainLookup';\nvar $5f3d902af6b1b508$var$ONNECT = 'onnect';\nvar $5f3d902af6b1b508$var$REQUEST = 'request';\nvar $5f3d902af6b1b508$var$RESPONSE = 'response';\nvar $5f3d902af6b1b508$var$LOAD_EVENT = 'loadEvent';\nvar $5f3d902af6b1b508$var$DOM_CONTENT_LOAD_EVENT = 'domContentLoadedEvent';\nconst $5f3d902af6b1b508$export$2f44a866b65eb89b = [];\nfunction $5f3d902af6b1b508$var$getPntType(type) {\n    if (typeof type === 'number') return type;\n    const types = {\n        navigate: undefined,\n        reload: 1,\n        back_forward: 2,\n        prerender: 3\n    };\n    return types[type];\n}\nfunction $5f3d902af6b1b508$export$4eecd77d9102a9b2(offset, pt, v = {}, isL1Api = false) {\n    if (!pt) return;\n    v.of = offset;\n    $5f3d902af6b1b508$var$handleValue(v.of, v, 'n', true);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$UNLOAD_EVENT + $5f3d902af6b1b508$var$START], v, 'u', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$REDIRECT + $5f3d902af6b1b508$var$START], v, 'r', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$UNLOAD_EVENT + $5f3d902af6b1b508$var$END], v, 'ue', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$REDIRECT + $5f3d902af6b1b508$var$END], v, 're', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt['fetch' + $5f3d902af6b1b508$var$START], v, 'f', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$DOMAIN_LOOKUP + $5f3d902af6b1b508$var$START], v, 'dn', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$DOMAIN_LOOKUP + $5f3d902af6b1b508$var$END], v, 'dne', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt['c' + $5f3d902af6b1b508$var$ONNECT + $5f3d902af6b1b508$var$START], v, 'c', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt['secureC' + $5f3d902af6b1b508$var$ONNECT + 'ion' + $5f3d902af6b1b508$var$START], v, 's', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt['c' + $5f3d902af6b1b508$var$ONNECT + $5f3d902af6b1b508$var$END], v, 'ce', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$REQUEST + $5f3d902af6b1b508$var$START], v, 'rq', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$RESPONSE + $5f3d902af6b1b508$var$START], v, 'rp', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$RESPONSE + $5f3d902af6b1b508$var$END], v, 'rpe', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt.domLoading, v, 'dl', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt.domInteractive, v, 'di', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$DOM_CONTENT_LOAD_EVENT + $5f3d902af6b1b508$var$START], v, 'ds', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$DOM_CONTENT_LOAD_EVENT + $5f3d902af6b1b508$var$END], v, 'de', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt.domComplete, v, 'dc', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$LOAD_EVENT + $5f3d902af6b1b508$var$START], v, 'l', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$LOAD_EVENT + $5f3d902af6b1b508$var$END], v, 'le', isL1Api);\n    return v;\n}\nfunction $5f3d902af6b1b508$export$a47612ea3c40772d(pn, v) {\n    $5f3d902af6b1b508$var$handleValue($5f3d902af6b1b508$var$getPntType(pn.type), v, 'ty');\n    $5f3d902af6b1b508$var$handleValue(pn.redirectCount, v, 'rc');\n    return v;\n}\n/**\n * By side effect, this modifies 'obj' with a mapping of the 'prop' provided to a 'value', and invalid values are not added.\n * On the other hand, the local navTimingValues array gets the value appended if valid and 'undefined' appended if invalid, regardless.\n */ function $5f3d902af6b1b508$var$handleValue(value, obj, prop, isOldApi) {\n    /*\n  For L2 Timing API, the value will already be a relative-to-previous-document DOMHighResTimeStamp.\n  For L1 (deprecated) Timing, the value is an UNIX epoch timestamp, which we will convert to a relative time using our offset.\n  PNT.type is reported as undefined, 1, 2, etc -- note that zero-value properties will be recorded as 'undefined', however DEM interprets undefined \"types\" as \"navigate\"\n  */ if (typeof value === 'number' && value > 0) {\n        // note that zero-value properties will be recorded as 'undefined'\n        if (isOldApi) {\n            const offset = obj?.of > 0 ? obj.of : 0; // expect an epoch timestamp, if called by addPT\n            value = Math.max(value - offset, 0);\n        }\n        value = Math.round(value);\n        obj[prop] = value;\n        $5f3d902af6b1b508$export$2f44a866b65eb89b.push(value);\n    } else $5f3d902af6b1b508$export$2f44a866b65eb89b.push(undefined);\n}\n\n});\n\nparcelRegister(\"jStS4\", function(module, exports) {\n\n$parcel$export(module.exports, \"Interaction\", function () { return $e78a3b3ec2400e03$export$a13296960cae0384; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $9EKMI = parcelRequire(\"9EKMI\");\n\nvar $6sT7C = parcelRequire(\"6sT7C\");\n\nvar $ewyxt = parcelRequire(\"ewyxt\");\n\nvar $1Z3KE = parcelRequire(\"1Z3KE\");\n\nvar $jWywI = parcelRequire(\"jWywI\");\n\nvar $1ZAXp = parcelRequire(\"1ZAXp\");\n\nvar $525mw = parcelRequire(\"525mw\");\nclass $e78a3b3ec2400e03$export$a13296960cae0384 extends (0, $525mw.BelNode) {\n    id = (0, $6sT7C.generateUuid)();\n    initialPageURL = (0, $9EKMI.initialLocation);\n    customName;\n    customAttributes = {};\n    customDataByApi = {};\n    queueTime;\n    appTime;\n    newRoute;\n    /** Internal state of this interaction: in-progress, finished, or cancelled. */ status = (0, $1ZAXp.INTERACTION_STATUS).IP;\n    domTimestamp = 0;\n    historyTimestamp = 0;\n    createdByApi = false;\n    keepOpenUntilEndApi = false;\n    onDone = [];\n    cancellationTimer;\n    constructor(agentRef, uiEvent, uiEventTimestamp, currentRouteKnown, currentUrl){\n        super(agentRef);\n        this.belType = (0, $1ZAXp.NODE_TYPE).INTERACTION;\n        this.trigger = uiEvent;\n        this.start = uiEventTimestamp;\n        this.oldRoute = currentRouteKnown;\n        this.eventSubscription = new Map([\n            [\n                'finished',\n                []\n            ],\n            [\n                'cancelled',\n                []\n            ]\n        ]);\n        this.forceSave = this.forceIgnore = false;\n        if (this.trigger === (0, $1ZAXp.API_TRIGGER_NAME)) this.createdByApi = true;\n        this.newURL = this.oldURL = currentUrl || (0, $9EKMI.globalScope)?.location.href;\n    }\n    updateDom(timestamp) {\n        this.domTimestamp = timestamp || (0, $1Z3KE.now)(); // default timestamp should be precise for accurate isActiveDuring calculations\n    }\n    updateHistory(timestamp, newUrl) {\n        this.newURL = newUrl || '' + (0, $9EKMI.globalScope)?.location;\n        this.historyTimestamp = timestamp || (0, $1Z3KE.now)();\n    }\n    seenHistoryAndDomChange() {\n        return this.historyTimestamp > 0 && this.domTimestamp > this.historyTimestamp; // URL must change before DOM does\n    }\n    on(event, cb) {\n        if (!this.eventSubscription.has(event)) throw new Error('Cannot subscribe to non pre-defined events.');\n        if (typeof cb !== 'function') throw new Error('Must supply function as callback.');\n        this.eventSubscription.get(event).push(cb);\n    }\n    done(customEndTime) {\n        // User could've mark this interaction--regardless UI or api started--as \"don't close until .end() is called on it\". Only .end provides a timestamp; the default flows do not.\n        if (this.keepOpenUntilEndApi && customEndTime === undefined) return false;\n        // If interaction is already closed, this is a no-op. However, returning true lets startUIInteraction know that it CAN start a new interaction, as this one is done.\n        if (this.status !== (0, $1ZAXp.INTERACTION_STATUS).IP) return true;\n        this.onDone.forEach((apiProvidedCb)=>apiProvidedCb(this.customDataByApi)); // this interaction's .save or .ignore can still be set by these user provided callbacks for example\n        if (this.forceIgnore) this.#cancel(); // .ignore() always has precedence over save actions\n        else if (this.seenHistoryAndDomChange()) this.#finish(customEndTime); // then this should've already finished while it was the interactionInProgress, with a natural end time\n        else if (this.forceSave) this.#finish(customEndTime || performance.now()); // a manually saved ixn (did not fulfill conditions) must have a specified end time, if one wasn't provided\n        else this.#cancel();\n        return true;\n    }\n    #finish(customEndTime = 0) {\n        clearTimeout(this.cancellationTimer);\n        this.end = Math.max(this.domTimestamp, this.historyTimestamp, customEndTime);\n        this.customAttributes = {\n            ...this.info.jsAttributes,\n            ...this.customAttributes\n        }; // attrs specific to this interaction should have precedence over the general custom attrs\n        this.status = (0, $1ZAXp.INTERACTION_STATUS).FIN;\n        // Run all the callbacks awaiting this interaction to finish.\n        const callbacks = this.eventSubscription.get('finished');\n        callbacks.forEach((fn)=>fn());\n    }\n    #cancel() {\n        clearTimeout(this.cancellationTimer);\n        this.status = (0, $1ZAXp.INTERACTION_STATUS).CAN;\n        // Run all the callbacks listening to this interaction's potential cancellation.\n        const callbacks = this.eventSubscription.get('cancelled');\n        callbacks.forEach((fn)=>fn());\n    }\n    /**\n   * Given a timestamp, determine if it falls within this interaction's span, i.e. if this was the active interaction during that time.\n   * For in-progress interactions, this only compares the time with the start of span. Cancelled interactions are not considered active at all.\n   * @param {DOMHighResTimeStamp} timestamp\n   * @returns True or false boolean.\n   */ isActiveDuring(timestamp) {\n        if (this.status === (0, $1ZAXp.INTERACTION_STATUS).IP) return this.start <= timestamp;\n        return this.status === (0, $1ZAXp.INTERACTION_STATUS).FIN && this.start <= timestamp && this.end > timestamp;\n    }\n    // Following are virtual properties overridden by a subclass:\n    get firstPaint() {}\n    get firstContentfulPaint() {}\n    get navTiming() {}\n    serialize(firstStartTimeOfPayload) {\n        const isFirstIxnOfPayload = firstStartTimeOfPayload === undefined;\n        const addString = (0, $ewyxt.getAddStringContext)(this.obfuscator);\n        const nodeList = [];\n        let ixnType;\n        if (this.trigger === (0, $1ZAXp.IPL_TRIGGER_NAME)) ixnType = (0, $1ZAXp.INTERACTION_TYPE).INITIAL_PAGE_LOAD;\n        else if (this.newURL !== this.oldURL) ixnType = (0, $1ZAXp.INTERACTION_TYPE).ROUTE_CHANGE;\n        else ixnType = (0, $1ZAXp.INTERACTION_TYPE).UNSPECIFIED;\n        // IMPORTANT: The order in which addString is called matters and correlates to the order in which string shows up in the harvest payload. Do not re-order the following code.\n        const fields = [\n            (0, $ewyxt.numeric)(this.belType),\n            0,\n            // this will be overwritten below with number of attached nodes\n            (0, $ewyxt.numeric)(this.start - (isFirstIxnOfPayload ? 0 : firstStartTimeOfPayload)),\n            // the very 1st ixn does not require offset so it should fallback to a 0 while rest is offset by the very 1st ixn's start\n            (0, $ewyxt.numeric)(this.end - this.start),\n            // end -- relative to start\n            (0, $ewyxt.numeric)(this.callbackEnd),\n            // cbEnd -- relative to start; not used by BrowserInteraction events\n            (0, $ewyxt.numeric)(this.callbackDuration),\n            // not relative\n            addString(this.trigger),\n            addString((0, $jWywI.cleanURL)(this.initialPageURL, true)),\n            addString((0, $jWywI.cleanURL)(this.oldURL, true)),\n            addString((0, $jWywI.cleanURL)(this.newURL, true)),\n            addString(this.customName),\n            ixnType,\n            (0, $ewyxt.nullable)(this.queueTime, (0, $ewyxt.numeric), true) + (0, $ewyxt.nullable)(this.appTime, (0, $ewyxt.numeric), true) + (0, $ewyxt.nullable)(this.oldRoute, addString, true) + (0, $ewyxt.nullable)(this.newRoute, addString, true) + addString(this.id),\n            addString(this.nodeId),\n            (0, $ewyxt.nullable)(this.firstPaint, (0, $ewyxt.numeric), true) + (0, $ewyxt.nullable)(this.firstContentfulPaint, (0, $ewyxt.numeric))\n        ];\n        const allAttachedNodes = (0, $ewyxt.addCustomAttributes)(this.customAttributes || {}, addString); // start with all custom attributes\n        if (this.info.atts) allAttachedNodes.push('a,' + addString(this.info.atts)); // add apm provided attributes\n        /* Querypack encoder+decoder quirkiness:\n       - If first ixn node of payload is being processed, its children's start time must be offset by this node's start. (firstStartTime should be undefined.)\n       - Else for subsequent ixns in the same payload, we go back to using that first ixn node's start to offset their children's start. */ this.children.forEach((node)=>allAttachedNodes.push(node.serialize(isFirstIxnOfPayload ? this.start : firstStartTimeOfPayload))); // recursively add the serialized string of every child of this (ixn) bel node\n        fields[1] = (0, $ewyxt.numeric)(allAttachedNodes.length);\n        nodeList.push(fields);\n        if (allAttachedNodes.length) nodeList.push(allAttachedNodes.join(';'));\n        if (this.navTiming) nodeList.push(this.navTiming);\n        else nodeList.push('');\n        // nodeList = [<fields array>, <serialized string of all attributes and children>, <serialized nav timing info> || '']\n        return nodeList.join(';');\n    }\n}\n\n});\n\n\n\n\n//# sourceMappingURL=aggregate.34b20a32.js.map\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { handle } from '../../../common/event-emitter/handle';\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { single } from '../../../common/util/invoke';\nimport { timeToFirstByte } from '../../../common/vitals/time-to-first-byte';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { API_TRIGGER_NAME, FEATURE_NAME, INTERACTION_STATUS, INTERACTION_TRIGGERS, IPL_TRIGGER_NAME } from '../constants';\nimport { AjaxNode } from './ajax-node';\nimport { InitialPageLoadInteraction } from './initial-page-load-interaction';\nimport { Interaction } from './interaction';\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentRef, {\n    domObserver\n  }) {\n    super(agentRef, FEATURE_NAME);\n    this.interactionsToHarvest = this.events;\n    this.domObserver = domObserver;\n    this.initialPageLoadInteraction = new InitialPageLoadInteraction(agentRef);\n    this.initialPageLoadInteraction.onDone.push(() => {\n      // this ensures the .end() method also works with iPL\n      if (agentRef.runtime.session?.isNew) this.initialPageLoadInteraction.customAttributes.isFirstOfSession = true; // mark the hard page load as first of its session\n      this.initialPageLoadInteraction.forceSave = true; // unless forcibly ignored, iPL always finish by default\n      const ixn = this.initialPageLoadInteraction;\n      this.interactionsToHarvest.add(ixn);\n      this.initialPageLoadInteraction = null;\n    });\n    timeToFirstByte.subscribe(({\n      attrs\n    }) => {\n      const loadEventTime = attrs.navigationEntry.loadEventEnd;\n      this.initialPageLoadInteraction.done(loadEventTime);\n      // Report metric on the initial page load time\n      this.reportSupportabilityMetric('SoftNav/Interaction/InitialPageLoad/Duration/Ms', Math.round(loadEventTime));\n    });\n    this.latestRouteSetByApi = null;\n    this.interactionInProgress = null; // aside from the \"page load\" interaction, there can only ever be 1 ongoing at a time\n    this.latestHistoryUrl = null;\n    this.harvestOpts.beforeUnload = () => this.interactionInProgress?.done(); // return any withheld ajax or jserr events so they can be sent with EoL harvest\n\n    this.waitForFlags(['spa']).then(([spaOn]) => {\n      if (spaOn) {\n        this.drain();\n        setTimeout(() => agentRef.runtime.harvester.triggerHarvestFor(this), 0); // send the IPL ixn on next tick, giving some time for any ajax to finish; we may want to just remove this?\n      } else {\n        this.blocked = true; // if rum response determines that customer lacks entitlements for spa endpoint, this feature shouldn't harvest\n        this.deregisterDrain();\n      }\n    });\n\n    // By default, a complete UI driven interaction requires event -> URL change -> DOM mod in that exact order.\n    registerHandler('newUIEvent', event => this.startUIInteraction(event.type, Math.floor(event.timeStamp), event.target), this.featureName, this.ee);\n    registerHandler('newURL', (timestamp, url) => {\n      // In the case of 'popstate' trigger, by the time the event fires, the URL has already changed, so we need to store what-will-be the *previous* URL for oldURL of next popstate ixn.\n      this.latestHistoryUrl = url;\n      this.interactionInProgress?.updateHistory(timestamp, url);\n    }, this.featureName, this.ee);\n    registerHandler('newDom', timestamp => {\n      this.interactionInProgress?.updateDom(timestamp);\n      if (this.interactionInProgress?.seenHistoryAndDomChange()) this.interactionInProgress.done();\n    }, this.featureName, this.ee);\n    this.#registerApiHandlers();\n    registerHandler('ajax', this.#handleAjaxEvent.bind(this), this.featureName, this.ee);\n    registerHandler('jserror', this.#handleJserror.bind(this), this.featureName, this.ee);\n  }\n  serializer(eventBuffer) {\n    // The payload depacker takes the first ixn of a payload (if there are multiple ixns) and positively offset the subsequent ixns timestamps by that amount.\n    // In order to accurately portray the real start & end times of the 2nd & onward ixns, we hence need to negatively offset their start timestamps with that of the 1st ixn.\n    let firstIxnStartTime;\n    const serializedIxnList = [];\n    for (const interaction of eventBuffer) {\n      serializedIxnList.push(interaction.serialize(firstIxnStartTime));\n      if (firstIxnStartTime === undefined) firstIxnStartTime = Math.floor(interaction.start); // careful not to match or overwrite on 0 value!\n    }\n    return \"bel.7;\".concat(serializedIxnList.join(';'));\n  }\n  startUIInteraction(eventName, startedAt, sourceElem) {\n    // this is throttled by instrumentation so that it isn't excessively called\n    if (this.interactionInProgress?.createdByApi) return; // api-started interactions cannot be disrupted aka cancelled by UI events (and the vice versa applies as well)\n    if (this.interactionInProgress?.done() === false) return; // current in-progress is blocked from closing, e.g. by 'waitForEnd' api option\n\n    const oldURL = eventName === INTERACTION_TRIGGERS[3] ? this.latestHistoryUrl : undefined; // see related comment in 'newURL' handler above, 'popstate'\n    this.interactionInProgress = new Interaction(this.agentRef, eventName, startedAt, this.latestRouteSetByApi, oldURL);\n    if (eventName === INTERACTION_TRIGGERS[0]) {\n      // 'click'\n      const sourceElemText = getActionText(sourceElem);\n      if (sourceElemText) this.interactionInProgress.customAttributes.actionText = sourceElemText;\n    }\n    this.interactionInProgress.cancellationTimer = setTimeout(() => {\n      this.interactionInProgress.done();\n      // Report metric on frequency of cancellation due to timeout for UI ixn\n      this.reportSupportabilityMetric('SoftNav/Interaction/TimeOut');\n    }, 30000); // UI ixn are disregarded after 30 seconds if it's not completed by then\n    this.setClosureHandlers();\n  }\n  setClosureHandlers() {\n    this.interactionInProgress.on('finished', () => {\n      const ref = this.interactionInProgress;\n      this.interactionsToHarvest.add(this.interactionInProgress);\n      this.interactionInProgress = null;\n      this.domObserver.disconnect(); // can stop observing whenever our interaction logic completes a cycle\n\n      // Report metric on the ixn duration\n      this.reportSupportabilityMetric(\"SoftNav/Interaction/\".concat(ref.newURL !== ref.oldURL ? 'RouteChange' : 'Custom', \"/Duration/Ms\"), Math.round(ref.end - ref.start));\n    });\n    this.interactionInProgress.on('cancelled', () => {\n      this.interactionInProgress = null;\n      this.domObserver.disconnect();\n    });\n  }\n\n  /**\n   * Find the active interaction (current or past) for a given timestamp. Note that historic lookups mostly only go as far back as the last harvest for this feature.\n   * Also, the caller should check the status of the interaction returned if found via {@link Interaction.status}, if that's pertinent.\n   * TIP: Cancelled (status) interactions are NOT returned!\n   * IMPORTANT: Finished interactions are in queue for next harvest! It's highly recommended that consumer logic be synchronous for safe reference.\n   * @param {DOMHighResTimeStamp} timestamp\n   * @returns An {@link Interaction} or undefined, if no active interaction was found.\n   */\n  getInteractionFor(timestamp) {\n    /* In the sole case wherein there can be two \"interactions\" overlapping (initialPageLoad + regular route-change),\n      the regular interaction should get precedence in being assigned the \"active\" interaction in regards to our one-at-a-time model.\n    */\n    if (this.interactionInProgress?.isActiveDuring(timestamp)) return this.interactionInProgress;\n    let saveIxn;\n    const [{\n      data: interactionsBuffer\n    }] = this.interactionsToHarvest.get();\n    for (let idx = interactionsBuffer.length - 1; idx >= 0; idx--) {\n      // reverse search for the latest completed interaction for efficiency\n      const finishedInteraction = interactionsBuffer[idx];\n      if (finishedInteraction.isActiveDuring(timestamp)) {\n        if (finishedInteraction.trigger !== IPL_TRIGGER_NAME) return finishedInteraction;\n        // It's possible that a complete interaction occurs before page is fully loaded, so we need to consider if a route-change ixn may have overlapped this iPL\n        else saveIxn = finishedInteraction;\n      }\n    }\n    if (saveIxn) return saveIxn; // if an iPL was determined to be active and no route-change was found active for the same time, then iPL is deemed the one\n    if (this.initialPageLoadInteraction?.isActiveDuring(timestamp)) return this.initialPageLoadInteraction; // lowest precedence and also only if it's still in-progress\n    // Time must be when no interaction is happening, so return undefined.\n  }\n\n  /**\n   * Handles or redirect ajax event based on the interaction, if any, that it's tied to.\n   * @param {Object} event see Ajax feature's storeXhr function for object definition\n   */\n  #handleAjaxEvent(event) {\n    const associatedInteraction = this.getInteractionFor(event.startTime);\n    if (!associatedInteraction) {\n      // no interaction was happening when this ajax started, so give it back to Ajax feature for processing\n      handle('returnAjax', [event], undefined, FEATURE_NAMES.ajax, this.ee);\n    } else {\n      if (associatedInteraction.status === INTERACTION_STATUS.FIN) processAjax(this.agentRef, event, associatedInteraction); // tack ajax onto the ixn object awaiting harvest\n      else {\n        // same thing as above, just at a later time -- if the interaction in progress is cancelled, just send the event back to ajax feat unmodified\n        associatedInteraction.on('finished', () => processAjax(this.agentRef, event, associatedInteraction));\n        associatedInteraction.on('cancelled', () => handle('returnAjax', [event], undefined, FEATURE_NAMES.ajax, this.ee));\n      }\n    }\n    function processAjax(agent, event, parentInteraction) {\n      const newNode = new AjaxNode(agent, event);\n      parentInteraction.addChild(newNode);\n    }\n  }\n\n  /**\n   * Decorate the passed-in params obj with properties relating to any associated interaction at the time of the timestamp.\n   * @param {Object} params reference to the local var instance in Jserrors feature's storeError\n   * @param {DOMHighResTimeStamp} timestamp time the jserror occurred\n   */\n  #handleJserror(params, timestamp) {\n    const associatedInteraction = this.getInteractionFor(timestamp);\n    if (!associatedInteraction) return; // do not need to decorate this jserror params\n\n    // Whether the interaction is in-progress or already finished, the id will let jserror buffer it under its index, until it gets the next step instruction.\n    params.browserInteractionId = associatedInteraction.id;\n    if (associatedInteraction.status === INTERACTION_STATUS.FIN) {\n      // This information cannot be relayed back via handle() that flushes buffered errs because this is being called by a jserror's handle() per se and before the err is buffered.\n      params._softNavFinished = true; // instead, signal that this err can be processed right away without needing to be buffered aka wait for an in-progress ixn\n      params._softNavAttributes = associatedInteraction.customAttributes;\n    } else {\n      // These callbacks may be added multiple times for an ixn, but just a single run will deal with all jserrors associated with the interaction.\n      // As such, be cautious not to use the params object since that's tied to one specific jserror and won't affect the rest of them.\n      associatedInteraction.on('finished', single(() => handle('softNavFlush', [associatedInteraction.id, true, associatedInteraction.customAttributes], undefined, FEATURE_NAMES.jserrors, this.ee)));\n      associatedInteraction.on('cancelled', single(() => handle('softNavFlush', [associatedInteraction.id, false, undefined], undefined, FEATURE_NAMES.jserrors, this.ee))); // don't take custom attrs from cancelled ixns\n    }\n  }\n  #registerApiHandlers() {\n    const INTERACTION_API = 'api-ixn-';\n    const thisClass = this;\n    registerHandler(INTERACTION_API + 'get', function (time, {\n      waitForEnd\n    } = {}) {\n      // In here, 'this' refers to the EventContext specific to per InteractionHandle instance spawned by each .interaction() api call.\n      // Each api call aka IH instance would therefore retain a reference to either the in-progress interaction *at the time of the call* OR a new api-started interaction.\n      this.associatedInteraction = thisClass.getInteractionFor(time);\n      if (this.associatedInteraction?.trigger === IPL_TRIGGER_NAME) this.associatedInteraction = null; // the api get-interaction method cannot target IPL\n      if (!this.associatedInteraction) {\n        // This new api-driven interaction will be the target of any subsequent .interaction() call, until it is closed by EITHER .end() OR the regular seenHistoryAndDomChange process.\n        this.associatedInteraction = thisClass.interactionInProgress = new Interaction(thisClass.agentRef, API_TRIGGER_NAME, time, thisClass.latestRouteSetByApi);\n        thisClass.domObserver.observe(document.body, {\n          attributes: true,\n          childList: true,\n          subtree: true,\n          characterData: true\n        }); // start observing for DOM changes like a regular UI-driven interaction\n        thisClass.setClosureHandlers();\n      }\n      if (waitForEnd === true) this.associatedInteraction.keepOpenUntilEndApi = true;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'end', function (timeNow) {\n      this.associatedInteraction.done(timeNow);\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'save', function () {\n      this.associatedInteraction.forceSave = true;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'ignore', function () {\n      this.associatedInteraction.forceIgnore = true;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'getContext', function (time, callback) {\n      if (typeof callback !== 'function') return;\n      setTimeout(() => callback(this.associatedInteraction.customDataByApi), 0);\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'onEnd', function (time, callback) {\n      if (typeof callback !== 'function') return;\n      this.associatedInteraction.onDone.push(callback);\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'actionText', function (time, newActionText) {\n      if (newActionText) this.associatedInteraction.customAttributes.actionText = newActionText;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'setName', function (time, name, trigger) {\n      if (name) this.associatedInteraction.customName = name;\n      if (trigger) this.associatedInteraction.trigger = trigger;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'setAttribute', function (time, key, value) {\n      this.associatedInteraction.customAttributes[key] = value;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'routeName', function (time, newRouteName) {\n      // notice that this fn tampers with the ixn IP, not with the linked ixn\n      thisClass.latestRouteSetByApi = newRouteName;\n      if (thisClass.interactionInProgress) thisClass.interactionInProgress.newRoute = newRouteName;\n    }, thisClass.featureName, thisClass.ee);\n  }\n}\nfunction getActionText(elem) {\n  const tagName = elem.tagName.toLowerCase();\n  const elementsOfInterest = ['a', 'button', 'input'];\n  if (elementsOfInterest.includes(tagName)) {\n    return elem.title || elem.value || elem.innerText;\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { globalScope, isBrowserScope, isiOS, originTime } from '../constants/runtime';\nimport { VITAL_NAMES } from './constants';\nimport { VitalMetric } from './vital-metric';\nimport { onTTFB } from 'web-vitals/attribution';\nexport const timeToFirstByte = new VitalMetric(VITAL_NAMES.TIME_TO_FIRST_BYTE);\n\n/**\n * onTTFB is not supported in the following scenarios:\n * - in a non-browser scope\n * - in browsers that do not support PerformanceNavigationTiming API\n * - in an iOS browser\n * - cross-origin iframes specifically in firefox and safari\n */\nif (isBrowserScope && typeof PerformanceNavigationTiming !== 'undefined' && !isiOS && window === window.parent) {\n  onTTFB(({\n    value,\n    attribution\n  }) => {\n    if (timeToFirstByte.isValid) return;\n    timeToFirstByte.update({\n      value,\n      attrs: {\n        navigationEntry: attribution.navigationEntry\n      }\n    });\n  });\n} else {\n  if (!timeToFirstByte.isValid) {\n    const entry = {};\n    // convert real timestamps to relative timestamps to match web-vitals behavior\n    for (let key in globalScope?.performance?.timing || {}) entry[key] = Math.max(globalScope?.performance?.timing[key] - originTime, 0);\n\n    // ttfb is equiv to document's responseStart property in timing API --> https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming/responseStart\n    timeToFirstByte.update({\n      value: entry.responseStart,\n      attrs: {\n        navigationEntry: entry\n      }\n    });\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { addCustomAttributes, getAddStringContext, nullable, numeric } from '../../../common/serialize/bel-serializer';\nimport { NODE_TYPE } from '../constants';\nimport { BelNode } from './bel-node';\nexport class AjaxNode extends BelNode {\n  constructor(agentRef, ajaxEvent) {\n    super(agentRef);\n    this.belType = NODE_TYPE.AJAX;\n    this.method = ajaxEvent.method;\n    this.status = ajaxEvent.status;\n    this.domain = ajaxEvent.domain;\n    this.path = ajaxEvent.path;\n    this.txSize = ajaxEvent.requestSize;\n    this.rxSize = ajaxEvent.responseSize;\n    this.requestedWith = ajaxEvent.type === 'fetch' ? 1 : ''; // 'xhr' and 'beacon' types get the empty string\n    this.spanId = ajaxEvent.spanId;\n    this.traceId = ajaxEvent.traceId;\n    this.spanTimestamp = ajaxEvent.spanTimestamp;\n    this.gql = ajaxEvent.gql;\n    this.start = ajaxEvent.startTime; // 5000 --- 5500 --> 10500\n    this.end = ajaxEvent.endTime;\n  }\n  serialize(parentStartTimestamp) {\n    const addString = getAddStringContext(this.obfuscator);\n    const nodeList = [];\n\n    // IMPORTANT: The order in which addString is called matters and correlates to the order in which string shows up in the harvest payload. Do not re-order the following code.\n    const fields = [numeric(this.belType), 0,\n    // this will be overwritten below with number of attached nodes\n    numeric(this.start - parentStartTimestamp),\n    // start relative to parent start (if part of first node in payload) or first parent start\n    numeric(this.end - this.start),\n    // end is relative to start\n    numeric(this.callbackEnd), numeric(this.callbackDuration), addString(this.method), numeric(this.status), addString(this.domain), addString(this.path), numeric(this.txSize), numeric(this.rxSize), this.requestedWith, addString(this.nodeId), nullable(this.spanId, addString, true) + nullable(this.traceId, addString, true) + nullable(this.spanTimestamp, numeric)];\n    let allAttachedNodes = [];\n    if (typeof this.gql === 'object') allAttachedNodes = addCustomAttributes(this.gql, addString);\n    this.children.forEach(node => allAttachedNodes.push(node.serialize())); // no children is expected under ajax nodes at this time\n\n    fields[1] = numeric(allAttachedNodes.length);\n    nodeList.push(fields);\n    if (allAttachedNodes.length) nodeList.push(allAttachedNodes.join(';'));\n    return nodeList.join(';');\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { stringify } from '../util/stringify';\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar MAX_ATTRIBUTES = 64;\nexport function nullable(val, fn, comma) {\n  return val || val === 0 || val === '' ? fn(val) + (comma ? ',' : '') : '!';\n}\nexport function numeric(n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36);\n  }\n  return n === undefined || n === 0 ? '' : Math.floor(n).toString(36);\n}\nexport function getAddStringContext(obfuscator) {\n  let stringTableIdx = 0;\n  const stringTable = Object.prototype.hasOwnProperty.call(Object, 'create') ? Object.create(null) : {};\n  return addString;\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return '';\n    str = obfuscator.obfuscateString(String(str));\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true);\n    } else {\n      stringTable[str] = stringTableIdx++;\n      return quoteString(str);\n    }\n  }\n}\nexport function addCustomAttributes(attrs, addString) {\n  var attrParts = [];\n  Object.entries(attrs || {}).forEach(([key, val]) => {\n    if (attrParts.length >= MAX_ATTRIBUTES) return;\n    var type = 5;\n    var serializedValue;\n    // add key to string table first\n    key = addString(key);\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val));\n        } else {\n          // null attribute type\n          type = 9;\n        }\n        break;\n      case 'number':\n        type = 6;\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.';\n        break;\n      case 'boolean':\n        type = val ? 7 : 8;\n        break;\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9;\n        break;\n      default:\n        serializedValue = addString(val);\n    }\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')]);\n  });\n  return attrParts;\n}\nvar escapable = /([,\\\\;])/g;\nfunction quoteString(str) {\n  return \"'\" + str.replace(escapable, '\\\\$1');\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nlet nodesSeen = 0;\nexport class BelNode {\n  belType;\n  /** List of other BelNode derivatives. Each children should be of a subclass that implements its own 'serialize' function. */\n  children = [];\n  start;\n  end;\n  callbackEnd = 0;\n  callbackDuration = 0;\n  nodeId = ++nodesSeen;\n  constructor(agentRef) {\n    this.obfuscator = agentRef.runtime.obfuscator;\n    this.info = agentRef.info;\n  }\n  addChild(child) {\n    this.children.push(child);\n  }\n\n  /** Virtual fn for stringifying an instance. */\n  serialize() {}\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { navTimingValues } from '../../../common/timing/nav-timing';\nimport { Interaction } from './interaction';\nimport { numeric } from '../../../common/serialize/bel-serializer';\nimport { firstPaint } from '../../../common/vitals/first-paint';\nimport { firstContentfulPaint } from '../../../common/vitals/first-contentful-paint';\nimport { IPL_TRIGGER_NAME } from '../constants';\nexport class InitialPageLoadInteraction extends Interaction {\n  constructor(agentRef) {\n    super(agentRef, IPL_TRIGGER_NAME, 0, null);\n    this.queueTime = agentRef.info.queueTime;\n    this.appTime = agentRef.info.applicationTime;\n  }\n  get firstPaint() {\n    return firstPaint.current.value;\n  }\n  get firstContentfulPaint() {\n    return firstContentfulPaint.current.value;\n  }\n\n  /**\n   * Build the navTiming node. This assumes the navTimingValues array in nav-timing.js has already been filled with values via the PageViewEvent feature having\n   * executed the addPT function first and foremost.\n   */\n  get navTiming() {\n    if (!navTimingValues.length) return;\n    /*\n    1. we initialize the seperator to ',' (seperates the nodeType id from the first value)\n    2. we initialize the navTiming node to 'b' (the nodeType id)\n    3. if the value is present, we add the seperator followed by the value;\n       otherwise:\n        - we add null seperator ('!') to the navTimingNode\n        - we set the seperator to an empty string since we already wrote it above\n      the reason for writing the null seperator instead of setting the seperator\n      is to ensure we still write it if the null is the last navTiming value.\n    */\n    let seperator = ',';\n    let navTimingNode = 'b';\n    let prev = 0;\n\n    // Get all navTiming values except offset aka timeOrigin since we just consider that (this.start) 0.\n    // These are the latter 20 of the 21 timings appended by addPT:\n    navTimingValues.slice(1, 21).forEach(v => {\n      if (v !== undefined) {\n        navTimingNode += seperator + numeric(v - prev);\n        seperator = ',';\n        prev = v;\n      } else {\n        navTimingNode += seperator + '!';\n        seperator = '';\n      }\n    });\n    return navTimingNode;\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// We don't use JSON.stringify directly on the performance timing data for these reasons:\n// * Chrome has extra data in the performance object that we don't want to send all the time (wasteful)\n// * Firefox fails to stringify the native object due to - http://code.google.com/p/v8/issues/detail?id=1223\n// * The variable names are long and wasteful to transmit\n\n// Add Performance Timing values to the given object.\n// * Values are written relative to an offset to reduce their length (i.e. number of characters).\n// * The offset is sent with the data\n// * 0's are not included unless the value is a 'relative zero'\n//\n\nvar START = 'Start';\nvar END = 'End';\nvar UNLOAD_EVENT = 'unloadEvent';\nvar REDIRECT = 'redirect';\nvar DOMAIN_LOOKUP = 'domainLookup';\nvar ONNECT = 'onnect';\nvar REQUEST = 'request';\nvar RESPONSE = 'response';\nvar LOAD_EVENT = 'loadEvent';\nvar DOM_CONTENT_LOAD_EVENT = 'domContentLoadedEvent';\nexport const navTimingValues = [];\nfunction getPntType(type) {\n  if (typeof type === 'number') return type;\n  const types = {\n    navigate: undefined,\n    reload: 1,\n    back_forward: 2,\n    prerender: 3\n  };\n  return types[type];\n}\nexport function addPT(offset, pt, v = {}, isL1Api = false) {\n  if (!pt) return;\n  v.of = offset;\n  handleValue(v.of, v, 'n', true);\n  handleValue(pt[UNLOAD_EVENT + START], v, 'u', isL1Api);\n  handleValue(pt[REDIRECT + START], v, 'r', isL1Api);\n  handleValue(pt[UNLOAD_EVENT + END], v, 'ue', isL1Api);\n  handleValue(pt[REDIRECT + END], v, 're', isL1Api);\n  handleValue(pt['fetch' + START], v, 'f', isL1Api);\n  handleValue(pt[DOMAIN_LOOKUP + START], v, 'dn', isL1Api);\n  handleValue(pt[DOMAIN_LOOKUP + END], v, 'dne', isL1Api);\n  handleValue(pt['c' + ONNECT + START], v, 'c', isL1Api);\n  handleValue(pt['secureC' + ONNECT + 'ion' + START], v, 's', isL1Api);\n  handleValue(pt['c' + ONNECT + END], v, 'ce', isL1Api);\n  handleValue(pt[REQUEST + START], v, 'rq', isL1Api);\n  handleValue(pt[RESPONSE + START], v, 'rp', isL1Api);\n  handleValue(pt[RESPONSE + END], v, 'rpe', isL1Api);\n  handleValue(pt.domLoading, v, 'dl', isL1Api);\n  handleValue(pt.domInteractive, v, 'di', isL1Api);\n  handleValue(pt[DOM_CONTENT_LOAD_EVENT + START], v, 'ds', isL1Api);\n  handleValue(pt[DOM_CONTENT_LOAD_EVENT + END], v, 'de', isL1Api);\n  handleValue(pt.domComplete, v, 'dc', isL1Api);\n  handleValue(pt[LOAD_EVENT + START], v, 'l', isL1Api);\n  handleValue(pt[LOAD_EVENT + END], v, 'le', isL1Api);\n  return v;\n}\n\n// Add Performance Navigation values to the given object\nexport function addPN(pn, v) {\n  handleValue(getPntType(pn.type), v, 'ty');\n  handleValue(pn.redirectCount, v, 'rc');\n  return v;\n}\n\n/**\n * By side effect, this modifies 'obj' with a mapping of the 'prop' provided to a 'value', and invalid values are not added.\n * On the other hand, the local navTimingValues array gets the value appended if valid and 'undefined' appended if invalid, regardless.\n */\nfunction handleValue(value, obj, prop, isOldApi) {\n  /*\n  For L2 Timing API, the value will already be a relative-to-previous-document DOMHighResTimeStamp.\n  For L1 (deprecated) Timing, the value is an UNIX epoch timestamp, which we will convert to a relative time using our offset.\n  PNT.type is reported as undefined, 1, 2, etc -- note that zero-value properties will be recorded as 'undefined', however DEM interprets undefined \"types\" as \"navigate\"\n  */\n  if (typeof value === 'number' && value > 0) {\n    // note that zero-value properties will be recorded as 'undefined'\n    if (isOldApi) {\n      const offset = obj?.of > 0 ? obj.of : 0; // expect an epoch timestamp, if called by addPT\n      value = Math.max(value - offset, 0);\n    }\n    value = Math.round(value);\n    obj[prop] = value;\n    navTimingValues.push(value);\n  } else navTimingValues.push(undefined);\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { globalScope, initialLocation } from '../../../common/constants/runtime';\nimport { generateUuid } from '../../../common/ids/unique-id';\nimport { addCustomAttributes, getAddStringContext, nullable, numeric } from '../../../common/serialize/bel-serializer';\nimport { now } from '../../../common/timing/now';\nimport { cleanURL } from '../../../common/url/clean-url';\nimport { NODE_TYPE, INTERACTION_STATUS, INTERACTION_TYPE, API_TRIGGER_NAME, IPL_TRIGGER_NAME } from '../constants';\nimport { BelNode } from './bel-node';\n\n/**\n * link https://github.com/newrelic/nr-querypack/blob/main/schemas/bel/7.qpschema\n **/\nexport class Interaction extends BelNode {\n  id = generateUuid(); // unique id that is serialized and used to link interactions with errors\n  initialPageURL = initialLocation;\n  customName;\n  customAttributes = {};\n  customDataByApi = {};\n  queueTime; // only used by initialPageLoad interactions\n  appTime; // only used by initialPageLoad interactions\n  newRoute;\n  /** Internal state of this interaction: in-progress, finished, or cancelled. */\n  status = INTERACTION_STATUS.IP;\n  domTimestamp = 0;\n  historyTimestamp = 0;\n  createdByApi = false;\n  keepOpenUntilEndApi = false;\n  onDone = [];\n  cancellationTimer;\n  constructor(agentRef, uiEvent, uiEventTimestamp, currentRouteKnown, currentUrl) {\n    super(agentRef);\n    this.belType = NODE_TYPE.INTERACTION;\n    this.trigger = uiEvent;\n    this.start = uiEventTimestamp;\n    this.oldRoute = currentRouteKnown;\n    this.eventSubscription = new Map([['finished', []], ['cancelled', []]]);\n    this.forceSave = this.forceIgnore = false;\n    if (this.trigger === API_TRIGGER_NAME) this.createdByApi = true;\n    this.newURL = this.oldURL = currentUrl || globalScope?.location.href;\n  }\n  updateDom(timestamp) {\n    this.domTimestamp = timestamp || now(); // default timestamp should be precise for accurate isActiveDuring calculations\n  }\n  updateHistory(timestamp, newUrl) {\n    this.newURL = newUrl || '' + globalScope?.location;\n    this.historyTimestamp = timestamp || now();\n  }\n  seenHistoryAndDomChange() {\n    return this.historyTimestamp > 0 && this.domTimestamp > this.historyTimestamp; // URL must change before DOM does\n  }\n  on(event, cb) {\n    if (!this.eventSubscription.has(event)) throw new Error('Cannot subscribe to non pre-defined events.');\n    if (typeof cb !== 'function') throw new Error('Must supply function as callback.');\n    this.eventSubscription.get(event).push(cb);\n  }\n  done(customEndTime) {\n    // User could've mark this interaction--regardless UI or api started--as \"don't close until .end() is called on it\". Only .end provides a timestamp; the default flows do not.\n    if (this.keepOpenUntilEndApi && customEndTime === undefined) return false;\n    // If interaction is already closed, this is a no-op. However, returning true lets startUIInteraction know that it CAN start a new interaction, as this one is done.\n    if (this.status !== INTERACTION_STATUS.IP) return true;\n    this.onDone.forEach(apiProvidedCb => apiProvidedCb(this.customDataByApi)); // this interaction's .save or .ignore can still be set by these user provided callbacks for example\n\n    if (this.forceIgnore) this.#cancel(); // .ignore() always has precedence over save actions\n    else if (this.seenHistoryAndDomChange()) this.#finish(customEndTime); // then this should've already finished while it was the interactionInProgress, with a natural end time\n    else if (this.forceSave) this.#finish(customEndTime || performance.now()); // a manually saved ixn (did not fulfill conditions) must have a specified end time, if one wasn't provided\n    else this.#cancel();\n    return true;\n  }\n  #finish(customEndTime = 0) {\n    clearTimeout(this.cancellationTimer);\n    this.end = Math.max(this.domTimestamp, this.historyTimestamp, customEndTime);\n    this.customAttributes = {\n      ...this.info.jsAttributes,\n      ...this.customAttributes\n    }; // attrs specific to this interaction should have precedence over the general custom attrs\n    this.status = INTERACTION_STATUS.FIN;\n\n    // Run all the callbacks awaiting this interaction to finish.\n    const callbacks = this.eventSubscription.get('finished');\n    callbacks.forEach(fn => fn());\n  }\n  #cancel() {\n    clearTimeout(this.cancellationTimer);\n    this.status = INTERACTION_STATUS.CAN;\n\n    // Run all the callbacks listening to this interaction's potential cancellation.\n    const callbacks = this.eventSubscription.get('cancelled');\n    callbacks.forEach(fn => fn());\n  }\n\n  /**\n   * Given a timestamp, determine if it falls within this interaction's span, i.e. if this was the active interaction during that time.\n   * For in-progress interactions, this only compares the time with the start of span. Cancelled interactions are not considered active at all.\n   * @param {DOMHighResTimeStamp} timestamp\n   * @returns True or false boolean.\n   */\n  isActiveDuring(timestamp) {\n    if (this.status === INTERACTION_STATUS.IP) return this.start <= timestamp;\n    return this.status === INTERACTION_STATUS.FIN && this.start <= timestamp && this.end > timestamp;\n  }\n\n  // Following are virtual properties overridden by a subclass:\n  get firstPaint() {}\n  get firstContentfulPaint() {}\n  get navTiming() {}\n  serialize(firstStartTimeOfPayload) {\n    const isFirstIxnOfPayload = firstStartTimeOfPayload === undefined;\n    const addString = getAddStringContext(this.obfuscator);\n    const nodeList = [];\n    let ixnType;\n    if (this.trigger === IPL_TRIGGER_NAME) ixnType = INTERACTION_TYPE.INITIAL_PAGE_LOAD;else if (this.newURL !== this.oldURL) ixnType = INTERACTION_TYPE.ROUTE_CHANGE;else ixnType = INTERACTION_TYPE.UNSPECIFIED;\n\n    // IMPORTANT: The order in which addString is called matters and correlates to the order in which string shows up in the harvest payload. Do not re-order the following code.\n    const fields = [numeric(this.belType), 0,\n    // this will be overwritten below with number of attached nodes\n    numeric(this.start - (isFirstIxnOfPayload ? 0 : firstStartTimeOfPayload)),\n    // the very 1st ixn does not require offset so it should fallback to a 0 while rest is offset by the very 1st ixn's start\n    numeric(this.end - this.start),\n    // end -- relative to start\n    numeric(this.callbackEnd),\n    // cbEnd -- relative to start; not used by BrowserInteraction events\n    numeric(this.callbackDuration),\n    // not relative\n    addString(this.trigger), addString(cleanURL(this.initialPageURL, true)), addString(cleanURL(this.oldURL, true)), addString(cleanURL(this.newURL, true)), addString(this.customName), ixnType, nullable(this.queueTime, numeric, true) + nullable(this.appTime, numeric, true) + nullable(this.oldRoute, addString, true) + nullable(this.newRoute, addString, true) + addString(this.id), addString(this.nodeId), nullable(this.firstPaint, numeric, true) + nullable(this.firstContentfulPaint, numeric)];\n    const allAttachedNodes = addCustomAttributes(this.customAttributes || {}, addString); // start with all custom attributes\n    if (this.info.atts) allAttachedNodes.push('a,' + addString(this.info.atts)); // add apm provided attributes\n    /* Querypack encoder+decoder quirkiness:\n       - If first ixn node of payload is being processed, its children's start time must be offset by this node's start. (firstStartTime should be undefined.)\n       - Else for subsequent ixns in the same payload, we go back to using that first ixn node's start to offset their children's start. */\n    this.children.forEach(node => allAttachedNodes.push(node.serialize(isFirstIxnOfPayload ? this.start : firstStartTimeOfPayload))); // recursively add the serialized string of every child of this (ixn) bel node\n\n    fields[1] = numeric(allAttachedNodes.length);\n    nodeList.push(fields);\n    if (allAttachedNodes.length) nodeList.push(allAttachedNodes.join(';'));\n    if (this.navTiming) nodeList.push(this.navTiming);else nodeList.push('');\n    // nodeList = [<fields array>, <serialized string of all attributes and children>, <serialized nav timing info> || '']\n\n    return nodeList.join(';');\n  }\n}"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","self","window","global","parcelRegister","register","module","exports","$87c3f9698a4c2d00$export$b9601df20779e14a","$gy0pT","$4he1m","$letnH","$kkmY2","$3R40a","$3DmF0","$1ZAXp","$gtRNT","$l3aTe","$jStS4","AggregateBase","featureName","FEATURE_NAME","constructor","agentRef","domObserver","interactionsToHarvest","events","initialPageLoadInteraction","InitialPageLoadInteraction","onDone","push","runtime","session","isNew","customAttributes","isFirstOfSession","forceSave","ixn","add","timeToFirstByte","subscribe","attrs","loadEventTime","navigationEntry","loadEventEnd","done","reportSupportabilityMetric","Math","round","latestRouteSetByApi","interactionInProgress","latestHistoryUrl","harvestOpts","beforeUnload","waitForFlags","then","spaOn","drain","setTimeout","harvester","triggerHarvestFor","blocked","deregisterDrain","registerHandler","event","startUIInteraction","type","floor","timeStamp","target","ee","timestamp","url","updateHistory","updateDom","seenHistoryAndDomChange","bind","serializer","eventBuffer","firstIxnStartTime","serializedIxnList","interaction","serialize","undefined","start","concat","join","eventName","startedAt","sourceElem","createdByApi","oldURL","INTERACTION_TRIGGERS","Interaction","sourceElemText","$87c3f9698a4c2d00$var$getActionText","elem","elementsOfInterest","includes","tagName","toLowerCase","title","value","innerText","actionText","cancellationTimer","setClosureHandlers","on","ref","disconnect","newURL","end","getInteractionFor","saveIxn","isActiveDuring","data","interactionsBuffer","idx","length","finishedInteraction","trigger","IPL_TRIGGER_NAME","associatedInteraction","startTime","processAjax","agent","parentInteraction","newNode","AjaxNode","addChild","status","INTERACTION_STATUS","FIN","handle","FEATURE_NAMES","ajax","params","browserInteractionId","id","_softNavFinished","_softNavAttributes","single","jserrors","INTERACTION_API","thisClass","time","waitForEnd","API_TRIGGER_NAME","observe","document","body","attributes","childList","subtree","characterData","keepOpenUntilEndApi","timeNow","forceIgnore","callback","customDataByApi","newActionText","name","customName","key","newRouteName","newRoute","$ecc77dc229fa9811$export$55966f8361587cf3","$9EKMI","$dYojd","$bDCBv","$8683F","VitalMetric","VITAL_NAMES","TIME_TO_FIRST_BYTE","isBrowserScope","PerformanceNavigationTiming","isiOS","parent","onTTFB","attribution","isValid","update","entry","globalScope","performance","timing","max","originTime","responseStart","$bff9171740061c30$export$f41bb0f2470b8df8","$ewyxt","$525mw","BelNode","ajaxEvent","belType","NODE_TYPE","AJAX","method","domain","path","txSize","requestSize","rxSize","responseSize","requestedWith","spanId","traceId","spanTimestamp","gql","endTime","parentStartTimestamp","addString","getAddStringContext","obfuscator","nodeList","fields","numeric","callbackEnd","callbackDuration","nodeId","nullable","allAttachedNodes","addCustomAttributes","children","forEach","node","$a92ed88948900b2c$export$133fc36489ac9add","$a92ed88948900b2c$export$b7a508fa8dae59fc","$a92ed88948900b2c$export$71f03e17b83cbe02","$a92ed88948900b2c$export$b7f14f78b59de5aa","$8KO5M","$a92ed88948900b2c$var$hasOwnProp","prototype","hasOwnProperty","val","fn","comma","noDefault","toString","stringTableIdx","stringTable","call","create","str","obfuscateString","String","replace","$a92ed88948900b2c$var$escapable","attrParts","entries","serializedValue","stringify","$3aa14c7a4b8be17c$export$3dbc0e1afe2e0da8","$3aa14c7a4b8be17c$var$nodesSeen","info","child","$f532534ce76998cd$export$a4acef8db8d90afa","$8aXHb","$gDw2s","$ifld8","queueTime","appTime","applicationTime","firstPaint","current","firstContentfulPaint","navTiming","navTimingValues","seperator","navTimingNode","prev","slice","$5f3d902af6b1b508$export$2f44a866b65eb89b","$5f3d902af6b1b508$export$4eecd77d9102a9b2","$5f3d902af6b1b508$export$a47612ea3c40772d","$5f3d902af6b1b508$var$START","$5f3d902af6b1b508$var$UNLOAD_EVENT","$5f3d902af6b1b508$var$REDIRECT","$5f3d902af6b1b508$var$DOMAIN_LOOKUP","$5f3d902af6b1b508$var$ONNECT","$5f3d902af6b1b508$var$RESPONSE","$5f3d902af6b1b508$var$LOAD_EVENT","$5f3d902af6b1b508$var$DOM_CONTENT_LOAD_EVENT","offset","pt","isL1Api","of","$5f3d902af6b1b508$var$handleValue","$5f3d902af6b1b508$var$REQUEST","domLoading","domInteractive","domComplete","pn","types","navigate","reload","back_forward","prerender","redirectCount","obj","prop","isOldApi","$e78a3b3ec2400e03$export$a13296960cae0384","$6sT7C","$1Z3KE","$jWywI","generateUuid","initialPageURL","initialLocation","IP","domTimestamp","historyTimestamp","uiEvent","uiEventTimestamp","currentRouteKnown","currentUrl","INTERACTION","oldRoute","eventSubscription","Map","location","href","now","newUrl","cb","has","Error","customEndTime","apiProvidedCb","clearTimeout","jsAttributes","callbacks","CAN","firstStartTimeOfPayload","ixnType","isFirstIxnOfPayload","INTERACTION_TYPE","INITIAL_PAGE_LOAD","ROUTE_CHANGE","UNSPECIFIED","cleanURL","atts"],"version":3,"file":"aggregate.34b20a32.js.map"}
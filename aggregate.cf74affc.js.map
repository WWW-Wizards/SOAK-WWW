{"mappings":"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","sources":["<anon>","node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/index.js","node_modules/@newrelic/browser-agent/dist/esm/common/timing/nav-timing.js","node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/interaction.js","node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/interaction-node.js","node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/serializer.js","node_modules/@newrelic/browser-agent/dist/esm/common/serialize/bel-serializer.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var parcelRequire = $parcel$global[\"parcelRequire5e30\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"gw6Td\", function(module, exports) {\n\n$parcel$export(module.exports, \"Aggregate\", function () { return $c064faa4a9ed4ca3$export$b9601df20779e14a; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ /* eslint no-undef: \"error\" */ \nvar $4he1m = parcelRequire(\"4he1m\");\n\nvar $5qa2T = parcelRequire(\"5qa2T\");\n\nvar $9ZQLQ = parcelRequire(\"9ZQLQ\");\n\nvar $8aXHb = parcelRequire(\"8aXHb\");\n\nvar $6sT7C = parcelRequire(\"6sT7C\");\n\nvar $5ML72 = parcelRequire(\"5ML72\");\n\nvar $8FJov = parcelRequire(\"8FJov\");\n\nvar $fPO2Q = parcelRequire(\"fPO2Q\");\n\nvar $im7dd = parcelRequire(\"im7dd\");\n\nvar $5boo9 = parcelRequire(\"5boo9\");\n\nvar $3R40a = parcelRequire(\"3R40a\");\n\nvar $3DmF0 = parcelRequire(\"3DmF0\");\n\nvar $ifld8 = parcelRequire(\"ifld8\");\n\nvar $gDw2s = parcelRequire(\"gDw2s\");\n\nvar $3Nvam = parcelRequire(\"3Nvam\");\n\nvar $9EKMI = parcelRequire(\"9EKMI\");\n\nvar $gy0pT = parcelRequire(\"gy0pT\");\n\nvar $bu0p3 = parcelRequire(\"bu0p3\");\n\nvar $jkuUu = parcelRequire(\"jkuUu\");\nconst { FEATURE_NAME: $c064faa4a9ed4ca3$var$FEATURE_NAME, INTERACTION_EVENTS: $c064faa4a9ed4ca3$var$INTERACTION_EVENTS, MAX_TIMER_BUDGET: $c064faa4a9ed4ca3$var$MAX_TIMER_BUDGET, FN_START: $c064faa4a9ed4ca3$var$FN_START, FN_END: $c064faa4a9ed4ca3$var$FN_END, CB_START: $c064faa4a9ed4ca3$var$CB_START, INTERACTION_API: $c064faa4a9ed4ca3$var$INTERACTION_API, REMAINING: $c064faa4a9ed4ca3$var$REMAINING, INTERACTION: $c064faa4a9ed4ca3$var$INTERACTION, SPA_NODE: $c064faa4a9ed4ca3$var$SPA_NODE, JSONP_NODE: $c064faa4a9ed4ca3$var$JSONP_NODE, FETCH_START: $c064faa4a9ed4ca3$var$FETCH_START, FETCH_DONE: $c064faa4a9ed4ca3$var$FETCH_DONE, FETCH_BODY: $c064faa4a9ed4ca3$var$FETCH_BODY, JSONP_END: $c064faa4a9ed4ca3$var$JSONP_END, originalSetTimeout: $c064faa4a9ed4ca3$var$originalSetTimeout } = $5boo9;\nclass $c064faa4a9ed4ca3$export$b9601df20779e14a extends (0, $3DmF0.AggregateBase) {\n    static featureName = $c064faa4a9ed4ca3$var$FEATURE_NAME;\n    constructor(agentRef){\n        super(agentRef, $c064faa4a9ed4ca3$var$FEATURE_NAME);\n        const state = this.state = {\n            initialPageURL: (0, $9EKMI.initialLocation),\n            lastSeenUrl: (0, $9EKMI.initialLocation),\n            lastSeenRouteName: null,\n            timerMap: {},\n            timerBudget: $c064faa4a9ed4ca3$var$MAX_TIMER_BUDGET,\n            currentNode: null,\n            prevNode: null,\n            nodeOnLastHashUpdate: null,\n            initialPageLoad: null,\n            pageLoaded: false,\n            childTime: 0,\n            depth: 0,\n            // The below feature flag is used to disable the SPA ajax fix for specific customers, see https://new-relic.atlassian.net/browse/NR-172169\n            disableSpaFix: (agentRef.init.feature_flags || []).indexOf('disable-spa-fix') > -1\n        };\n        this.spaSerializerClass = new (0, $fPO2Q.Serializer)(agentRef);\n        const classThis = this;\n        const baseEE = (0, $im7dd.ee).get(agentRef.agentIdentifier); // <-- parent baseEE\n        const mutationEE = baseEE.get('mutation');\n        const promiseEE = baseEE.get('promise');\n        const historyEE = baseEE.get('history');\n        const eventsEE = baseEE.get('events'); // ajax --> ee(123).emit() ee()\n        const timerEE = baseEE.get('timer');\n        const fetchEE = baseEE.get('fetch');\n        const jsonpEE = baseEE.get('jsonp');\n        const xhrEE = baseEE.get('xhr');\n        const tracerEE = baseEE.get('tracer');\n        // childTime is used when calculating exclusive time for a cb duration.\n        //\n        // Exclusive time will be different than the total time for either callbacks\n        // which synchronously invoke a customTracer callback or, trigger a synchronous\n        // event (eg. onreadystate=1 or popstate).\n        //\n        // At fn-end, childTime will contain the total time of all timed callbacks and\n        // event handlers which executed as a child of the current callback. At the\n        // begining of every callback, childTime is saved to the event context (which at\n        // that time contains the sum of its preceeding siblings) and is reset to 0. The\n        // callback is then executed, and its children may increase childTime.  At the\n        // end of the callback, it reports its exclusive time as its\n        // execution time - exlcuded. childTime is then reset to its previous\n        // value, and the totalTime of the callback that just finished executing is\n        // added to the childTime time.\n        //                                    | clock | childTime | ctx.ct | totalTime | exclusive |\n        // click fn-start                     |   0   |    0     |    0   |           |           |\n        //  | click begining:                 |   5   |    0     |    0   |           |           |\n        //  |   | custom-1 fn-start           |   10  |    0     |    0   |           |           |\n        //  |   |   |  custom-1 begining      |   15  |    0     |    0   |           |           |\n        //  |   |   |    |  custom-2 fn-start |   20  |    0     |    0   |           |           |\n        //  |   |   |    |  | custom-2        |   25  |    0     |    0   |           |           |\n        //  |   |   |    |  custom-2 fn-end   |   30  |    10    |    0   |     10    |     10    |\n        //  |   |   |  custom-1 middle        |   35  |    10    |    0   |           |           |\n        //  |   |   |    |  custom-3 fn-start |   40  |    0     |    10  |           |           |\n        //  |   |   |    |  | custom-3        |   45  |    0     |    10  |           |           |\n        //  |   |   |    |  custom-3 fn-end   |   50  |    20    |    0   |     10    |     10    |\n        //  |   |   |  custom-1 ending        |   55  |    20    |    0   |           |           |\n        //  |     custom-1 fn-end             |   60  |    50    |    0   |     50    |     30    |\n        //  | click ending:                   |   65  |    50    |        |           |           |\n        // click fn-end                       |   70  |    0     |    0   |     70    |     20    |\n        let harvester;\n        this.waitForFlags([\n            'spa'\n        ]).then(([spaFlag])=>{\n            if (spaFlag) {\n                harvester = agentRef.runtime.harvester; // since this is after RUM call, PVE would've initialized harvester by now\n                this.drain();\n            } else {\n                this.blocked = true;\n                this.deregisterDrain();\n            }\n        });\n        if (agentRef.init.spa.enabled !== true) return;\n        state.initialPageLoad = new (0, $5ML72.Interaction)('initialPageLoad', 0, state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentRef);\n        state.initialPageLoad.save = true;\n        if (agentRef.runtime.session?.isNew) state.initialPageLoad.root.attrs.custom.isFirstOfSession = true; // mark the hard page load as first of its session\n        state.prevInteraction = state.initialPageLoad;\n        state.currentNode = state.initialPageLoad.root; // hint\n        // ensure that checkFinish calls are safe during initialPageLoad\n        state.initialPageLoad[$c064faa4a9ed4ca3$var$REMAINING]++;\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$FN_START, callbackStart, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$CB_START, callbackStart, this.featureName, promiseEE);\n        // register plugins\n        var pluginApi = {\n            getCurrentNode: getCurrentNode,\n            setCurrentNode: setCurrentNode\n        };\n        (0, $4he1m.registerHandler)('spa-register', function(init) {\n            if (typeof init === 'function') init(pluginApi);\n        }, (0, $3R40a.FEATURE_NAMES).spa, baseEE);\n        function callbackStart() {\n            state.depth++;\n            this.prevNode = state.currentNode;\n            this.ct = state.childTime;\n            state.childTime = 0;\n            state.timerBudget = $c064faa4a9ed4ca3$var$MAX_TIMER_BUDGET;\n        }\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$FN_END, callbackEnd, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)('cb-end', callbackEnd, this.featureName, promiseEE);\n        function callbackEnd() {\n            state.depth--;\n            var totalTime = this.jsTime || 0;\n            var exclusiveTime = totalTime - state.childTime;\n            state.childTime = this.ct + totalTime;\n            if (state.currentNode) {\n                // transfer accumulated callback time to the active interaction node\n                // run even if jsTime is 0 to update jsEnd\n                state.currentNode.callback(exclusiveTime, this[$c064faa4a9ed4ca3$var$FN_END]);\n                if (this.isTraced) state.currentNode.attrs.tracedTime = exclusiveTime;\n            }\n            this.jsTime = state.currentNode ? 0 : exclusiveTime;\n            setCurrentNode(this.prevNode);\n            this.prevNode = null;\n            state.timerBudget = $c064faa4a9ed4ca3$var$MAX_TIMER_BUDGET;\n        }\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$FN_START, function(args, eventSource) {\n            var ev = args[0];\n            var evName = ev.type;\n            var eventNode = ev[\"__nrNode:\".concat((0, $3Nvam.bundleId))];\n            if (!state.pageLoaded && (evName === 'load' && eventSource === window || (0, $9EKMI.loadedAsDeferredBrowserScript))) {\n                state.pageLoaded = true;\n                // set to null so prevNode is set correctly\n                this.prevNode = state.currentNode = null;\n                if (state.initialPageLoad) {\n                    eventNode = state.initialPageLoad.root;\n                    // Even if initialPageLoad has remaining callbacks, force the initialPageLoad\n                    // interaction to complete when the page load event occurs.\n                    state.initialPageLoad[$c064faa4a9ed4ca3$var$REMAINING] = 0;\n                    $c064faa4a9ed4ca3$var$originalSetTimeout(function() {\n                        $c064faa4a9ed4ca3$var$INTERACTION_EVENTS.push('popstate');\n                    });\n                }\n            }\n            if (eventNode) // If we've already seen a previous handler for this specific event object,\n            // just restore that. We want multiple handlers for the same event to share\n            // a node.\n            setCurrentNode(eventNode);\n            else if (evName === 'hashchange') {\n                setCurrentNode(state.nodeOnLastHashUpdate);\n                state.nodeOnLastHashUpdate = null;\n            } else if (eventSource instanceof XMLHttpRequest) // If this event was emitted by an XHR, restore the node ID associated with\n            // that XHR.\n            setCurrentNode(baseEE.context(eventSource).spaNode);\n            else if (!state.currentNode && $c064faa4a9ed4ca3$var$INTERACTION_EVENTS.indexOf(evName) !== -1) {\n                // Otherwise, if no interaction is currently active, create a new node ID,\n                // and let the aggregator know that we entered a new event handler callback\n                // so that it has a chance to possibly start an interaction.\n                var ixn = new (0, $5ML72.Interaction)(evName, this[$c064faa4a9ed4ca3$var$FN_START], state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentRef);\n                // Store the interaction as prevInteraction in case it is prematurely discarded\n                state.prevInteraction = ixn;\n                setCurrentNode(ixn.root);\n                if (evName === 'click') {\n                    var value = getActionText(ev.target);\n                    if (value) state.currentNode.attrs.custom.actionText = value;\n                }\n            }\n            ev[\"__nrNode:\".concat((0, $3Nvam.bundleId))] = state.currentNode;\n        }, this.featureName, eventsEE);\n        /**\n     * *** TIMERS ***\n     * setTimeout call needs to keep the interaction active in case a node is started\n     * in its callback.\n     */ // The context supplied to this callback will be shared with the fn-start/fn-end\n        // callbacks that fire around the callback passed to setTimeout originally.\n        (0, $4he1m.registerHandler)('setTimeout-end', function saveId(args, obj, timerId) {\n            if (!state.currentNode || state.timerBudget - this.timerDuration < 0) return;\n            if (args && !(args[0] instanceof Function)) return;\n            state.currentNode[$c064faa4a9ed4ca3$var$INTERACTION][$c064faa4a9ed4ca3$var$REMAINING]++;\n            this.timerId = timerId;\n            state.timerMap[timerId] = state.currentNode;\n            this.timerBudget = state.timerBudget - 50;\n        }, this.featureName, timerEE);\n        (0, $4he1m.registerHandler)('clearTimeout-start', function clear(args) {\n            var timerId = args[0];\n            var node = state.timerMap[timerId];\n            if (node) {\n                var interaction = node[$c064faa4a9ed4ca3$var$INTERACTION];\n                interaction[$c064faa4a9ed4ca3$var$REMAINING]--;\n                interaction.checkFinish();\n                delete state.timerMap[timerId];\n            }\n        }, this.featureName, timerEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$FN_START, function() {\n            state.timerBudget = this.timerBudget || $c064faa4a9ed4ca3$var$MAX_TIMER_BUDGET;\n            var id = this.timerId;\n            var node = state.timerMap[id];\n            setCurrentNode(node);\n            delete state.timerMap[id];\n            if (node) node[$c064faa4a9ed4ca3$var$INTERACTION][$c064faa4a9ed4ca3$var$REMAINING]--;\n        }, this.featureName, timerEE);\n        /**\n     * *** XHR ***\n     * - `new-xhr` event is fired when new instance of XHR is created. Here we create\n     *    a new node and store it on the XHR object.\n     * -  When the send method is called (`send-xhr-start` event), we tell the interaction\n     *    to wait for this XHR to complete.\n     * -  When any direct event handlers are invoked (`fn-start` on the `xhr` emitter),\n     *    we restore the node in case other child nodes are started here.\n     * -  Callbacks attached using `addEventListener` are handled using `fn-start` on the\n     *    `events` emitter.\n     * -  When `xhr-resolved` is emitted, we end the node. The node.finish() call also\n     *    instructs the interaction to stop waiting for this node.\n     */ // context is shared with new-xhr event, and is stored on the xhr iteself.\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$FN_START, function() {\n            setCurrentNode(this[$c064faa4a9ed4ca3$var$SPA_NODE]);\n        }, this.featureName, xhrEE);\n        // context is stored on the xhr and is shared with all callbacks associated\n        // with the new xhr\n        (0, $4he1m.registerHandler)('new-xhr', function() {\n            if (!state.disableSpaFix && !state.currentNode && state.prevInteraction && !state.prevInteraction.ignored) {\n                /*\n         * The previous interaction was discarded before a route change. Restore the interaction\n         * in case this XHR is associated with a route change.\n         */ const interaction = state.prevInteraction;\n                state.currentNode = interaction.root;\n                interaction.root.end = null;\n            }\n            if (state.currentNode) this[$c064faa4a9ed4ca3$var$SPA_NODE] = state.currentNode.child('ajax', null, null, true);\n        }, this.featureName, xhrEE);\n        (0, $4he1m.registerHandler)('send-xhr-start', function() {\n            var node = this[$c064faa4a9ed4ca3$var$SPA_NODE];\n            if (node && !this.sent) {\n                this.sent = true;\n                node.dt = this.dt;\n                if (node.dt?.timestamp) node.dt.timestamp = agentRef.runtime.timeKeeper.correctAbsoluteTimestamp(node.dt.timestamp);\n                node.jsEnd = node.start = this.startTime;\n                node[$c064faa4a9ed4ca3$var$INTERACTION][$c064faa4a9ed4ca3$var$REMAINING]++;\n            }\n        }, this.featureName, xhrEE);\n        (0, $4he1m.registerHandler)('xhr-resolved', function() {\n            var node = this[$c064faa4a9ed4ca3$var$SPA_NODE];\n            if (node) {\n                if (!(0, $9ZQLQ.shouldCollectEvent)(this.params)) {\n                    node.cancel();\n                    return;\n                }\n                var attrs = node.attrs;\n                attrs.params = this.params;\n                attrs.metrics = this.metrics;\n                node.finish(this.endTime);\n                if (!!this.currentNode && !!this.currentNode.interaction) this.currentNode.interaction.checkFinish();\n            }\n        }, this.featureName, baseEE);\n        /**\n     * *** JSONP ***\n     *\n     */ (0, $4he1m.registerHandler)('new-jsonp', function(url) {\n            if (state.currentNode) {\n                var node = this[$c064faa4a9ed4ca3$var$JSONP_NODE] = state.currentNode.child('ajax', this[$c064faa4a9ed4ca3$var$FETCH_START]);\n                node.start = this['new-jsonp'];\n                this.url = url;\n                this.status = null;\n            }\n        }, this.featureName, jsonpEE);\n        (0, $4he1m.registerHandler)('cb-start', function(args) {\n            var node = this[$c064faa4a9ed4ca3$var$JSONP_NODE];\n            if (node) {\n                setCurrentNode(node);\n                this.status = 200;\n            }\n        }, this.featureName, jsonpEE);\n        (0, $4he1m.registerHandler)('jsonp-error', function() {\n            var node = this[$c064faa4a9ed4ca3$var$JSONP_NODE];\n            if (node) {\n                setCurrentNode(node);\n                this.status = 0;\n            }\n        }, this.featureName, jsonpEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$JSONP_END, function() {\n            var node = this[$c064faa4a9ed4ca3$var$JSONP_NODE];\n            if (node) {\n                // if no status is set then cb never fired - so it's not a valid JSONP\n                if (this.status === null) {\n                    node.cancel();\n                    return;\n                }\n                var attrs = node.attrs;\n                var params = attrs.params = {};\n                var parsed = (0, $5qa2T.parseUrl)(this.url);\n                params.method = 'GET';\n                params.pathname = parsed.pathname;\n                params.host = parsed.hostname + ':' + parsed.port;\n                params.status = this.status;\n                attrs.metrics = {\n                    txSize: 0,\n                    rxSize: 0\n                };\n                attrs.isJSONP = true;\n                node.jsEnd = this[$c064faa4a9ed4ca3$var$JSONP_END];\n                node.jsTime = this[$c064faa4a9ed4ca3$var$CB_START] ? this[$c064faa4a9ed4ca3$var$JSONP_END] - this[$c064faa4a9ed4ca3$var$CB_START] : 0;\n                node.finish(node.jsEnd);\n            }\n        }, this.featureName, jsonpEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$FETCH_START, function(fetchArguments, dtPayload) {\n            if (fetchArguments) {\n                if (!state.disableSpaFix && !state.currentNode && state.prevInteraction && !state.prevInteraction.ignored) {\n                    /*\n           * The previous interaction was discarded before a route change. Restore the interaction\n           * in case this XHR is associated with a route change.\n           */ const interaction = state.prevInteraction;\n                    state.currentNode = interaction.root;\n                    interaction.root.end = null;\n                }\n                if (state.currentNode) {\n                    this[$c064faa4a9ed4ca3$var$SPA_NODE] = state.currentNode.child('ajax', this[$c064faa4a9ed4ca3$var$FETCH_START]);\n                    if (dtPayload && this[$c064faa4a9ed4ca3$var$SPA_NODE]) {\n                        this[$c064faa4a9ed4ca3$var$SPA_NODE].dt = dtPayload;\n                        if (this[$c064faa4a9ed4ca3$var$SPA_NODE].dt?.timestamp) this[$c064faa4a9ed4ca3$var$SPA_NODE].dt.timestamp = agentRef.runtime.timeKeeper.correctAbsoluteTimestamp(this[$c064faa4a9ed4ca3$var$SPA_NODE].dt.timestamp);\n                    }\n                }\n            }\n        }, this.featureName, fetchEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$FETCH_BODY + 'start', function(args) {\n            if (state.currentNode) {\n                this[$c064faa4a9ed4ca3$var$SPA_NODE] = state.currentNode;\n                state.currentNode[$c064faa4a9ed4ca3$var$INTERACTION][$c064faa4a9ed4ca3$var$REMAINING]++;\n            }\n        }, this.featureName, fetchEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$FETCH_BODY + 'end', function(args, ctx, bodyPromise) {\n            var node = this[$c064faa4a9ed4ca3$var$SPA_NODE];\n            if (node) node[$c064faa4a9ed4ca3$var$INTERACTION][$c064faa4a9ed4ca3$var$REMAINING]--;\n        }, this.featureName, fetchEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$FETCH_DONE, function(err, res) {\n            var node = this[$c064faa4a9ed4ca3$var$SPA_NODE];\n            if (node) {\n                if (err || !(0, $9ZQLQ.shouldCollectEvent)(this.params)) {\n                    node.cancel();\n                    return;\n                }\n                var attrs = node.attrs;\n                attrs.params = this.params;\n                attrs.metrics = {\n                    txSize: this.txSize,\n                    rxSize: this.rxSize\n                };\n                attrs.isFetch = true;\n                node.finish(this[$c064faa4a9ed4ca3$var$FETCH_DONE]);\n            }\n        }, this.featureName, fetchEE);\n        (0, $4he1m.registerHandler)('newURL', function(url, hashChangedDuringCb) {\n            if (state.currentNode) state.currentNode[$c064faa4a9ed4ca3$var$INTERACTION].setNewURL(url);\n            else if (state.prevInteraction && !state.prevInteraction.ignored) {\n                /*\n         * The previous interaction was discarded before the route was changed. This can happen in SPA\n         * frameworks when using lazy loading. We have also seen this in version 11+ of Nextjs where\n         * some route changes re-use cached resolved promises.\n         */ const interaction = state.prevInteraction;\n                interaction.setNewURL(url);\n                interaction.root.end = null;\n                setCurrentNode(interaction.root);\n            }\n            if (state.currentNode) {\n                if (state.lastSeenUrl !== url) state.currentNode[$c064faa4a9ed4ca3$var$INTERACTION].routeChange = true;\n                if (hashChangedDuringCb) state.nodeOnLastHashUpdate = state.currentNode;\n            }\n            state.lastSeenUrl = url;\n        }, this.featureName, historyEE);\n        /**\n     * SCRIPTS\n     *   This is only needed to keep the interaction open while external scripts are being loaded.\n     *   The script that is loaded could continue the interaction by making additional AJAX\n     *   calls or changing the URL. The interaction context (currentNode) needs to be\n     *   restored somehow, but this differs based on the specific customer code. In some cases, we\n     *   could wrap a JSONP callback, in other cases we could wrap a higher-level API, and in\n     *   some cases we may not be able to restore context automatically (customer would need\n     *   to instrument their code manually).\n     *\n     * - We do not restore the original context in the load/error callbacks. This would not\n     *   work for the scripts themselves because by the time the load event fires, the\n     *   script content has already been executed.\n     */ // dom-start is emitted when appendChild or replaceChild are called. If the element being\n        // inserted is script and we are inside an interaction, we will keep the interaction open\n        // until the script is loaded.\n        jsonpEE.on('dom-start', function(args) {\n            if (!state.currentNode) return;\n            var el = args[0];\n            var isScript = el && el.nodeName === 'SCRIPT' && el.src !== '';\n            var interaction = state.currentNode.interaction;\n            if (isScript) {\n                // increase remaining count to keep the interaction open\n                interaction[$c064faa4a9ed4ca3$var$REMAINING]++;\n                el.addEventListener('load', onload, (0, $8FJov.eventListenerOpts)(false));\n                el.addEventListener('error', onerror, (0, $8FJov.eventListenerOpts)(false));\n            }\n            function onload() {\n                // decrease remaining to allow interaction to finish\n                interaction[$c064faa4a9ed4ca3$var$REMAINING]--;\n                // checkFinish is what initiates closing interaction, but is only called\n                // when setCurrentNode is called. Since we are not restoring a node here,\n                // we need to initiate the check manually.\n                // The reason we are not restoring the node here is because 1) this is not\n                // where the code of the external script runs (by the time the load event\n                // fires, it has already executed), and 2) it would require storing the context\n                // probably on the DOM node and restoring in all callbacks, which is a different\n                // use case than lazy loading.\n                interaction.checkFinish();\n            }\n            function onerror() {\n                interaction[$c064faa4a9ed4ca3$var$REMAINING]--;\n                interaction.checkFinish();\n            }\n        });\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$FN_START, function() {\n            setCurrentNode(state.prevNode);\n        }, this.featureName, mutationEE);\n        (0, $4he1m.registerHandler)('resolve-start', resolvePromise, this.featureName, promiseEE);\n        (0, $4he1m.registerHandler)('executor-err', resolvePromise, this.featureName, promiseEE);\n        (0, $4he1m.registerHandler)('propagate', saveNode, this.featureName, promiseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$CB_START, function() {\n            var ctx = this.getCtx ? this.getCtx() : this;\n            setCurrentNode(ctx[$c064faa4a9ed4ca3$var$SPA_NODE]);\n        }, this.featureName, promiseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$INTERACTION_API + 'get', function(t) {\n            var interaction;\n            if (state?.currentNode?.[$c064faa4a9ed4ca3$var$INTERACTION]) interaction = this.ixn = state.currentNode[$c064faa4a9ed4ca3$var$INTERACTION];\n            else if (state?.prevNode?.end === null && state?.prevNode?.[$c064faa4a9ed4ca3$var$INTERACTION]?.root?.[$c064faa4a9ed4ca3$var$INTERACTION]?.eventName !== 'initialPageLoad') interaction = this.ixn = state.prevNode[$c064faa4a9ed4ca3$var$INTERACTION];\n            else interaction = this.ixn = new (0, $5ML72.Interaction)('api', t, state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentRef);\n            if (!state.currentNode) {\n                interaction.checkFinish();\n                if (state.depth) setCurrentNode(interaction.root);\n            }\n        }, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$INTERACTION_API + 'actionText', function(t, actionText) {\n            var customAttrs = this.ixn.root.attrs.custom;\n            if (actionText) customAttrs.actionText = actionText;\n        }, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$INTERACTION_API + 'setName', function(t, name, trigger) {\n            var attrs = this.ixn.root.attrs;\n            if (name) attrs.customName = name;\n            if (trigger) attrs.trigger = trigger;\n        }, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$INTERACTION_API + 'setAttribute', function(t, name, value) {\n            this.ixn.root.attrs.custom[name] = value;\n        }, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$INTERACTION_API + 'end', function(timestamp) {\n            var interaction = this.ixn;\n            var node = activeNodeFor(interaction);\n            setCurrentNode(null);\n            node.child('customEnd', timestamp)?.finish(timestamp);\n            interaction.finish();\n        }, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$INTERACTION_API + 'ignore', function(t) {\n            this.ixn.ignored = true;\n        }, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$INTERACTION_API + 'save', function(t) {\n            this.ixn.save = true;\n        }, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$INTERACTION_API + 'tracer', function(timestamp, name, store) {\n            var interaction = this.ixn;\n            var parent = activeNodeFor(interaction);\n            var ctx = baseEE.context(store);\n            if (!name) {\n                ctx.inc = ++interaction[$c064faa4a9ed4ca3$var$REMAINING];\n                return ctx[$c064faa4a9ed4ca3$var$SPA_NODE] = parent;\n            }\n            ctx[$c064faa4a9ed4ca3$var$SPA_NODE] = parent.child('customTracer', timestamp, name);\n        }, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$FN_START, tracerDone, this.featureName, tracerEE);\n        (0, $4he1m.registerHandler)('no-' + $c064faa4a9ed4ca3$var$FN_START, tracerDone, this.featureName, tracerEE);\n        function tracerDone(timestamp, interactionContext, hasCb) {\n            var node = this[$c064faa4a9ed4ca3$var$SPA_NODE];\n            if (!node) return;\n            var interaction = node[$c064faa4a9ed4ca3$var$INTERACTION];\n            var inc = this.inc;\n            this.isTraced = true;\n            if (inc) interaction[$c064faa4a9ed4ca3$var$REMAINING]--;\n            else if (node) node.finish(timestamp);\n            hasCb ? setCurrentNode(node) : interaction.checkFinish();\n        }\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$INTERACTION_API + 'getContext', function(t, cb) {\n            var store = this.ixn.root.attrs.store;\n            setTimeout(function() {\n                cb(store);\n            }, 0);\n        }, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)($c064faa4a9ed4ca3$var$INTERACTION_API + 'onEnd', function(t, cb) {\n            this.ixn.handlers.push(cb);\n        }, this.featureName, baseEE);\n        (0, $4he1m.registerHandler)('api-routeName', function(t, currentRouteName) {\n            state.lastSeenRouteName = currentRouteName;\n            if (state.currentNode) state.currentNode[$c064faa4a9ed4ca3$var$INTERACTION].setNewRoute(currentRouteName);\n        }, this.featureName, baseEE);\n        function activeNodeFor(interaction) {\n            return state.currentNode && state.currentNode[$c064faa4a9ed4ca3$var$INTERACTION] === interaction ? state.currentNode : interaction.root;\n        }\n        function saveNode(val, overwrite) {\n            if (overwrite || !this[$c064faa4a9ed4ca3$var$SPA_NODE]) this[$c064faa4a9ed4ca3$var$SPA_NODE] = state.currentNode;\n        }\n        function resolvePromise() {\n            if (!this.resolved) {\n                this.resolved = true;\n                this[$c064faa4a9ed4ca3$var$SPA_NODE] = state.currentNode;\n            }\n        }\n        function getCurrentNode() {\n            return state.currentNode;\n        }\n        function setCurrentNode(newNode) {\n            if (!state.pageLoaded && !newNode && state.initialPageLoad) newNode = state.initialPageLoad.root;\n            if (state.currentNode) state.currentNode[$c064faa4a9ed4ca3$var$INTERACTION].checkFinish();\n            state.prevNode = state.currentNode;\n            state.currentNode = newNode && !newNode[$c064faa4a9ed4ca3$var$INTERACTION].root.end ? newNode : null;\n        }\n        function onInteractionFinished(interaction) {\n            if (interaction === state.initialPageLoad) state.initialPageLoad = null;\n            var root = interaction.root;\n            var attrs = root.attrs;\n            // make sure that newrelic[INTERACTION]() works in end handler\n            state.currentNode = root;\n            Object.values(interaction.handlers || {}).forEach(function(cb) {\n                cb(attrs.store);\n            });\n            setCurrentNode(null);\n        }\n        baseEE.on('spa-jserror', function(type, name, params, metrics) {\n            if (!state.currentNode) return;\n            params._interactionId = state.currentNode.interaction.id;\n            // do not capture parentNodeId when in root node\n            if (state.currentNode.type && state.currentNode.type !== 'interaction') params._interactionNodeId = state.currentNode.id;\n        });\n        (0, $4he1m.registerHandler)('function-err', function(args, obj, error) {\n            if (!state.currentNode) return;\n            error.__newrelic ??= {};\n            error.__newrelic[agentRef.agentIdentifier] = {\n                interactionId: state.currentNode.interaction.id\n            };\n            if (state.currentNode.type && state.currentNode.type !== 'interaction') error.__newrelic[agentRef.agentIdentifier].interactionNodeId = state.currentNode.id;\n        }, this.featureName, baseEE);\n        baseEE.on('interaction', saveInteraction);\n        function getActionText(node) {\n            var nodeType = node.tagName.toLowerCase();\n            var goodNodeTypes = [\n                'a',\n                'button',\n                'input'\n            ];\n            var isGoodNode = goodNodeTypes.indexOf(nodeType) !== -1;\n            if (isGoodNode) return node.title || node.value || node.innerText;\n        }\n        function saveInteraction(interaction) {\n            if (interaction.ignored || !interaction.save && !interaction.routeChange) {\n                baseEE.emit('interactionDone', [\n                    interaction,\n                    false\n                ]);\n                return;\n            }\n            if (state.prevInteraction === interaction) // If the interaction is being saved, remove it from prevInteraction variable\n            // to prevent the interaction from possibly being sent twice or causing an internal\n            // recursive loop issue.\n            state.prevInteraction = null;\n            // assign unique id, this is serialized and used to link interactions with errors\n            interaction.root.attrs.id = (0, $6sT7C.generateUuid)();\n            if (interaction.root.attrs.trigger === 'initialPageLoad') {\n                interaction.root.attrs.firstPaint = (0, $gDw2s.firstPaint).current.value;\n                interaction.root.attrs.firstContentfulPaint = (0, $ifld8.firstContentfulPaint).current.value;\n            }\n            baseEE.emit('interactionDone', [\n                interaction,\n                true\n            ]);\n            classThis.events.add(interaction);\n            let smCategory;\n            if (interaction.root?.attrs?.trigger === 'initialPageLoad') smCategory = 'InitialPageLoad';\n            else if (interaction.routeChange) smCategory = 'RouteChange';\n            else smCategory = 'Custom';\n            (0, $gy0pT.handle)((0, $bu0p3.SUPPORTABILITY_METRIC_CHANNEL), [\n                \"Spa/Interaction/\".concat(smCategory, \"/Duration/Ms\"),\n                Math.max((interaction.root?.end || 0) - (interaction.root?.start || 0), 0)\n            ], undefined, (0, $3R40a.FEATURE_NAMES).metrics, baseEE);\n            if (!harvester) {\n                (0, $jkuUu.warn)(19);\n                return;\n            }\n            harvester.triggerHarvestFor(classThis);\n        }\n    }\n    serializer(eventBuffer) {\n        return this.spaSerializerClass.serializeMultiple(eventBuffer, 0, (0, $8aXHb.navTimingValues));\n    }\n}\n\n});\nparcelRegister(\"8aXHb\", function(module, exports) {\n\n$parcel$export(module.exports, \"navTimingValues\", function () { return $5f3d902af6b1b508$export$2f44a866b65eb89b; });\n$parcel$export(module.exports, \"addPT\", function () { return $5f3d902af6b1b508$export$4eecd77d9102a9b2; });\n$parcel$export(module.exports, \"addPN\", function () { return $5f3d902af6b1b508$export$a47612ea3c40772d; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ // We don't use JSON.stringify directly on the performance timing data for these reasons:\n// * Chrome has extra data in the performance object that we don't want to send all the time (wasteful)\n// * Firefox fails to stringify the native object due to - http://code.google.com/p/v8/issues/detail?id=1223\n// * The variable names are long and wasteful to transmit\n// Add Performance Timing values to the given object.\n// * Values are written relative to an offset to reduce their length (i.e. number of characters).\n// * The offset is sent with the data\n// * 0's are not included unless the value is a 'relative zero'\n//\nvar $5f3d902af6b1b508$var$START = 'Start';\nvar $5f3d902af6b1b508$var$END = 'End';\nvar $5f3d902af6b1b508$var$UNLOAD_EVENT = 'unloadEvent';\nvar $5f3d902af6b1b508$var$REDIRECT = 'redirect';\nvar $5f3d902af6b1b508$var$DOMAIN_LOOKUP = 'domainLookup';\nvar $5f3d902af6b1b508$var$ONNECT = 'onnect';\nvar $5f3d902af6b1b508$var$REQUEST = 'request';\nvar $5f3d902af6b1b508$var$RESPONSE = 'response';\nvar $5f3d902af6b1b508$var$LOAD_EVENT = 'loadEvent';\nvar $5f3d902af6b1b508$var$DOM_CONTENT_LOAD_EVENT = 'domContentLoadedEvent';\nconst $5f3d902af6b1b508$export$2f44a866b65eb89b = [];\nfunction $5f3d902af6b1b508$var$getPntType(type) {\n    if (typeof type === 'number') return type;\n    const types = {\n        navigate: undefined,\n        reload: 1,\n        back_forward: 2,\n        prerender: 3\n    };\n    return types[type];\n}\nfunction $5f3d902af6b1b508$export$4eecd77d9102a9b2(offset, pt, v = {}, isL1Api = false) {\n    if (!pt) return;\n    v.of = offset;\n    $5f3d902af6b1b508$var$handleValue(v.of, v, 'n', true);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$UNLOAD_EVENT + $5f3d902af6b1b508$var$START], v, 'u', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$REDIRECT + $5f3d902af6b1b508$var$START], v, 'r', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$UNLOAD_EVENT + $5f3d902af6b1b508$var$END], v, 'ue', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$REDIRECT + $5f3d902af6b1b508$var$END], v, 're', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt['fetch' + $5f3d902af6b1b508$var$START], v, 'f', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$DOMAIN_LOOKUP + $5f3d902af6b1b508$var$START], v, 'dn', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$DOMAIN_LOOKUP + $5f3d902af6b1b508$var$END], v, 'dne', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt['c' + $5f3d902af6b1b508$var$ONNECT + $5f3d902af6b1b508$var$START], v, 'c', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt['secureC' + $5f3d902af6b1b508$var$ONNECT + 'ion' + $5f3d902af6b1b508$var$START], v, 's', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt['c' + $5f3d902af6b1b508$var$ONNECT + $5f3d902af6b1b508$var$END], v, 'ce', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$REQUEST + $5f3d902af6b1b508$var$START], v, 'rq', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$RESPONSE + $5f3d902af6b1b508$var$START], v, 'rp', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$RESPONSE + $5f3d902af6b1b508$var$END], v, 'rpe', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt.domLoading, v, 'dl', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt.domInteractive, v, 'di', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$DOM_CONTENT_LOAD_EVENT + $5f3d902af6b1b508$var$START], v, 'ds', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$DOM_CONTENT_LOAD_EVENT + $5f3d902af6b1b508$var$END], v, 'de', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt.domComplete, v, 'dc', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$LOAD_EVENT + $5f3d902af6b1b508$var$START], v, 'l', isL1Api);\n    $5f3d902af6b1b508$var$handleValue(pt[$5f3d902af6b1b508$var$LOAD_EVENT + $5f3d902af6b1b508$var$END], v, 'le', isL1Api);\n    return v;\n}\nfunction $5f3d902af6b1b508$export$a47612ea3c40772d(pn, v) {\n    $5f3d902af6b1b508$var$handleValue($5f3d902af6b1b508$var$getPntType(pn.type), v, 'ty');\n    $5f3d902af6b1b508$var$handleValue(pn.redirectCount, v, 'rc');\n    return v;\n}\n/**\n * By side effect, this modifies 'obj' with a mapping of the 'prop' provided to a 'value', and invalid values are not added.\n * On the other hand, the local navTimingValues array gets the value appended if valid and 'undefined' appended if invalid, regardless.\n */ function $5f3d902af6b1b508$var$handleValue(value, obj, prop, isOldApi) {\n    /*\n  For L2 Timing API, the value will already be a relative-to-previous-document DOMHighResTimeStamp.\n  For L1 (deprecated) Timing, the value is an UNIX epoch timestamp, which we will convert to a relative time using our offset.\n  PNT.type is reported as undefined, 1, 2, etc -- note that zero-value properties will be recorded as 'undefined', however DEM interprets undefined \"types\" as \"navigate\"\n  */ if (typeof value === 'number' && value > 0) {\n        // note that zero-value properties will be recorded as 'undefined'\n        if (isOldApi) {\n            const offset = obj?.of > 0 ? obj.of : 0; // expect an epoch timestamp, if called by addPT\n            value = Math.max(value - offset, 0);\n        }\n        value = Math.round(value);\n        obj[prop] = value;\n        $5f3d902af6b1b508$export$2f44a866b65eb89b.push(value);\n    } else $5f3d902af6b1b508$export$2f44a866b65eb89b.push(undefined);\n}\n\n});\n\nparcelRegister(\"5ML72\", function(module, exports) {\n\n$parcel$export(module.exports, \"Interaction\", function () { return $4365fb078d1679da$export$a13296960cae0384; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $9EKMI = parcelRequire(\"9EKMI\");\n\nvar $juL0p = parcelRequire(\"juL0p\");\n\nvar $QoKOJ = parcelRequire(\"QoKOJ\");\nvar $4365fb078d1679da$var$originalSetTimeout = (0, $juL0p.gosNREUMOriginals)().o.ST;\nvar $4365fb078d1679da$var$originalClearTimeout = (0, $juL0p.gosNREUMOriginals)().o.CT;\nvar $4365fb078d1679da$var$lastId = {};\nfunction $4365fb078d1679da$export$a13296960cae0384(eventName, timestamp, url, routeName, onFinished, agentRef) {\n    this.agentRef = agentRef;\n    $4365fb078d1679da$var$lastId[agentRef.agentIdentifier] = 0;\n    this.id = ++$4365fb078d1679da$var$lastId[agentRef.agentIdentifier];\n    this.eventName = eventName;\n    this.nodes = 0;\n    this.remaining = 0;\n    this.finishTimer = null;\n    this.checkingFinish = false;\n    this.lastCb = this.lastFinish = timestamp;\n    this.handlers = [];\n    this.onFinished = onFinished;\n    this.done = false;\n    var root = this.root = new (0, $QoKOJ.InteractionNode)(this, null, 'interaction', timestamp);\n    var attrs = root.attrs;\n    attrs.trigger = eventName;\n    attrs.initialPageURL = (0, $9EKMI.initialLocation);\n    attrs.oldRoute = routeName;\n    attrs.newURL = attrs.oldURL = url;\n    attrs.custom = {};\n    attrs.store = {};\n}\nvar $4365fb078d1679da$var$InteractionPrototype = $4365fb078d1679da$export$a13296960cae0384.prototype;\n$4365fb078d1679da$var$InteractionPrototype.checkFinish = function checkFinish() {\n    var interaction = this;\n    if (interaction.remaining > 0) {\n        interaction._resetFinishCheck();\n        return;\n    }\n    if (interaction.checkingFinish) return;\n    if (interaction.root.end !== null) return;\n    interaction._resetFinishCheck();\n    interaction.checkingFinish = true;\n    interaction.finishTimer = $4365fb078d1679da$var$originalSetTimeout(()=>{\n        interaction.checkingFinish = false;\n        interaction.finishTimer = $4365fb078d1679da$var$originalSetTimeout(()=>{\n            interaction.finishTimer = null;\n            if (interaction.remaining <= 0) interaction.finish();\n        }, 1);\n    }, 0);\n};\n$4365fb078d1679da$var$InteractionPrototype.setNewURL = function setNewURL(url) {\n    this.root.attrs.newURL = url;\n};\n$4365fb078d1679da$var$InteractionPrototype.setNewRoute = function setNewRoute(route) {\n    this.root.attrs.newRoute = route;\n};\n$4365fb078d1679da$var$InteractionPrototype.onNodeAdded = function onNodeAdded() {\n    this._resetFinishCheck();\n};\n$4365fb078d1679da$var$InteractionPrototype._resetFinishCheck = function _resetFinishCheck() {\n    if (this.finishTimer) {\n        $4365fb078d1679da$var$originalClearTimeout(this.finishTimer);\n        this.finishTimer = null;\n        this.checkingFinish = false;\n    }\n};\n// serialize report and remove nodes from map\n$4365fb078d1679da$var$InteractionPrototype.finish = function finishInteraction() {\n    var interaction = this;\n    var root = interaction.root;\n    if (root.end !== null) return;\n    var endTimestamp = Math.max(interaction.lastCb, interaction.lastFinish);\n    var attrs = root.attrs;\n    var customAttrs = attrs.custom;\n    if (this.onFinished) this.onFinished(this);\n    Object.entries(interaction.agentRef.info.jsAttributes || {}).forEach(([attr, value])=>{\n        if (!(attr in customAttrs)) customAttrs[attr] = value;\n    });\n    root.end = endTimestamp;\n    interaction.agentRef.ee.emit('interaction', [\n        this\n    ]);\n};\n\n});\nparcelRegister(\"QoKOJ\", function(module, exports) {\n\n$parcel$export(module.exports, \"InteractionNode\", function () { return $09d80f185bfd9b94$export$b0f4aa4abbc3e49a; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ var $09d80f185bfd9b94$var$MAX_NODES = 128;\nvar $09d80f185bfd9b94$var$lastId = 0;\nfunction $09d80f185bfd9b94$export$b0f4aa4abbc3e49a(interaction, parent, type, timestamp) {\n    Object.defineProperty(this, 'interaction', {\n        value: interaction,\n        writable: true // enumerable: false -- by default, which hides this prop from obj (iterations)\n    });\n    this.parent = parent;\n    this.id = ++$09d80f185bfd9b94$var$lastId;\n    this.type = type;\n    this.children = [];\n    this.end = null;\n    this.jsEnd = this.start = timestamp;\n    this.jsTime = 0;\n    this.attrs = {};\n    this.cancelled = false;\n}\nvar $09d80f185bfd9b94$var$InteractionNodePrototype = $09d80f185bfd9b94$export$b0f4aa4abbc3e49a.prototype;\n/**\n * @param {string} type\n * @param {number} timestamp\n * @param {string} name\n * @param {bool} dontWait - When true, the interaction will not immediately start waiting\n *                          for this node to complete. This is used when the creation of\n *                          the node and its start happen at different times (e.g. XHR).\n */ $09d80f185bfd9b94$var$InteractionNodePrototype.child = function child(type, timestamp, name, dontWait) {\n    var interaction = this.interaction;\n    if (interaction.end || interaction.nodes >= $09d80f185bfd9b94$var$MAX_NODES) return null;\n    interaction.onNodeAdded(this);\n    var node = new $09d80f185bfd9b94$export$b0f4aa4abbc3e49a(interaction, this, type, timestamp);\n    node.attrs.name = name;\n    interaction.nodes++;\n    if (!dontWait) interaction.remaining++;\n    return node;\n};\n$09d80f185bfd9b94$var$InteractionNodePrototype.callback = function addCallbackTime(exclusiveTime, end) {\n    var node = this;\n    node.jsTime += exclusiveTime;\n    if (end > node.jsEnd) {\n        node.jsEnd = end;\n        node.interaction.lastCb = end;\n    }\n};\n$09d80f185bfd9b94$var$InteractionNodePrototype.cancel = function cancel() {\n    this.cancelled = true;\n    var interaction = this.interaction;\n    interaction.remaining--;\n};\n$09d80f185bfd9b94$var$InteractionNodePrototype.finish = function finish(timestamp) {\n    var node = this;\n    if (node.end) return;\n    node.end = timestamp;\n    // Find the next parent node that is not cancelled\n    let parent = node.parent;\n    while(parent?.cancelled)parent = parent.parent;\n    // Assign the node to the non-cancelled parent node\n    if (parent) parent.children.push(node);\n    node.parent = null;\n    // Update the interaction remaining counter\n    var interaction = this.interaction;\n    interaction.remaining--;\n    interaction.lastFinish = timestamp;\n    // check if interaction has finished, (this is needed for older browsers for unknown reasons)\n    interaction.checkFinish();\n};\n\n});\n\n\nparcelRegister(\"fPO2Q\", function(module, exports) {\n\n$parcel$export(module.exports, \"Serializer\", function () { return $b872705412ca5d32$export$ef852775387a0be7; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $jWywI = parcelRequire(\"jWywI\");\n\nvar $ewyxt = parcelRequire(\"ewyxt\");\nclass $b872705412ca5d32$export$ef852775387a0be7 {\n    constructor(agentRef){\n        this.obfuscator = agentRef.runtime.obfuscator;\n        this.info = agentRef.info;\n        /**\n     * This variable is used to calculate an interactions ending offset when the\n     * harvest includes multiple interactions. This variable is set by the first\n     * interaction processed and used by subsequent interactions in the same harvest.\n     * See https://issues.newrelic.com/browse/NEWRELIC-5498\n     * @type {number|undefined}\n     */ this.firstTimestamp = undefined;\n    }\n    serializeMultiple(interactions, offset, navTiming) {\n        var addString = (0, $ewyxt.getAddStringContext)(this.obfuscator);\n        var serialized = 'bel.7';\n        interactions.forEach((interaction)=>{\n            serialized += ';' + this.serializeInteraction(interaction.root, offset, navTiming, interaction.routeChange, addString, this.info);\n        });\n        this.firstTimestamp = undefined;\n        return serialized;\n    }\n    serializeSingle(root, offset, navTiming, isRouteChange) {\n        var addString = (0, $ewyxt.getAddStringContext)(this.obfuscator);\n        var serialized = 'bel.7;' + this.serializeInteraction(root, offset, navTiming, isRouteChange, addString, this.info);\n        this.firstTimestamp = undefined;\n        return serialized;\n    }\n    serializeInteraction(root, offset, navTiming, isRouteChange, addString, info) {\n        offset = offset || 0;\n        var isInitialPage = root.attrs.trigger === 'initialPageLoad';\n        var typeIdsByName = {\n            interaction: 1,\n            ajax: 2,\n            customTracer: 4\n        };\n        // Include the hash fragment with all SPA data\n        var includeHashFragment = true;\n        const addNode = (node, nodeList)=>{\n            if (node.type === 'customEnd') return nodeList.push([\n                3,\n                (0, $ewyxt.numeric)(node.end - this.firstTimestamp)\n            ]);\n            var typeName = node.type;\n            var typeId = typeIdsByName[typeName];\n            var startTimestamp = node.start;\n            var childCount = node.children.length;\n            var attrCount = 0;\n            var apmAttributes = info.atts;\n            var hasNavTiming = isInitialPage && navTiming.length && typeId === 1;\n            var children = [];\n            var attrs = node.attrs;\n            var metrics = attrs.metrics;\n            var params = attrs.params;\n            var queueTime = info.queueTime;\n            var appTime = info.applicationTime;\n            if (typeof this.firstTimestamp === 'undefined') {\n                startTimestamp += offset;\n                this.firstTimestamp = startTimestamp;\n            } else startTimestamp -= this.firstTimestamp;\n            var fields = [\n                (0, $ewyxt.numeric)(startTimestamp),\n                (0, $ewyxt.numeric)(node.end - node.start),\n                (0, $ewyxt.numeric)(node.jsEnd - node.end),\n                (0, $ewyxt.numeric)(node.jsTime)\n            ];\n            switch(typeId){\n                case 1:\n                    fields[2] = (0, $ewyxt.numeric)(node.jsEnd - this.firstTimestamp);\n                    fields.push(addString(attrs.trigger), addString((0, $jWywI.cleanURL)(attrs.initialPageURL, includeHashFragment)), addString((0, $jWywI.cleanURL)(attrs.oldURL, includeHashFragment)), addString((0, $jWywI.cleanURL)(attrs.newURL, includeHashFragment)), addString(attrs.customName), isInitialPage ? '' : isRouteChange ? 1 : 2, (0, $ewyxt.nullable)(isInitialPage && queueTime, (0, $ewyxt.numeric), true) + (0, $ewyxt.nullable)(isInitialPage && appTime, (0, $ewyxt.numeric), true) + (0, $ewyxt.nullable)(attrs.oldRoute, addString, true) + (0, $ewyxt.nullable)(attrs.newRoute, addString, true) + addString(attrs.id), addString(node.id), (0, $ewyxt.nullable)(attrs.firstPaint, (0, $ewyxt.numeric), true) + (0, $ewyxt.nullable)(attrs.firstContentfulPaint, (0, $ewyxt.numeric), false));\n                    var attrParts = (0, $ewyxt.addCustomAttributes)(attrs.custom, addString);\n                    children = children.concat(attrParts);\n                    attrCount = attrParts.length;\n                    if (apmAttributes) {\n                        childCount++;\n                        children.push('a,' + addString(apmAttributes));\n                    }\n                    break;\n                case 2:\n                    fields.push(addString(params.method), (0, $ewyxt.numeric)(params.status), addString(params.host), addString(params.pathname), (0, $ewyxt.numeric)(metrics.txSize), (0, $ewyxt.numeric)(metrics.rxSize), attrs.isFetch ? 1 : attrs.isJSONP ? 2 : '', addString(node.id), (0, $ewyxt.nullable)(node.dt && node.dt.spanId, addString, true) + (0, $ewyxt.nullable)(node.dt && node.dt.traceId, addString, true) + (0, $ewyxt.nullable)(node.dt && node.dt.timestamp, (0, $ewyxt.numeric), false));\n                    // add params.gql here\n                    if (Object.keys(params?.gql || {}).length) {\n                        var ajaxAttrParts = (0, $ewyxt.addCustomAttributes)(params.gql, addString);\n                        children = children.concat(ajaxAttrParts);\n                        attrCount = ajaxAttrParts.length;\n                    }\n                    break;\n                case 4:\n                    var tracedTime = attrs.tracedTime;\n                    fields.push(addString(attrs.name), (0, $ewyxt.nullable)(tracedTime, (0, $ewyxt.numeric), true) + addString(node.id));\n                    break;\n            }\n            for(var i = 0; i < node.children.length; i++)addNode(node.children[i], children);\n            fields.unshift((0, $ewyxt.numeric)(typeId), (0, $ewyxt.numeric)(childCount += attrCount));\n            nodeList.push(fields);\n            if (childCount) nodeList.push(children.join(';'));\n            if (hasNavTiming) {\n                // this build up the navTiming node\n                // it for each navTiming value (pre aggregated in nav-timing.js):\n                // we initialize the seperator to ',' (seperates the nodeType id from the first value)\n                // we initialize the navTiming node to 'b' (the nodeType id)\n                // if the value is present:\n                //   we add the seperator followed by the value\n                // otherwise\n                //   we add null seperator ('!') to the navTimingNode\n                //   we set the seperator to an empty string since we already wrote it above\n                //   the reason for writing the null seperator instead of setting the seperator\n                //   is to ensure we still write it if the null is the last navTiming value.\n                var seperator = ',';\n                var navTimingNode = 'b';\n                var prev = 0;\n                // get all navTiming values except navigationStart\n                // (since its the same as interaction.start)\n                // and limit to just the first 20 values we know about\n                Object.values(navTiming.slice(1, 21) || {}).forEach((v)=>{\n                    if (v !== undefined) {\n                        navTimingNode += seperator + (0, $ewyxt.numeric)(v - prev);\n                        seperator = ',';\n                        prev = v;\n                    } else {\n                        navTimingNode += seperator + '!';\n                        seperator = '';\n                    }\n                });\n                nodeList.push(navTimingNode);\n            } else if (typeId === 1) nodeList.push('');\n            return nodeList;\n        };\n        return addNode(root, []).join(';');\n    }\n}\n\n});\nparcelRegister(\"ewyxt\", function(module, exports) {\n\n$parcel$export(module.exports, \"nullable\", function () { return $a92ed88948900b2c$export$133fc36489ac9add; });\n$parcel$export(module.exports, \"numeric\", function () { return $a92ed88948900b2c$export$b7a508fa8dae59fc; });\n$parcel$export(module.exports, \"getAddStringContext\", function () { return $a92ed88948900b2c$export$71f03e17b83cbe02; });\n$parcel$export(module.exports, \"addCustomAttributes\", function () { return $a92ed88948900b2c$export$b7f14f78b59de5aa; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $8KO5M = parcelRequire(\"8KO5M\");\nvar $a92ed88948900b2c$var$hasOwnProp = Object.prototype.hasOwnProperty;\nvar $a92ed88948900b2c$var$MAX_ATTRIBUTES = 64;\nfunction $a92ed88948900b2c$export$133fc36489ac9add(val, fn, comma) {\n    return val || val === 0 || val === '' ? fn(val) + (comma ? ',' : '') : '!';\n}\nfunction $a92ed88948900b2c$export$b7a508fa8dae59fc(n, noDefault) {\n    if (noDefault) return Math.floor(n).toString(36);\n    return n === undefined || n === 0 ? '' : Math.floor(n).toString(36);\n}\nfunction $a92ed88948900b2c$export$71f03e17b83cbe02(obfuscator) {\n    let stringTableIdx = 0;\n    const stringTable = Object.prototype.hasOwnProperty.call(Object, 'create') ? Object.create(null) : {};\n    return addString;\n    function addString(str) {\n        if (typeof str === 'undefined' || str === '') return '';\n        str = obfuscator.obfuscateString(String(str));\n        if ($a92ed88948900b2c$var$hasOwnProp.call(stringTable, str)) return $a92ed88948900b2c$export$b7a508fa8dae59fc(stringTable[str], true);\n        else {\n            stringTable[str] = stringTableIdx++;\n            return $a92ed88948900b2c$var$quoteString(str);\n        }\n    }\n}\nfunction $a92ed88948900b2c$export$b7f14f78b59de5aa(attrs, addString) {\n    var attrParts = [];\n    Object.entries(attrs || {}).forEach(([key, val])=>{\n        if (attrParts.length >= $a92ed88948900b2c$var$MAX_ATTRIBUTES) return;\n        var type = 5;\n        var serializedValue;\n        // add key to string table first\n        key = addString(key);\n        switch(typeof val){\n            case 'object':\n                if (val) // serialize objects to strings\n                serializedValue = addString((0, $8KO5M.stringify)(val));\n                else // null attribute type\n                type = 9;\n                break;\n            case 'number':\n                type = 6;\n                // make sure numbers contain a `.` so they are parsed as doubles\n                serializedValue = val % 1 ? val : val + '.';\n                break;\n            case 'boolean':\n                type = val ? 7 : 8;\n                break;\n            case 'undefined':\n                // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n                type = 9;\n                break;\n            default:\n                serializedValue = addString(val);\n        }\n        attrParts.push([\n            type,\n            key + (serializedValue ? ',' + serializedValue : '')\n        ]);\n    });\n    return attrParts;\n}\nvar $a92ed88948900b2c$var$escapable = /([,\\\\;])/g;\nfunction $a92ed88948900b2c$var$quoteString(str) {\n    return \"'\" + str.replace($a92ed88948900b2c$var$escapable, '\\\\$1');\n}\n\n});\n\n\n\n\n//# sourceMappingURL=aggregate.cf74affc.js.map\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n/* eslint no-undef: \"error\" */\nimport { registerHandler as register } from '../../../common/event-emitter/register-handler';\nimport { parseUrl } from '../../../common/url/parse-url';\nimport { shouldCollectEvent } from '../../../common/deny-list/deny-list';\nimport { navTimingValues as navTiming } from '../../../common/timing/nav-timing';\nimport { generateUuid } from '../../../common/ids/unique-id';\nimport { Interaction } from './interaction';\nimport { eventListenerOpts } from '../../../common/event-listener/event-listener-opts';\nimport { Serializer } from './serializer';\nimport { ee } from '../../../common/event-emitter/contextual-ee';\nimport * as CONSTANTS from '../constants';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { firstContentfulPaint } from '../../../common/vitals/first-contentful-paint';\nimport { firstPaint } from '../../../common/vitals/first-paint';\nimport { bundleId } from '../../../common/ids/bundle-id';\nimport { initialLocation, loadedAsDeferredBrowserScript } from '../../../common/constants/runtime';\nimport { handle } from '../../../common/event-emitter/handle';\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../metrics/constants';\nimport { warn } from '../../../common/util/console';\nconst {\n  FEATURE_NAME,\n  INTERACTION_EVENTS,\n  MAX_TIMER_BUDGET,\n  FN_START,\n  FN_END,\n  CB_START,\n  INTERACTION_API,\n  REMAINING,\n  INTERACTION,\n  SPA_NODE,\n  JSONP_NODE,\n  FETCH_START,\n  FETCH_DONE,\n  FETCH_BODY,\n  JSONP_END,\n  originalSetTimeout\n} = CONSTANTS;\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentRef) {\n    super(agentRef, FEATURE_NAME);\n    const state = this.state = {\n      initialPageURL: initialLocation,\n      lastSeenUrl: initialLocation,\n      lastSeenRouteName: null,\n      timerMap: {},\n      timerBudget: MAX_TIMER_BUDGET,\n      currentNode: null,\n      prevNode: null,\n      nodeOnLastHashUpdate: null,\n      initialPageLoad: null,\n      pageLoaded: false,\n      childTime: 0,\n      depth: 0,\n      // The below feature flag is used to disable the SPA ajax fix for specific customers, see https://new-relic.atlassian.net/browse/NR-172169\n      disableSpaFix: (agentRef.init.feature_flags || []).indexOf('disable-spa-fix') > -1\n    };\n    this.spaSerializerClass = new Serializer(agentRef);\n    const classThis = this;\n    const baseEE = ee.get(agentRef.agentIdentifier); // <-- parent baseEE\n    const mutationEE = baseEE.get('mutation');\n    const promiseEE = baseEE.get('promise');\n    const historyEE = baseEE.get('history');\n    const eventsEE = baseEE.get('events'); // ajax --> ee(123).emit() ee()\n    const timerEE = baseEE.get('timer');\n    const fetchEE = baseEE.get('fetch');\n    const jsonpEE = baseEE.get('jsonp');\n    const xhrEE = baseEE.get('xhr');\n    const tracerEE = baseEE.get('tracer');\n\n    // childTime is used when calculating exclusive time for a cb duration.\n    //\n    // Exclusive time will be different than the total time for either callbacks\n    // which synchronously invoke a customTracer callback or, trigger a synchronous\n    // event (eg. onreadystate=1 or popstate).\n    //\n    // At fn-end, childTime will contain the total time of all timed callbacks and\n    // event handlers which executed as a child of the current callback. At the\n    // begining of every callback, childTime is saved to the event context (which at\n    // that time contains the sum of its preceeding siblings) and is reset to 0. The\n    // callback is then executed, and its children may increase childTime.  At the\n    // end of the callback, it reports its exclusive time as its\n    // execution time - exlcuded. childTime is then reset to its previous\n    // value, and the totalTime of the callback that just finished executing is\n    // added to the childTime time.\n    //                                    | clock | childTime | ctx.ct | totalTime | exclusive |\n    // click fn-start                     |   0   |    0     |    0   |           |           |\n    //  | click begining:                 |   5   |    0     |    0   |           |           |\n    //  |   | custom-1 fn-start           |   10  |    0     |    0   |           |           |\n    //  |   |   |  custom-1 begining      |   15  |    0     |    0   |           |           |\n    //  |   |   |    |  custom-2 fn-start |   20  |    0     |    0   |           |           |\n    //  |   |   |    |  | custom-2        |   25  |    0     |    0   |           |           |\n    //  |   |   |    |  custom-2 fn-end   |   30  |    10    |    0   |     10    |     10    |\n    //  |   |   |  custom-1 middle        |   35  |    10    |    0   |           |           |\n    //  |   |   |    |  custom-3 fn-start |   40  |    0     |    10  |           |           |\n    //  |   |   |    |  | custom-3        |   45  |    0     |    10  |           |           |\n    //  |   |   |    |  custom-3 fn-end   |   50  |    20    |    0   |     10    |     10    |\n    //  |   |   |  custom-1 ending        |   55  |    20    |    0   |           |           |\n    //  |     custom-1 fn-end             |   60  |    50    |    0   |     50    |     30    |\n    //  | click ending:                   |   65  |    50    |        |           |           |\n    // click fn-end                       |   70  |    0     |    0   |     70    |     20    |\n\n    let harvester;\n    this.waitForFlags(['spa']).then(([spaFlag]) => {\n      if (spaFlag) {\n        harvester = agentRef.runtime.harvester; // since this is after RUM call, PVE would've initialized harvester by now\n        this.drain();\n      } else {\n        this.blocked = true;\n        this.deregisterDrain();\n      }\n    });\n    if (agentRef.init.spa.enabled !== true) return;\n    state.initialPageLoad = new Interaction('initialPageLoad', 0, state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentRef);\n    state.initialPageLoad.save = true;\n    if (agentRef.runtime.session?.isNew) state.initialPageLoad.root.attrs.custom.isFirstOfSession = true; // mark the hard page load as first of its session\n    state.prevInteraction = state.initialPageLoad;\n    state.currentNode = state.initialPageLoad.root; // hint\n    // ensure that checkFinish calls are safe during initialPageLoad\n    state.initialPageLoad[REMAINING]++;\n    register(FN_START, callbackStart, this.featureName, baseEE);\n    register(CB_START, callbackStart, this.featureName, promiseEE);\n\n    // register plugins\n    var pluginApi = {\n      getCurrentNode,\n      setCurrentNode\n    };\n    register('spa-register', function (init) {\n      if (typeof init === 'function') {\n        init(pluginApi);\n      }\n    }, FEATURE_NAMES.spa, baseEE);\n    function callbackStart() {\n      state.depth++;\n      this.prevNode = state.currentNode;\n      this.ct = state.childTime;\n      state.childTime = 0;\n      state.timerBudget = MAX_TIMER_BUDGET;\n    }\n    register(FN_END, callbackEnd, this.featureName, baseEE);\n    register('cb-end', callbackEnd, this.featureName, promiseEE);\n    function callbackEnd() {\n      state.depth--;\n      var totalTime = this.jsTime || 0;\n      var exclusiveTime = totalTime - state.childTime;\n      state.childTime = this.ct + totalTime;\n      if (state.currentNode) {\n        // transfer accumulated callback time to the active interaction node\n        // run even if jsTime is 0 to update jsEnd\n        state.currentNode.callback(exclusiveTime, this[FN_END]);\n        if (this.isTraced) {\n          state.currentNode.attrs.tracedTime = exclusiveTime;\n        }\n      }\n      this.jsTime = state.currentNode ? 0 : exclusiveTime;\n      setCurrentNode(this.prevNode);\n      this.prevNode = null;\n      state.timerBudget = MAX_TIMER_BUDGET;\n    }\n    register(FN_START, function (args, eventSource) {\n      var ev = args[0];\n      var evName = ev.type;\n      var eventNode = ev[\"__nrNode:\".concat(bundleId)];\n      if (!state.pageLoaded && (evName === 'load' && eventSource === window || loadedAsDeferredBrowserScript)) {\n        state.pageLoaded = true;\n        // set to null so prevNode is set correctly\n        this.prevNode = state.currentNode = null;\n        if (state.initialPageLoad) {\n          eventNode = state.initialPageLoad.root;\n\n          // Even if initialPageLoad has remaining callbacks, force the initialPageLoad\n          // interaction to complete when the page load event occurs.\n          state.initialPageLoad[REMAINING] = 0;\n          originalSetTimeout(function () {\n            INTERACTION_EVENTS.push('popstate');\n          });\n        }\n      }\n      if (eventNode) {\n        // If we've already seen a previous handler for this specific event object,\n        // just restore that. We want multiple handlers for the same event to share\n        // a node.\n        setCurrentNode(eventNode);\n      } else if (evName === 'hashchange') {\n        setCurrentNode(state.nodeOnLastHashUpdate);\n        state.nodeOnLastHashUpdate = null;\n      } else if (eventSource instanceof XMLHttpRequest) {\n        // If this event was emitted by an XHR, restore the node ID associated with\n        // that XHR.\n        setCurrentNode(baseEE.context(eventSource).spaNode);\n      } else if (!state.currentNode && INTERACTION_EVENTS.indexOf(evName) !== -1) {\n        // Otherwise, if no interaction is currently active, create a new node ID,\n        // and let the aggregator know that we entered a new event handler callback\n        // so that it has a chance to possibly start an interaction.\n        var ixn = new Interaction(evName, this[FN_START], state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentRef);\n\n        // Store the interaction as prevInteraction in case it is prematurely discarded\n        state.prevInteraction = ixn;\n        setCurrentNode(ixn.root);\n        if (evName === 'click') {\n          var value = getActionText(ev.target);\n          if (value) {\n            state.currentNode.attrs.custom.actionText = value;\n          }\n        }\n      }\n      ev[\"__nrNode:\".concat(bundleId)] = state.currentNode;\n    }, this.featureName, eventsEE);\n\n    /**\n     * *** TIMERS ***\n     * setTimeout call needs to keep the interaction active in case a node is started\n     * in its callback.\n     */\n\n    // The context supplied to this callback will be shared with the fn-start/fn-end\n    // callbacks that fire around the callback passed to setTimeout originally.\n    register('setTimeout-end', function saveId(args, obj, timerId) {\n      if (!state.currentNode || state.timerBudget - this.timerDuration < 0) return;\n      if (args && !(args[0] instanceof Function)) return;\n      state.currentNode[INTERACTION][REMAINING]++;\n      this.timerId = timerId;\n      state.timerMap[timerId] = state.currentNode;\n      this.timerBudget = state.timerBudget - 50;\n    }, this.featureName, timerEE);\n    register('clearTimeout-start', function clear(args) {\n      var timerId = args[0];\n      var node = state.timerMap[timerId];\n      if (node) {\n        var interaction = node[INTERACTION];\n        interaction[REMAINING]--;\n        interaction.checkFinish();\n        delete state.timerMap[timerId];\n      }\n    }, this.featureName, timerEE);\n    register(FN_START, function () {\n      state.timerBudget = this.timerBudget || MAX_TIMER_BUDGET;\n      var id = this.timerId;\n      var node = state.timerMap[id];\n      setCurrentNode(node);\n      delete state.timerMap[id];\n      if (node) node[INTERACTION][REMAINING]--;\n    }, this.featureName, timerEE);\n\n    /**\n     * *** XHR ***\n     * - `new-xhr` event is fired when new instance of XHR is created. Here we create\n     *    a new node and store it on the XHR object.\n     * -  When the send method is called (`send-xhr-start` event), we tell the interaction\n     *    to wait for this XHR to complete.\n     * -  When any direct event handlers are invoked (`fn-start` on the `xhr` emitter),\n     *    we restore the node in case other child nodes are started here.\n     * -  Callbacks attached using `addEventListener` are handled using `fn-start` on the\n     *    `events` emitter.\n     * -  When `xhr-resolved` is emitted, we end the node. The node.finish() call also\n     *    instructs the interaction to stop waiting for this node.\n     */\n\n    // context is shared with new-xhr event, and is stored on the xhr iteself.\n    register(FN_START, function () {\n      setCurrentNode(this[SPA_NODE]);\n    }, this.featureName, xhrEE);\n\n    // context is stored on the xhr and is shared with all callbacks associated\n    // with the new xhr\n    register('new-xhr', function () {\n      if (!state.disableSpaFix && !state.currentNode && state.prevInteraction && !state.prevInteraction.ignored) {\n        /*\n         * The previous interaction was discarded before a route change. Restore the interaction\n         * in case this XHR is associated with a route change.\n         */\n        const interaction = state.prevInteraction;\n        state.currentNode = interaction.root;\n        interaction.root.end = null;\n      }\n      if (state.currentNode) {\n        this[SPA_NODE] = state.currentNode.child('ajax', null, null, true);\n      }\n    }, this.featureName, xhrEE);\n    register('send-xhr-start', function () {\n      var node = this[SPA_NODE];\n      if (node && !this.sent) {\n        this.sent = true;\n        node.dt = this.dt;\n        if (node.dt?.timestamp) {\n          node.dt.timestamp = agentRef.runtime.timeKeeper.correctAbsoluteTimestamp(node.dt.timestamp);\n        }\n        node.jsEnd = node.start = this.startTime;\n        node[INTERACTION][REMAINING]++;\n      }\n    }, this.featureName, xhrEE);\n    register('xhr-resolved', function () {\n      var node = this[SPA_NODE];\n      if (node) {\n        if (!shouldCollectEvent(this.params)) {\n          node.cancel();\n          return;\n        }\n        var attrs = node.attrs;\n        attrs.params = this.params;\n        attrs.metrics = this.metrics;\n        node.finish(this.endTime);\n        if (!!this.currentNode && !!this.currentNode.interaction) this.currentNode.interaction.checkFinish();\n      }\n    }, this.featureName, baseEE);\n\n    /**\n     * *** JSONP ***\n     *\n     */\n\n    register('new-jsonp', function (url) {\n      if (state.currentNode) {\n        var node = this[JSONP_NODE] = state.currentNode.child('ajax', this[FETCH_START]);\n        node.start = this['new-jsonp'];\n        this.url = url;\n        this.status = null;\n      }\n    }, this.featureName, jsonpEE);\n    register('cb-start', function (args) {\n      var node = this[JSONP_NODE];\n      if (node) {\n        setCurrentNode(node);\n        this.status = 200;\n      }\n    }, this.featureName, jsonpEE);\n    register('jsonp-error', function () {\n      var node = this[JSONP_NODE];\n      if (node) {\n        setCurrentNode(node);\n        this.status = 0;\n      }\n    }, this.featureName, jsonpEE);\n    register(JSONP_END, function () {\n      var node = this[JSONP_NODE];\n      if (node) {\n        // if no status is set then cb never fired - so it's not a valid JSONP\n        if (this.status === null) {\n          node.cancel();\n          return;\n        }\n        var attrs = node.attrs;\n        var params = attrs.params = {};\n        var parsed = parseUrl(this.url);\n        params.method = 'GET';\n        params.pathname = parsed.pathname;\n        params.host = parsed.hostname + ':' + parsed.port;\n        params.status = this.status;\n        attrs.metrics = {\n          txSize: 0,\n          rxSize: 0\n        };\n        attrs.isJSONP = true;\n        node.jsEnd = this[JSONP_END];\n        node.jsTime = this[CB_START] ? this[JSONP_END] - this[CB_START] : 0;\n        node.finish(node.jsEnd);\n      }\n    }, this.featureName, jsonpEE);\n    register(FETCH_START, function (fetchArguments, dtPayload) {\n      if (fetchArguments) {\n        if (!state.disableSpaFix && !state.currentNode && state.prevInteraction && !state.prevInteraction.ignored) {\n          /*\n           * The previous interaction was discarded before a route change. Restore the interaction\n           * in case this XHR is associated with a route change.\n           */\n          const interaction = state.prevInteraction;\n          state.currentNode = interaction.root;\n          interaction.root.end = null;\n        }\n        if (state.currentNode) {\n          this[SPA_NODE] = state.currentNode.child('ajax', this[FETCH_START]);\n          if (dtPayload && this[SPA_NODE]) {\n            this[SPA_NODE].dt = dtPayload;\n            if (this[SPA_NODE].dt?.timestamp) {\n              this[SPA_NODE].dt.timestamp = agentRef.runtime.timeKeeper.correctAbsoluteTimestamp(this[SPA_NODE].dt.timestamp);\n            }\n          }\n        }\n      }\n    }, this.featureName, fetchEE);\n    register(FETCH_BODY + 'start', function (args) {\n      if (state.currentNode) {\n        this[SPA_NODE] = state.currentNode;\n        state.currentNode[INTERACTION][REMAINING]++;\n      }\n    }, this.featureName, fetchEE);\n    register(FETCH_BODY + 'end', function (args, ctx, bodyPromise) {\n      var node = this[SPA_NODE];\n      if (node) node[INTERACTION][REMAINING]--;\n    }, this.featureName, fetchEE);\n    register(FETCH_DONE, function (err, res) {\n      var node = this[SPA_NODE];\n      if (node) {\n        if (err || !shouldCollectEvent(this.params)) {\n          node.cancel();\n          return;\n        }\n        var attrs = node.attrs;\n        attrs.params = this.params;\n        attrs.metrics = {\n          txSize: this.txSize,\n          rxSize: this.rxSize\n        };\n        attrs.isFetch = true;\n        node.finish(this[FETCH_DONE]);\n      }\n    }, this.featureName, fetchEE);\n    register('newURL', function (url, hashChangedDuringCb) {\n      if (state.currentNode) {\n        state.currentNode[INTERACTION].setNewURL(url);\n      } else if (state.prevInteraction && !state.prevInteraction.ignored) {\n        /*\n         * The previous interaction was discarded before the route was changed. This can happen in SPA\n         * frameworks when using lazy loading. We have also seen this in version 11+ of Nextjs where\n         * some route changes re-use cached resolved promises.\n         */\n        const interaction = state.prevInteraction;\n        interaction.setNewURL(url);\n        interaction.root.end = null;\n        setCurrentNode(interaction.root);\n      }\n      if (state.currentNode) {\n        if (state.lastSeenUrl !== url) {\n          state.currentNode[INTERACTION].routeChange = true;\n        }\n        if (hashChangedDuringCb) {\n          state.nodeOnLastHashUpdate = state.currentNode;\n        }\n      }\n      state.lastSeenUrl = url;\n    }, this.featureName, historyEE);\n\n    /**\n     * SCRIPTS\n     *   This is only needed to keep the interaction open while external scripts are being loaded.\n     *   The script that is loaded could continue the interaction by making additional AJAX\n     *   calls or changing the URL. The interaction context (currentNode) needs to be\n     *   restored somehow, but this differs based on the specific customer code. In some cases, we\n     *   could wrap a JSONP callback, in other cases we could wrap a higher-level API, and in\n     *   some cases we may not be able to restore context automatically (customer would need\n     *   to instrument their code manually).\n     *\n     * - We do not restore the original context in the load/error callbacks. This would not\n     *   work for the scripts themselves because by the time the load event fires, the\n     *   script content has already been executed.\n     */\n\n    // dom-start is emitted when appendChild or replaceChild are called. If the element being\n    // inserted is script and we are inside an interaction, we will keep the interaction open\n    // until the script is loaded.\n    jsonpEE.on('dom-start', function (args) {\n      if (!state.currentNode) return;\n      var el = args[0];\n      var isScript = el && el.nodeName === 'SCRIPT' && el.src !== '';\n      var interaction = state.currentNode.interaction;\n      if (isScript) {\n        // increase remaining count to keep the interaction open\n        interaction[REMAINING]++;\n        el.addEventListener('load', onload, eventListenerOpts(false));\n        el.addEventListener('error', onerror, eventListenerOpts(false));\n      }\n      function onload() {\n        // decrease remaining to allow interaction to finish\n        interaction[REMAINING]--;\n\n        // checkFinish is what initiates closing interaction, but is only called\n        // when setCurrentNode is called. Since we are not restoring a node here,\n        // we need to initiate the check manually.\n        // The reason we are not restoring the node here is because 1) this is not\n        // where the code of the external script runs (by the time the load event\n        // fires, it has already executed), and 2) it would require storing the context\n        // probably on the DOM node and restoring in all callbacks, which is a different\n        // use case than lazy loading.\n        interaction.checkFinish();\n      }\n      function onerror() {\n        interaction[REMAINING]--;\n        interaction.checkFinish();\n      }\n    });\n    register(FN_START, function () {\n      setCurrentNode(state.prevNode);\n    }, this.featureName, mutationEE);\n    register('resolve-start', resolvePromise, this.featureName, promiseEE);\n    register('executor-err', resolvePromise, this.featureName, promiseEE);\n    register('propagate', saveNode, this.featureName, promiseEE);\n    register(CB_START, function () {\n      var ctx = this.getCtx ? this.getCtx() : this;\n      setCurrentNode(ctx[SPA_NODE]);\n    }, this.featureName, promiseEE);\n    register(INTERACTION_API + 'get', function (t) {\n      var interaction;\n      if (state?.currentNode?.[INTERACTION]) interaction = this.ixn = state.currentNode[INTERACTION];else if (state?.prevNode?.end === null && state?.prevNode?.[INTERACTION]?.root?.[INTERACTION]?.eventName !== 'initialPageLoad') interaction = this.ixn = state.prevNode[INTERACTION];else interaction = this.ixn = new Interaction('api', t, state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentRef);\n      if (!state.currentNode) {\n        interaction.checkFinish();\n        if (state.depth) setCurrentNode(interaction.root);\n      }\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'actionText', function (t, actionText) {\n      var customAttrs = this.ixn.root.attrs.custom;\n      if (actionText) customAttrs.actionText = actionText;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'setName', function (t, name, trigger) {\n      var attrs = this.ixn.root.attrs;\n      if (name) attrs.customName = name;\n      if (trigger) attrs.trigger = trigger;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'setAttribute', function (t, name, value) {\n      this.ixn.root.attrs.custom[name] = value;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'end', function (timestamp) {\n      var interaction = this.ixn;\n      var node = activeNodeFor(interaction);\n      setCurrentNode(null);\n      node.child('customEnd', timestamp)?.finish(timestamp);\n      interaction.finish();\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'ignore', function (t) {\n      this.ixn.ignored = true;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'save', function (t) {\n      this.ixn.save = true;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'tracer', function (timestamp, name, store) {\n      var interaction = this.ixn;\n      var parent = activeNodeFor(interaction);\n      var ctx = baseEE.context(store);\n      if (!name) {\n        ctx.inc = ++interaction[REMAINING];\n        return ctx[SPA_NODE] = parent;\n      }\n      ctx[SPA_NODE] = parent.child('customTracer', timestamp, name);\n    }, this.featureName, baseEE);\n    register(FN_START, tracerDone, this.featureName, tracerEE);\n    register('no-' + FN_START, tracerDone, this.featureName, tracerEE);\n    function tracerDone(timestamp, interactionContext, hasCb) {\n      var node = this[SPA_NODE];\n      if (!node) return;\n      var interaction = node[INTERACTION];\n      var inc = this.inc;\n      this.isTraced = true;\n      if (inc) {\n        interaction[REMAINING]--;\n      } else if (node) {\n        node.finish(timestamp);\n      }\n      hasCb ? setCurrentNode(node) : interaction.checkFinish();\n    }\n    register(INTERACTION_API + 'getContext', function (t, cb) {\n      var store = this.ixn.root.attrs.store;\n      setTimeout(function () {\n        cb(store);\n      }, 0);\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'onEnd', function (t, cb) {\n      this.ixn.handlers.push(cb);\n    }, this.featureName, baseEE);\n    register('api-routeName', function (t, currentRouteName) {\n      state.lastSeenRouteName = currentRouteName;\n      if (state.currentNode) state.currentNode[INTERACTION].setNewRoute(currentRouteName);\n    }, this.featureName, baseEE);\n    function activeNodeFor(interaction) {\n      return state.currentNode && state.currentNode[INTERACTION] === interaction ? state.currentNode : interaction.root;\n    }\n    function saveNode(val, overwrite) {\n      if (overwrite || !this[SPA_NODE]) this[SPA_NODE] = state.currentNode;\n    }\n    function resolvePromise() {\n      if (!this.resolved) {\n        this.resolved = true;\n        this[SPA_NODE] = state.currentNode;\n      }\n    }\n    function getCurrentNode() {\n      return state.currentNode;\n    }\n    function setCurrentNode(newNode) {\n      if (!state.pageLoaded && !newNode && state.initialPageLoad) newNode = state.initialPageLoad.root;\n      if (state.currentNode) {\n        state.currentNode[INTERACTION].checkFinish();\n      }\n      state.prevNode = state.currentNode;\n      state.currentNode = newNode && !newNode[INTERACTION].root.end ? newNode : null;\n    }\n    function onInteractionFinished(interaction) {\n      if (interaction === state.initialPageLoad) state.initialPageLoad = null;\n      var root = interaction.root;\n      var attrs = root.attrs;\n\n      // make sure that newrelic[INTERACTION]() works in end handler\n      state.currentNode = root;\n      Object.values(interaction.handlers || {}).forEach(function (cb) {\n        cb(attrs.store);\n      });\n      setCurrentNode(null);\n    }\n    baseEE.on('spa-jserror', function (type, name, params, metrics) {\n      if (!state.currentNode) return;\n      params._interactionId = state.currentNode.interaction.id;\n      // do not capture parentNodeId when in root node\n      if (state.currentNode.type && state.currentNode.type !== 'interaction') {\n        params._interactionNodeId = state.currentNode.id;\n      }\n    });\n    register('function-err', function (args, obj, error) {\n      if (!state.currentNode) return;\n      error.__newrelic ??= {};\n      error.__newrelic[agentRef.agentIdentifier] = {\n        interactionId: state.currentNode.interaction.id\n      };\n      if (state.currentNode.type && state.currentNode.type !== 'interaction') {\n        error.__newrelic[agentRef.agentIdentifier].interactionNodeId = state.currentNode.id;\n      }\n    }, this.featureName, baseEE);\n    baseEE.on('interaction', saveInteraction);\n    function getActionText(node) {\n      var nodeType = node.tagName.toLowerCase();\n      var goodNodeTypes = ['a', 'button', 'input'];\n      var isGoodNode = goodNodeTypes.indexOf(nodeType) !== -1;\n      if (isGoodNode) {\n        return node.title || node.value || node.innerText;\n      }\n    }\n    function saveInteraction(interaction) {\n      if (interaction.ignored || !interaction.save && !interaction.routeChange) {\n        baseEE.emit('interactionDone', [interaction, false]);\n        return;\n      }\n      if (state.prevInteraction === interaction) {\n        // If the interaction is being saved, remove it from prevInteraction variable\n        // to prevent the interaction from possibly being sent twice or causing an internal\n        // recursive loop issue.\n        state.prevInteraction = null;\n      }\n\n      // assign unique id, this is serialized and used to link interactions with errors\n      interaction.root.attrs.id = generateUuid();\n      if (interaction.root.attrs.trigger === 'initialPageLoad') {\n        interaction.root.attrs.firstPaint = firstPaint.current.value;\n        interaction.root.attrs.firstContentfulPaint = firstContentfulPaint.current.value;\n      }\n      baseEE.emit('interactionDone', [interaction, true]);\n      classThis.events.add(interaction);\n      let smCategory;\n      if (interaction.root?.attrs?.trigger === 'initialPageLoad') smCategory = 'InitialPageLoad';else if (interaction.routeChange) smCategory = 'RouteChange';else smCategory = 'Custom';\n      handle(SUPPORTABILITY_METRIC_CHANNEL, [\"Spa/Interaction/\".concat(smCategory, \"/Duration/Ms\"), Math.max((interaction.root?.end || 0) - (interaction.root?.start || 0), 0)], undefined, FEATURE_NAMES.metrics, baseEE);\n      if (!harvester) {\n        warn(19);\n        return;\n      }\n      harvester.triggerHarvestFor(classThis);\n    }\n  }\n  serializer(eventBuffer) {\n    return this.spaSerializerClass.serializeMultiple(eventBuffer, 0, navTiming);\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// We don't use JSON.stringify directly on the performance timing data for these reasons:\n// * Chrome has extra data in the performance object that we don't want to send all the time (wasteful)\n// * Firefox fails to stringify the native object due to - http://code.google.com/p/v8/issues/detail?id=1223\n// * The variable names are long and wasteful to transmit\n\n// Add Performance Timing values to the given object.\n// * Values are written relative to an offset to reduce their length (i.e. number of characters).\n// * The offset is sent with the data\n// * 0's are not included unless the value is a 'relative zero'\n//\n\nvar START = 'Start';\nvar END = 'End';\nvar UNLOAD_EVENT = 'unloadEvent';\nvar REDIRECT = 'redirect';\nvar DOMAIN_LOOKUP = 'domainLookup';\nvar ONNECT = 'onnect';\nvar REQUEST = 'request';\nvar RESPONSE = 'response';\nvar LOAD_EVENT = 'loadEvent';\nvar DOM_CONTENT_LOAD_EVENT = 'domContentLoadedEvent';\nexport const navTimingValues = [];\nfunction getPntType(type) {\n  if (typeof type === 'number') return type;\n  const types = {\n    navigate: undefined,\n    reload: 1,\n    back_forward: 2,\n    prerender: 3\n  };\n  return types[type];\n}\nexport function addPT(offset, pt, v = {}, isL1Api = false) {\n  if (!pt) return;\n  v.of = offset;\n  handleValue(v.of, v, 'n', true);\n  handleValue(pt[UNLOAD_EVENT + START], v, 'u', isL1Api);\n  handleValue(pt[REDIRECT + START], v, 'r', isL1Api);\n  handleValue(pt[UNLOAD_EVENT + END], v, 'ue', isL1Api);\n  handleValue(pt[REDIRECT + END], v, 're', isL1Api);\n  handleValue(pt['fetch' + START], v, 'f', isL1Api);\n  handleValue(pt[DOMAIN_LOOKUP + START], v, 'dn', isL1Api);\n  handleValue(pt[DOMAIN_LOOKUP + END], v, 'dne', isL1Api);\n  handleValue(pt['c' + ONNECT + START], v, 'c', isL1Api);\n  handleValue(pt['secureC' + ONNECT + 'ion' + START], v, 's', isL1Api);\n  handleValue(pt['c' + ONNECT + END], v, 'ce', isL1Api);\n  handleValue(pt[REQUEST + START], v, 'rq', isL1Api);\n  handleValue(pt[RESPONSE + START], v, 'rp', isL1Api);\n  handleValue(pt[RESPONSE + END], v, 'rpe', isL1Api);\n  handleValue(pt.domLoading, v, 'dl', isL1Api);\n  handleValue(pt.domInteractive, v, 'di', isL1Api);\n  handleValue(pt[DOM_CONTENT_LOAD_EVENT + START], v, 'ds', isL1Api);\n  handleValue(pt[DOM_CONTENT_LOAD_EVENT + END], v, 'de', isL1Api);\n  handleValue(pt.domComplete, v, 'dc', isL1Api);\n  handleValue(pt[LOAD_EVENT + START], v, 'l', isL1Api);\n  handleValue(pt[LOAD_EVENT + END], v, 'le', isL1Api);\n  return v;\n}\n\n// Add Performance Navigation values to the given object\nexport function addPN(pn, v) {\n  handleValue(getPntType(pn.type), v, 'ty');\n  handleValue(pn.redirectCount, v, 'rc');\n  return v;\n}\n\n/**\n * By side effect, this modifies 'obj' with a mapping of the 'prop' provided to a 'value', and invalid values are not added.\n * On the other hand, the local navTimingValues array gets the value appended if valid and 'undefined' appended if invalid, regardless.\n */\nfunction handleValue(value, obj, prop, isOldApi) {\n  /*\n  For L2 Timing API, the value will already be a relative-to-previous-document DOMHighResTimeStamp.\n  For L1 (deprecated) Timing, the value is an UNIX epoch timestamp, which we will convert to a relative time using our offset.\n  PNT.type is reported as undefined, 1, 2, etc -- note that zero-value properties will be recorded as 'undefined', however DEM interprets undefined \"types\" as \"navigate\"\n  */\n  if (typeof value === 'number' && value > 0) {\n    // note that zero-value properties will be recorded as 'undefined'\n    if (isOldApi) {\n      const offset = obj?.of > 0 ? obj.of : 0; // expect an epoch timestamp, if called by addPT\n      value = Math.max(value - offset, 0);\n    }\n    value = Math.round(value);\n    obj[prop] = value;\n    navTimingValues.push(value);\n  } else navTimingValues.push(undefined);\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { initialLocation } from '../../../common/constants/runtime';\nimport { gosNREUMOriginals } from '../../../common/window/nreum';\nimport { InteractionNode } from './interaction-node';\nvar originalSetTimeout = gosNREUMOriginals().o.ST;\nvar originalClearTimeout = gosNREUMOriginals().o.CT;\nvar lastId = {};\nexport function Interaction(eventName, timestamp, url, routeName, onFinished, agentRef) {\n  this.agentRef = agentRef;\n  lastId[agentRef.agentIdentifier] = 0;\n  this.id = ++lastId[agentRef.agentIdentifier];\n  this.eventName = eventName;\n  this.nodes = 0;\n  this.remaining = 0;\n  this.finishTimer = null;\n  this.checkingFinish = false;\n  this.lastCb = this.lastFinish = timestamp;\n  this.handlers = [];\n  this.onFinished = onFinished;\n  this.done = false;\n  var root = this.root = new InteractionNode(this, null, 'interaction', timestamp);\n  var attrs = root.attrs;\n  attrs.trigger = eventName;\n  attrs.initialPageURL = initialLocation;\n  attrs.oldRoute = routeName;\n  attrs.newURL = attrs.oldURL = url;\n  attrs.custom = {};\n  attrs.store = {};\n}\nvar InteractionPrototype = Interaction.prototype;\nInteractionPrototype.checkFinish = function checkFinish() {\n  var interaction = this;\n  if (interaction.remaining > 0) {\n    interaction._resetFinishCheck();\n    return;\n  }\n  if (interaction.checkingFinish) {\n    return;\n  }\n  if (interaction.root.end !== null) return;\n  interaction._resetFinishCheck();\n  interaction.checkingFinish = true;\n  interaction.finishTimer = originalSetTimeout(() => {\n    interaction.checkingFinish = false;\n    interaction.finishTimer = originalSetTimeout(() => {\n      interaction.finishTimer = null;\n      if (interaction.remaining <= 0) interaction.finish();\n    }, 1);\n  }, 0);\n};\nInteractionPrototype.setNewURL = function setNewURL(url) {\n  this.root.attrs.newURL = url;\n};\nInteractionPrototype.setNewRoute = function setNewRoute(route) {\n  this.root.attrs.newRoute = route;\n};\nInteractionPrototype.onNodeAdded = function onNodeAdded() {\n  this._resetFinishCheck();\n};\nInteractionPrototype._resetFinishCheck = function _resetFinishCheck() {\n  if (this.finishTimer) {\n    originalClearTimeout(this.finishTimer);\n    this.finishTimer = null;\n    this.checkingFinish = false;\n  }\n};\n\n// serialize report and remove nodes from map\nInteractionPrototype.finish = function finishInteraction() {\n  var interaction = this;\n  var root = interaction.root;\n  if (root.end !== null) return;\n  var endTimestamp = Math.max(interaction.lastCb, interaction.lastFinish);\n  var attrs = root.attrs;\n  var customAttrs = attrs.custom;\n  if (this.onFinished) {\n    this.onFinished(this);\n  }\n  Object.entries(interaction.agentRef.info.jsAttributes || {}).forEach(([attr, value]) => {\n    if (!(attr in customAttrs)) customAttrs[attr] = value;\n  });\n  root.end = endTimestamp;\n  interaction.agentRef.ee.emit('interaction', [this]);\n};","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar MAX_NODES = 128;\nvar lastId = 0;\nexport function InteractionNode(interaction, parent, type, timestamp) {\n  Object.defineProperty(this, 'interaction', {\n    value: interaction,\n    writable: true // enumerable: false -- by default, which hides this prop from obj (iterations)\n  });\n  this.parent = parent;\n  this.id = ++lastId;\n  this.type = type;\n  this.children = [];\n  this.end = null;\n  this.jsEnd = this.start = timestamp;\n  this.jsTime = 0;\n  this.attrs = {};\n  this.cancelled = false;\n}\nvar InteractionNodePrototype = InteractionNode.prototype;\n\n/**\n * @param {string} type\n * @param {number} timestamp\n * @param {string} name\n * @param {bool} dontWait - When true, the interaction will not immediately start waiting\n *                          for this node to complete. This is used when the creation of\n *                          the node and its start happen at different times (e.g. XHR).\n */\nInteractionNodePrototype.child = function child(type, timestamp, name, dontWait) {\n  var interaction = this.interaction;\n  if (interaction.end || interaction.nodes >= MAX_NODES) return null;\n  interaction.onNodeAdded(this);\n  var node = new InteractionNode(interaction, this, type, timestamp);\n  node.attrs.name = name;\n  interaction.nodes++;\n  if (!dontWait) {\n    interaction.remaining++;\n  }\n  return node;\n};\nInteractionNodePrototype.callback = function addCallbackTime(exclusiveTime, end) {\n  var node = this;\n  node.jsTime += exclusiveTime;\n  if (end > node.jsEnd) {\n    node.jsEnd = end;\n    node.interaction.lastCb = end;\n  }\n};\nInteractionNodePrototype.cancel = function cancel() {\n  this.cancelled = true;\n  var interaction = this.interaction;\n  interaction.remaining--;\n};\nInteractionNodePrototype.finish = function finish(timestamp) {\n  var node = this;\n  if (node.end) return;\n  node.end = timestamp;\n\n  // Find the next parent node that is not cancelled\n  let parent = node.parent;\n  while (parent?.cancelled) parent = parent.parent;\n\n  // Assign the node to the non-cancelled parent node\n  if (parent) parent.children.push(node);\n  node.parent = null;\n\n  // Update the interaction remaining counter\n  var interaction = this.interaction;\n  interaction.remaining--;\n  interaction.lastFinish = timestamp;\n  // check if interaction has finished, (this is needed for older browsers for unknown reasons)\n  interaction.checkFinish();\n};","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { cleanURL } from '../../../common/url/clean-url';\nimport { nullable, numeric, getAddStringContext, addCustomAttributes } from '../../../common/serialize/bel-serializer';\nexport class Serializer {\n  constructor(agentRef) {\n    this.obfuscator = agentRef.runtime.obfuscator;\n    this.info = agentRef.info;\n\n    /**\n     * This variable is used to calculate an interactions ending offset when the\n     * harvest includes multiple interactions. This variable is set by the first\n     * interaction processed and used by subsequent interactions in the same harvest.\n     * See https://issues.newrelic.com/browse/NEWRELIC-5498\n     * @type {number|undefined}\n     */\n    this.firstTimestamp = undefined;\n  }\n  serializeMultiple(interactions, offset, navTiming) {\n    var addString = getAddStringContext(this.obfuscator);\n    var serialized = 'bel.7';\n    interactions.forEach(interaction => {\n      serialized += ';' + this.serializeInteraction(interaction.root, offset, navTiming, interaction.routeChange, addString, this.info);\n    });\n    this.firstTimestamp = undefined;\n    return serialized;\n  }\n  serializeSingle(root, offset, navTiming, isRouteChange) {\n    var addString = getAddStringContext(this.obfuscator);\n    var serialized = 'bel.7;' + this.serializeInteraction(root, offset, navTiming, isRouteChange, addString, this.info);\n    this.firstTimestamp = undefined;\n    return serialized;\n  }\n  serializeInteraction(root, offset, navTiming, isRouteChange, addString, info) {\n    offset = offset || 0;\n    var isInitialPage = root.attrs.trigger === 'initialPageLoad';\n    var typeIdsByName = {\n      interaction: 1,\n      ajax: 2,\n      customTracer: 4\n    };\n\n    // Include the hash fragment with all SPA data\n    var includeHashFragment = true;\n    const addNode = (node, nodeList) => {\n      if (node.type === 'customEnd') return nodeList.push([3, numeric(node.end - this.firstTimestamp)]);\n      var typeName = node.type;\n      var typeId = typeIdsByName[typeName];\n      var startTimestamp = node.start;\n      var childCount = node.children.length;\n      var attrCount = 0;\n      var apmAttributes = info.atts;\n      var hasNavTiming = isInitialPage && navTiming.length && typeId === 1;\n      var children = [];\n      var attrs = node.attrs;\n      var metrics = attrs.metrics;\n      var params = attrs.params;\n      var queueTime = info.queueTime;\n      var appTime = info.applicationTime;\n      if (typeof this.firstTimestamp === 'undefined') {\n        startTimestamp += offset;\n        this.firstTimestamp = startTimestamp;\n      } else {\n        startTimestamp -= this.firstTimestamp;\n      }\n      var fields = [numeric(startTimestamp), numeric(node.end - node.start), numeric(node.jsEnd - node.end), numeric(node.jsTime)];\n      switch (typeId) {\n        case 1:\n          fields[2] = numeric(node.jsEnd - this.firstTimestamp);\n          fields.push(addString(attrs.trigger), addString(cleanURL(attrs.initialPageURL, includeHashFragment)), addString(cleanURL(attrs.oldURL, includeHashFragment)), addString(cleanURL(attrs.newURL, includeHashFragment)), addString(attrs.customName), isInitialPage ? '' : isRouteChange ? 1 : 2, nullable(isInitialPage && queueTime, numeric, true) + nullable(isInitialPage && appTime, numeric, true) + nullable(attrs.oldRoute, addString, true) + nullable(attrs.newRoute, addString, true) + addString(attrs.id), addString(node.id), nullable(attrs.firstPaint, numeric, true) + nullable(attrs.firstContentfulPaint, numeric, false));\n          var attrParts = addCustomAttributes(attrs.custom, addString);\n          children = children.concat(attrParts);\n          attrCount = attrParts.length;\n          if (apmAttributes) {\n            childCount++;\n            children.push('a,' + addString(apmAttributes));\n          }\n          break;\n        case 2:\n          fields.push(addString(params.method), numeric(params.status), addString(params.host), addString(params.pathname), numeric(metrics.txSize), numeric(metrics.rxSize), attrs.isFetch ? 1 : attrs.isJSONP ? 2 : '', addString(node.id), nullable(node.dt && node.dt.spanId, addString, true) + nullable(node.dt && node.dt.traceId, addString, true) + nullable(node.dt && node.dt.timestamp, numeric, false));\n\n          // add params.gql here\n          if (Object.keys(params?.gql || {}).length) {\n            var ajaxAttrParts = addCustomAttributes(params.gql, addString);\n            children = children.concat(ajaxAttrParts);\n            attrCount = ajaxAttrParts.length;\n          }\n          break;\n        case 4:\n          var tracedTime = attrs.tracedTime;\n          fields.push(addString(attrs.name), nullable(tracedTime, numeric, true) + addString(node.id));\n          break;\n      }\n      for (var i = 0; i < node.children.length; i++) {\n        addNode(node.children[i], children);\n      }\n      fields.unshift(numeric(typeId), numeric(childCount += attrCount));\n      nodeList.push(fields);\n      if (childCount) {\n        nodeList.push(children.join(';'));\n      }\n      if (hasNavTiming) {\n        // this build up the navTiming node\n        // it for each navTiming value (pre aggregated in nav-timing.js):\n        // we initialize the seperator to ',' (seperates the nodeType id from the first value)\n        // we initialize the navTiming node to 'b' (the nodeType id)\n        // if the value is present:\n        //   we add the seperator followed by the value\n        // otherwise\n        //   we add null seperator ('!') to the navTimingNode\n        //   we set the seperator to an empty string since we already wrote it above\n        //   the reason for writing the null seperator instead of setting the seperator\n        //   is to ensure we still write it if the null is the last navTiming value.\n\n        var seperator = ',';\n        var navTimingNode = 'b';\n        var prev = 0;\n\n        // get all navTiming values except navigationStart\n        // (since its the same as interaction.start)\n        // and limit to just the first 20 values we know about\n        Object.values(navTiming.slice(1, 21) || {}).forEach(v => {\n          if (v !== undefined) {\n            navTimingNode += seperator + numeric(v - prev);\n            seperator = ',';\n            prev = v;\n          } else {\n            navTimingNode += seperator + '!';\n            seperator = '';\n          }\n        });\n        nodeList.push(navTimingNode);\n      } else if (typeId === 1) {\n        nodeList.push('');\n      }\n      return nodeList;\n    };\n    return addNode(root, []).join(';');\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { stringify } from '../util/stringify';\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar MAX_ATTRIBUTES = 64;\nexport function nullable(val, fn, comma) {\n  return val || val === 0 || val === '' ? fn(val) + (comma ? ',' : '') : '!';\n}\nexport function numeric(n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36);\n  }\n  return n === undefined || n === 0 ? '' : Math.floor(n).toString(36);\n}\nexport function getAddStringContext(obfuscator) {\n  let stringTableIdx = 0;\n  const stringTable = Object.prototype.hasOwnProperty.call(Object, 'create') ? Object.create(null) : {};\n  return addString;\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return '';\n    str = obfuscator.obfuscateString(String(str));\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true);\n    } else {\n      stringTable[str] = stringTableIdx++;\n      return quoteString(str);\n    }\n  }\n}\nexport function addCustomAttributes(attrs, addString) {\n  var attrParts = [];\n  Object.entries(attrs || {}).forEach(([key, val]) => {\n    if (attrParts.length >= MAX_ATTRIBUTES) return;\n    var type = 5;\n    var serializedValue;\n    // add key to string table first\n    key = addString(key);\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val));\n        } else {\n          // null attribute type\n          type = 9;\n        }\n        break;\n      case 'number':\n        type = 6;\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.';\n        break;\n      case 'boolean':\n        type = val ? 7 : 8;\n        break;\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9;\n        break;\n      default:\n        serializedValue = addString(val);\n    }\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')]);\n  });\n  return attrParts;\n}\nvar escapable = /([,\\\\;])/g;\nfunction quoteString(str) {\n  return \"'\" + str.replace(escapable, '\\\\$1');\n}"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","self","window","global","parcelRegister","register","module","exports","$c064faa4a9ed4ca3$export$b9601df20779e14a","$4he1m","$5qa2T","$9ZQLQ","$8aXHb","$6sT7C","$5ML72","$8FJov","$fPO2Q","$im7dd","$5boo9","$3R40a","$3DmF0","$ifld8","$gDw2s","$3Nvam","$9EKMI","$gy0pT","$bu0p3","$jkuUu","FEATURE_NAME","$c064faa4a9ed4ca3$var$FEATURE_NAME","INTERACTION_EVENTS","$c064faa4a9ed4ca3$var$INTERACTION_EVENTS","MAX_TIMER_BUDGET","$c064faa4a9ed4ca3$var$MAX_TIMER_BUDGET","FN_START","$c064faa4a9ed4ca3$var$FN_START","FN_END","$c064faa4a9ed4ca3$var$FN_END","CB_START","$c064faa4a9ed4ca3$var$CB_START","INTERACTION_API","$c064faa4a9ed4ca3$var$INTERACTION_API","REMAINING","$c064faa4a9ed4ca3$var$REMAINING","INTERACTION","$c064faa4a9ed4ca3$var$INTERACTION","SPA_NODE","$c064faa4a9ed4ca3$var$SPA_NODE","JSONP_NODE","$c064faa4a9ed4ca3$var$JSONP_NODE","FETCH_START","$c064faa4a9ed4ca3$var$FETCH_START","FETCH_DONE","$c064faa4a9ed4ca3$var$FETCH_DONE","FETCH_BODY","$c064faa4a9ed4ca3$var$FETCH_BODY","JSONP_END","$c064faa4a9ed4ca3$var$JSONP_END","originalSetTimeout","$c064faa4a9ed4ca3$var$originalSetTimeout","AggregateBase","featureName","constructor","agentRef","harvester","state","initialPageURL","initialLocation","lastSeenUrl","lastSeenRouteName","timerMap","timerBudget","currentNode","prevNode","nodeOnLastHashUpdate","initialPageLoad","pageLoaded","childTime","depth","disableSpaFix","init","feature_flags","indexOf","spaSerializerClass","Serializer","classThis","baseEE","ee","agentIdentifier","mutationEE","promiseEE","historyEE","eventsEE","timerEE","fetchEE","jsonpEE","xhrEE","tracerEE","waitForFlags","then","spaFlag","runtime","drain","blocked","deregisterDrain","spa","enabled","Interaction","onInteractionFinished","save","session","isNew","root","attrs","custom","isFirstOfSession","prevInteraction","registerHandler","callbackStart","pluginApi","getCurrentNode","setCurrentNode","ct","callbackEnd","totalTime","jsTime","exclusiveTime","callback","isTraced","tracedTime","tracerDone","timestamp","interactionContext","hasCb","node","interaction","inc","finish","checkFinish","activeNodeFor","resolvePromise","resolved","newNode","end","values","handlers","forEach","cb","store","FEATURE_NAMES","args","eventSource","ev","evName","type","eventNode","concat","bundleId","loadedAsDeferredBrowserScript","push","XMLHttpRequest","context","spaNode","ixn","value","getActionText","goodNodeTypes","tagName","toLowerCase","title","innerText","target","actionText","obj","timerId","timerDuration","Function","id","ignored","child","sent","dt","timeKeeper","correctAbsoluteTimestamp","jsEnd","start","startTime","shouldCollectEvent","params","cancel","metrics","endTime","url","status","parsed","parseUrl","method","pathname","host","hostname","port","txSize","rxSize","isJSONP","fetchArguments","dtPayload","ctx","bodyPromise","err","res","isFetch","hashChangedDuringCb","setNewURL","routeChange","on","el","isScript","nodeName","src","addEventListener","eventListenerOpts","val","overwrite","getCtx","t","eventName","customAttrs","name","trigger","customName","parent","setTimeout","currentRouteName","setNewRoute","_interactionId","_interactionNodeId","error","__newrelic","interactionId","interactionNodeId","smCategory","generateUuid","firstPaint","current","firstContentfulPaint","emit","events","add","handle","SUPPORTABILITY_METRIC_CHANNEL","Math","max","undefined","triggerHarvestFor","warn","serializer","eventBuffer","serializeMultiple","navTimingValues","$5f3d902af6b1b508$export$2f44a866b65eb89b","$5f3d902af6b1b508$export$4eecd77d9102a9b2","$5f3d902af6b1b508$export$a47612ea3c40772d","$5f3d902af6b1b508$var$START","$5f3d902af6b1b508$var$UNLOAD_EVENT","$5f3d902af6b1b508$var$REDIRECT","$5f3d902af6b1b508$var$DOMAIN_LOOKUP","$5f3d902af6b1b508$var$ONNECT","$5f3d902af6b1b508$var$RESPONSE","$5f3d902af6b1b508$var$LOAD_EVENT","$5f3d902af6b1b508$var$DOM_CONTENT_LOAD_EVENT","offset","pt","isL1Api","of","$5f3d902af6b1b508$var$handleValue","$5f3d902af6b1b508$var$REQUEST","domLoading","domInteractive","domComplete","pn","types","navigate","reload","back_forward","prerender","redirectCount","prop","isOldApi","round","$4365fb078d1679da$export$a13296960cae0384","$juL0p","$QoKOJ","$4365fb078d1679da$var$originalSetTimeout","gosNREUMOriginals","o","ST","$4365fb078d1679da$var$originalClearTimeout","CT","$4365fb078d1679da$var$lastId","routeName","onFinished","nodes","remaining","finishTimer","checkingFinish","lastCb","lastFinish","done","InteractionNode","oldRoute","newURL","oldURL","$4365fb078d1679da$var$InteractionPrototype","prototype","_resetFinishCheck","route","newRoute","onNodeAdded","endTimestamp","entries","info","jsAttributes","attr","$09d80f185bfd9b94$export$b0f4aa4abbc3e49a","$09d80f185bfd9b94$var$lastId","writable","children","cancelled","$09d80f185bfd9b94$var$InteractionNodePrototype","dontWait","$b872705412ca5d32$export$ef852775387a0be7","$jWywI","$ewyxt","obfuscator","firstTimestamp","interactions","navTiming","addString","getAddStringContext","serialized","serializeInteraction","serializeSingle","isRouteChange","isInitialPage","typeIdsByName","ajax","customTracer","addNode","nodeList","numeric","typeId","startTimestamp","childCount","length","attrCount","apmAttributes","atts","hasNavTiming","queueTime","appTime","applicationTime","fields","cleanURL","nullable","attrParts","addCustomAttributes","spanId","traceId","keys","gql","ajaxAttrParts","i","unshift","join","seperator","navTimingNode","prev","slice","$a92ed88948900b2c$export$133fc36489ac9add","$a92ed88948900b2c$export$b7a508fa8dae59fc","$a92ed88948900b2c$export$71f03e17b83cbe02","$a92ed88948900b2c$export$b7f14f78b59de5aa","$8KO5M","$a92ed88948900b2c$var$hasOwnProp","hasOwnProperty","fn","comma","noDefault","floor","toString","stringTableIdx","stringTable","call","create","str","obfuscateString","String","replace","$a92ed88948900b2c$var$escapable","key","serializedValue","stringify"],"version":3,"file":"aggregate.cf74affc.js.map"}
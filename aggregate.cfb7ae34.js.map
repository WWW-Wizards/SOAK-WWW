{"mappings":"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","sources":["<anon>","node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/aggregate/index.js","node_modules/@newrelic/browser-agent/dist/esm/common/constants/shared-channel.js","node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/shared/stylesheet-evaluator.js","node_modules/@parcel/runtime-js/lib/runtime-dc05cfc65990bdbf.js","node_modules/@parcel/runtime-js/lib/runtime-381d5282a355632b.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$import(url) {\n  url = parcelRequire.i?.[url] || url;\n  return import($parcel$distDir + url);\n}\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  var $parcel$distDir = \"./\";\nvar parcelRequire = $parcel$global[\"parcelRequire5e30\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"8rBbr\", function(module, exports) {\n\n$parcel$export(module.exports, \"Aggregate\", function () { return $625db035f0c28dc8$export$b9601df20779e14a; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * @file Records, aggregates, and harvests session replay data.\n */ \nvar $4he1m = parcelRequire(\"4he1m\");\n\nvar $6bsRh = parcelRequire(\"6bsRh\");\n\nvar $3DmF0 = parcelRequire(\"3DmF0\");\n\nvar $5GJZE = parcelRequire(\"5GJZE\");\n\nvar $ikySP = parcelRequire(\"ikySP\");\n\nvar $jkuUu = parcelRequire(\"jkuUu\");\n\nvar $9EKMI = parcelRequire(\"9EKMI\");\n\nvar $4wUr4 = parcelRequire(\"4wUr4\");\n\nvar $44Lnf = parcelRequire(\"44Lnf\");\n\nvar $8KO5M = parcelRequire(\"8KO5M\");\n\nvar $7tsml = parcelRequire(\"7tsml\");\n\nvar $1Z3KE = parcelRequire(\"1Z3KE\");\n\nvar $24qgc = parcelRequire(\"24qgc\");\n\nvar $iNTSX = parcelRequire(\"iNTSX\");\n\nvar $jWywI = parcelRequire(\"jWywI\");\n\nvar $1orxZ = parcelRequire(\"1orxZ\");\n\n\nclass $625db035f0c28dc8$export$b9601df20779e14a extends (0, $3DmF0.AggregateBase) {\n    static featureName = (0, $6bsRh.FEATURE_NAME);\n    mode = (0, $44Lnf.MODE).OFF;\n    // pass the recorder into the aggregator\n    constructor(agentRef, args){\n        super(agentRef, (0, $6bsRh.FEATURE_NAME));\n        /** Set once the recorder has fully initialized after flag checks and sampling */ this.initialized = false;\n        /** Set once the feature has been \"aborted\" to prevent other side-effects from continuing */ this.blocked = false;\n        /** populated with the gzipper lib async */ this.gzipper = undefined;\n        /** populated with the u8 string lib async */ this.u8 = undefined;\n        /** set by BCS response */ this.entitled = false;\n        /** set at BCS response, stored in runtime */ this.timeKeeper = undefined;\n        this.recorder = args?.recorder;\n        this.errorNoticed = args?.errorNoticed || false;\n        this.harvestOpts.raw = true;\n        this.isSessionTrackingEnabled = (0, $1orxZ.canEnableSessionTracking)(agentRef.init) && !!agentRef.runtime.session;\n        this.reportSupportabilityMetric('Config/SessionReplay/Enabled');\n        // The SessionEntity class can emit a message indicating the session was cleared and reset (expiry, inactivity). This feature must abort and never resume if that occurs.\n        this.ee.on((0, $44Lnf.SESSION_EVENTS).RESET, ()=>{\n            this.abort((0, $6bsRh.ABORT_REASONS).RESET);\n        });\n        // The SessionEntity class can emit a message indicating the session was paused (visibility change). This feature must stop recording if that occurs.\n        this.ee.on((0, $44Lnf.SESSION_EVENTS).PAUSE, ()=>{\n            this.recorder?.stopRecording();\n        });\n        // The SessionEntity class can emit a message indicating the session was resumed (visibility change). This feature must start running again (if already running) if that occurs.\n        this.ee.on((0, $44Lnf.SESSION_EVENTS).RESUME, ()=>{\n            if (!this.recorder) return;\n            // if the mode changed on a different tab, it needs to update this instance to match\n            this.mode = agentRef.runtime.session.state.sessionReplayMode;\n            if (!this.initialized || this.mode === (0, $44Lnf.MODE).OFF) return;\n            this.recorder?.startRecording();\n        });\n        this.ee.on((0, $44Lnf.SESSION_EVENTS).UPDATE, (type, data)=>{\n            if (!this.recorder || !this.initialized || this.blocked || type !== (0, $44Lnf.SESSION_EVENT_TYPES).CROSS_TAB) return;\n            if (this.mode !== (0, $44Lnf.MODE).OFF && data.sessionReplayMode === (0, $44Lnf.MODE).OFF) this.abort((0, $6bsRh.ABORT_REASONS).CROSS_TAB);\n            this.mode = data.sessionReplayMode;\n        });\n        (0, $4he1m.registerHandler)((0, $6bsRh.SR_EVENT_EMITTER_TYPES).PAUSE, ()=>{\n            this.forceStop(this.mode === (0, $44Lnf.MODE).FULL);\n        }, this.featureName, this.ee);\n        (0, $4he1m.registerHandler)((0, $6bsRh.SR_EVENT_EMITTER_TYPES).ERROR_DURING_REPLAY, (e)=>{\n            this.handleError(e);\n        }, this.featureName, this.ee);\n        const { error_sampling_rate: error_sampling_rate, sampling_rate: sampling_rate, autoStart: autoStart, block_selector: block_selector, mask_text_selector: mask_text_selector, mask_all_inputs: mask_all_inputs, inline_images: inline_images, collect_fonts: collect_fonts } = agentRef.init.session_replay;\n        this.waitForFlags([\n            'srs',\n            'sr'\n        ]).then(([srMode, entitled])=>{\n            this.entitled = !!entitled;\n            if (!this.entitled) {\n                this.deregisterDrain();\n                if (this.recorder?.recording) {\n                    this.abort((0, $6bsRh.ABORT_REASONS).ENTITLEMENTS);\n                    this.reportSupportabilityMetric('SessionReplay/EnabledNotEntitled/Detected');\n                }\n                return;\n            }\n            this.drain();\n            this.initializeRecording(srMode);\n        }).then(()=>{\n            if (this.mode === (0, $44Lnf.MODE).OFF) {\n                this.recorder?.stopRecording(); // stop any conservative preload recording launched by instrument\n                while(this.recorder?.getEvents().events.length)this.recorder?.clearBuffer?.();\n            }\n            (0, $5GJZE.sharedChannel).onReplayReady(this.mode);\n        }); // notify watchers that replay started with the mode\n        /** Detect if the default configs have been altered and report a SM.  This is useful to evaluate what the reasonable defaults are across a customer base over time */ if (!autoStart) this.reportSupportabilityMetric('Config/SessionReplay/AutoStart/Modified');\n        if (collect_fonts === true) this.reportSupportabilityMetric('Config/SessionReplay/CollectFonts/Modified');\n        if (inline_images === true) this.reportSupportabilityMetric('Config/SessionReplay/InlineImages/Modifed');\n        if (mask_all_inputs !== true) this.reportSupportabilityMetric('Config/SessionReplay/MaskAllInputs/Modified');\n        if (block_selector !== '[data-nr-block]') this.reportSupportabilityMetric('Config/SessionReplay/BlockSelector/Modified');\n        if (mask_text_selector !== '*') this.reportSupportabilityMetric('Config/SessionReplay/MaskTextSelector/Modified');\n        this.reportSupportabilityMetric('Config/SessionReplay/SamplingRate/Value', sampling_rate);\n        this.reportSupportabilityMetric('Config/SessionReplay/ErrorSamplingRate/Value', error_sampling_rate);\n    }\n    replayIsActive() {\n        return Boolean(this.recorder && this.mode === (0, $44Lnf.MODE).FULL && !this.blocked && this.entitled);\n    }\n    handleError(e) {\n        if (this.recorder) this.recorder.currentBufferTarget.hasError = true;\n        // run once\n        if (this.mode === (0, $44Lnf.MODE).ERROR && (0, $9EKMI.globalScope)?.document.visibilityState === 'visible') this.switchToFull();\n    }\n    switchToFull() {\n        if (!this.entitled || this.blocked) return;\n        this.mode = (0, $44Lnf.MODE).FULL;\n        // if the error was noticed AFTER the recorder was already imported....\n        if (this.recorder && this.initialized) {\n            if (!this.recorder.recording) this.recorder.startRecording();\n            this.syncWithSessionManager({\n                sessionReplayMode: this.mode\n            });\n        } else this.initializeRecording((0, $44Lnf.MODE).FULL, true);\n    }\n    /**\n   * Evaluate entitlements and sampling before starting feature mechanics, importing and configuring recording library, and setting storage state\n   * @param {boolean} srMode - the true/false state of the \"sr\" flag (aka. entitlements) from RUM response\n   * @param {boolean} ignoreSession - whether to force the method to ignore the session state and use just the sample flags\n   * @returns {void}\n   */ async initializeRecording(srMode, ignoreSession) {\n        this.initialized = true;\n        if (!this.entitled) return;\n        // if theres an existing session replay in progress, there's no need to sample, just check the entitlements response\n        // if not, these sample flags need to be checked\n        // if this isnt the FIRST load of a session AND\n        // we are not actively recording SR... DO NOT import or run the recording library\n        // session replay samples can only be decided on the first load of a session\n        // session replays can continue if already in progress\n        const { session: session, timeKeeper: timeKeeper } = this.agentRef.runtime;\n        this.timeKeeper = timeKeeper;\n        if (this.recorder?.parent.trigger === (0, $6bsRh.TRIGGERS).API && this.recorder?.recording) this.mode = (0, $44Lnf.MODE).FULL;\n        else if (!session.isNew && !ignoreSession) // inherit the mode of the existing session\n        this.mode = session.state.sessionReplayMode;\n        else // The session is new... determine the mode the new session should start in\n        this.mode = srMode;\n        // If off, then don't record (early return)\n        if (this.mode === (0, $44Lnf.MODE).OFF) return;\n        if (!this.recorder) try {\n            // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n            const { Recorder: Recorder } = await (parcelRequire(\"8tHcq\"));\n            this.recorder = new Recorder(this);\n            this.recorder.currentBufferTarget.hasError = this.errorNoticed;\n        } catch (err) {\n            return this.abort((0, $6bsRh.ABORT_REASONS).IMPORT);\n        }\n        else this.recorder.parent = this;\n        // If an error was noticed before the mode could be set (like in the early lifecycle of the page), immediately set to FULL mode\n        if (this.mode === (0, $44Lnf.MODE).ERROR && this.errorNoticed) this.mode = (0, $44Lnf.MODE).FULL;\n        // FULL mode records AND reports from the beginning, while ERROR mode only records (but does not report).\n        // ERROR mode will do this until an error is thrown, and then switch into FULL mode.\n        // The makeHarvestPayload should ensure that no payload is returned if we're not in FULL mode...\n        // If theres preloaded events and we are in full mode, just harvest immediately to clear up space and for consistency\n        if (this.mode === (0, $44Lnf.MODE).FULL && this.recorder?.getEvents().type === 'preloaded') this.prepUtils().then(()=>this.agentRef.runtime.harvester.triggerHarvestFor(this));\n        await this.prepUtils();\n        if (!this.recorder.recording) this.recorder.startRecording();\n        this.syncWithSessionManager({\n            sessionReplayMode: this.mode\n        });\n    }\n    async prepUtils() {\n        try {\n            // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n            const { gzipSync: gzipSync, strToU8: strToU8 } = await (parcelRequire(\"7YYUV\"));\n            this.gzipper = gzipSync;\n            this.u8 = strToU8;\n        } catch (err) {\n        // compressor failed to load, but we can still record without compression as a last ditch effort\n        }\n    }\n    makeHarvestPayload(shouldRetryOnFail) {\n        const payloadOutput = {\n            targetApp: undefined,\n            payload: undefined\n        };\n        if (this.mode !== (0, $44Lnf.MODE).FULL || this.blocked) return;\n        if (!this.recorder || !this.timeKeeper?.ready || !this.recorder.hasSeenSnapshot) return;\n        const recorderEvents = this.recorder.getEvents();\n        // get the event type and use that to trigger another harvest if needed\n        if (!recorderEvents.events.length) return;\n        const payload = this.getHarvestContents(recorderEvents);\n        if (!payload.body.length) {\n            this.recorder.clearBuffer();\n            return [\n                payloadOutput\n            ];\n        }\n        this.reportSupportabilityMetric('SessionReplay/Harvest/Attempts');\n        let len = 0;\n        if (!!this.gzipper && !!this.u8) {\n            payload.body = this.gzipper(this.u8(\"[\".concat(payload.body.map(({ __serialized: __serialized, ...e })=>{\n                if (e.__newrelic && __serialized) return __serialized;\n                const output = {\n                    ...e\n                };\n                if (!output.__newrelic) {\n                    output.__newrelic = (0, $24qgc.buildNRMetaNode)(e.timestamp, this.timeKeeper);\n                    output.timestamp = this.timeKeeper.correctAbsoluteTimestamp(e.timestamp);\n                }\n                return (0, $8KO5M.stringify)(output);\n            }).join(','), \"]\")));\n            len = payload.body.length;\n        } else {\n            payload.body = payload.body.map(({ __serialized: __serialized, ...node })=>{\n                if (node.__newrelic) return node;\n                const output = {\n                    ...node\n                };\n                output.__newrelic = (0, $24qgc.buildNRMetaNode)(node.timestamp, this.timeKeeper);\n                output.timestamp = this.timeKeeper.correctAbsoluteTimestamp(node.timestamp);\n                return output;\n            });\n            len = (0, $8KO5M.stringify)(payload.body).length;\n        }\n        if (len > (0, $iNTSX.MAX_PAYLOAD_SIZE)) {\n            this.abort((0, $6bsRh.ABORT_REASONS).TOO_BIG, len);\n            return [\n                payloadOutput\n            ];\n        }\n        // TODO -- Gracefully handle the buffer for retries.\n        if (!this.agentRef.runtime.session.state.sessionReplaySentFirstChunk) this.syncWithSessionManager({\n            sessionReplaySentFirstChunk: true\n        });\n        this.recorder.clearBuffer();\n        if (recorderEvents.type === 'preloaded') this.agentRef.runtime.harvester.triggerHarvestFor(this);\n        payloadOutput.payload = payload;\n        return [\n            payloadOutput\n        ];\n    }\n    getCorrectedTimestamp(node) {\n        if (!node?.timestamp) return;\n        if (node.__newrelic) return node.timestamp;\n        return this.timeKeeper.correctAbsoluteTimestamp(node.timestamp);\n    }\n    getHarvestContents(recorderEvents) {\n        recorderEvents ??= this.recorder.getEvents();\n        let events = recorderEvents.events;\n        const agentRuntime = this.agentRef.runtime;\n        const endUserId = this.agentRef.info.jsAttributes?.['enduser.id'];\n        // do not let the first node be a full snapshot node, since this NEEDS to be preceded by a meta node\n        // we will manually inject it if this happens\n        const payloadStartsWithFullSnapshot = events?.[0]?.type === (0, $6bsRh.RRWEB_EVENT_TYPES).FullSnapshot;\n        if (payloadStartsWithFullSnapshot && !!this.recorder.lastMeta) {\n            recorderEvents.hasMeta = true;\n            events.unshift(this.recorder.lastMeta); // --> pushed the meta from a previous payload into newer payload... but it still has old timestamps\n            this.recorder.lastMeta = undefined;\n        }\n        // do not let the last node be a meta node, since this NEEDS to precede a snapshot\n        // we will manually inject it later if we find a payload that is missing a meta node\n        const payloadEndsWithMeta = events[events.length - 1]?.type === (0, $6bsRh.RRWEB_EVENT_TYPES).Meta;\n        if (payloadEndsWithMeta) {\n            this.recorder.lastMeta = events[events.length - 1];\n            events = events.slice(0, events.length - 1);\n            recorderEvents.hasMeta = !!events.find((x)=>x.type === (0, $6bsRh.RRWEB_EVENT_TYPES).Meta);\n        }\n        const relativeNow = (0, $1Z3KE.now)();\n        const firstEventTimestamp = this.getCorrectedTimestamp(events[0]); // from rrweb node\n        const lastEventTimestamp = this.getCorrectedTimestamp(events[events.length - 1]); // from rrweb node\n        // from rrweb node || from when the harvest cycle started\n        const firstTimestamp = firstEventTimestamp || Math.floor(this.timeKeeper.correctAbsoluteTimestamp(recorderEvents.cycleTimestamp));\n        const lastTimestamp = lastEventTimestamp || Math.floor(this.timeKeeper.correctRelativeTimestamp(relativeNow));\n        const agentMetadata = agentRuntime.appMetadata?.agents?.[0] || {};\n        return {\n            qs: {\n                browser_monitoring_key: this.agentRef.info.licenseKey,\n                type: 'SessionReplay',\n                app_id: this.agentRef.info.applicationID,\n                protocol_version: '0',\n                timestamp: firstTimestamp,\n                attributes: (0, $ikySP.obj)({\n                    // this section of attributes must be controllable and stay below the query param padding limit -- see QUERY_PARAM_PADDING\n                    // if not, data could be lost to truncation at time of sending, potentially breaking parsing / API behavior in NR1\n                    ...!!this.gzipper && !!this.u8 && {\n                        content_encoding: 'gzip'\n                    },\n                    ...agentMetadata.entityGuid && {\n                        entityGuid: agentMetadata.entityGuid\n                    },\n                    harvestId: [\n                        agentRuntime.session?.state.value,\n                        agentRuntime.ptid,\n                        agentRuntime.harvestCount\n                    ].filter((x)=>x).join('_'),\n                    'replay.firstTimestamp': firstTimestamp,\n                    'replay.lastTimestamp': lastTimestamp,\n                    'replay.nodes': events.length,\n                    'session.durationMs': agentRuntime.session.getDuration(),\n                    agentVersion: agentRuntime.version,\n                    session: agentRuntime.session.state.value,\n                    rst: relativeNow,\n                    hasMeta: recorderEvents.hasMeta || false,\n                    hasSnapshot: recorderEvents.hasSnapshot || false,\n                    hasError: recorderEvents.hasError || false,\n                    isFirstChunk: agentRuntime.session.state.sessionReplaySentFirstChunk === false,\n                    decompressedBytes: recorderEvents.payloadBytesEstimation,\n                    invalidStylesheetsDetected: (0, $7tsml.stylesheetEvaluator).invalidStylesheetsDetected,\n                    inlinedAllStylesheets: recorderEvents.inlinedAllStylesheets,\n                    'rrweb.version': (0, $4wUr4.RRWEB_VERSION),\n                    'payload.type': recorderEvents.type,\n                    // customer-defined data should go last so that if it exceeds the query param padding limit it will be truncated instead of important attrs\n                    ...endUserId && {\n                        'enduser.id': this.obfuscator.obfuscateString(endUserId)\n                    },\n                    currentUrl: this.obfuscator.obfuscateString((0, $jWywI.cleanURL)('' + location))\n                }, (0, $6bsRh.QUERY_PARAM_PADDING)).substring(1) // remove the leading '&'\n            },\n            body: events\n        };\n    }\n    postHarvestCleanup(result) {\n        // The mutual decision for now is to stop recording and clear buffers if ingest is experiencing 429 rate limiting\n        if (result.status === 429) this.abort((0, $6bsRh.ABORT_REASONS).TOO_MANY);\n    }\n    /**\n   * Forces the agent into OFF mode so that changing tabs or navigating\n   * does not restart the recording. This is used when the customer calls\n   * the stopRecording API.\n   */ forceStop(forceHarvest) {\n        if (forceHarvest) this.agentRef.runtime.harvester.triggerHarvestFor(this);\n        this.mode = (0, $44Lnf.MODE).OFF;\n        this.recorder?.stopRecording?.();\n        this.syncWithSessionManager({\n            sessionReplayMode: this.mode\n        });\n    }\n    /** Abort the feature, once aborted it will not resume */ abort(reason = {}, data) {\n        (0, $jkuUu.warn)(33, reason.message);\n        this.reportSupportabilityMetric(\"SessionReplay/Abort/\".concat(reason.sm), data);\n        this.blocked = true;\n        this.mode = (0, $44Lnf.MODE).OFF;\n        this.recorder?.stopRecording?.();\n        this.syncWithSessionManager({\n            sessionReplayMode: this.mode\n        });\n        this.recorder?.clearTimestamps?.();\n        while(this.recorder?.getEvents().events.length)this.recorder?.clearBuffer?.();\n    }\n    syncWithSessionManager(state = {}) {\n        if (this.isSessionTrackingEnabled) this.agentRef.runtime.session.write(state);\n    }\n}\n\n});\nparcelRegister(\"5GJZE\", function(module, exports) {\n\n$parcel$export(module.exports, \"sharedChannel\", function () { return $42448d51f724b7bf$export$ef19b434e352183b; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * @file Keeps an object alive that is passed to all feature aggregate modules.\n * The purpose is to have a way for communication and signals to relay across features at runtime.\n * This object can hold any arbitrary values and should be treated as on-the-fly dynamic.\n */ let $42448d51f724b7bf$var$onReplayReady;\nconst $42448d51f724b7bf$var$sessionReplayInitialized = new Promise((resolve)=>{\n    $42448d51f724b7bf$var$onReplayReady = resolve;\n});\nconst $42448d51f724b7bf$export$ef19b434e352183b = Object.freeze({\n    onReplayReady: $42448d51f724b7bf$var$onReplayReady,\n    sessionReplayInitialized: $42448d51f724b7bf$var$sessionReplayInitialized\n});\n\n});\n\nparcelRegister(\"7tsml\", function(module, exports) {\n\n$parcel$export(module.exports, \"stylesheetEvaluator\", function () { return $57113d7053e688ae$export$fdabeb4af43679fc; });\n/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */ \nvar $juL0p = parcelRequire(\"juL0p\");\n\nvar $9EKMI = parcelRequire(\"9EKMI\");\nclass $57113d7053e688ae$var$StylesheetEvaluator {\n    #evaluated = new WeakSet();\n    #brokenSheets = [];\n    /**\n  * Flipped to true if stylesheets that cannot be natively inlined are detected by the stylesheetEvaluator class\n  * Used at harvest time to denote that all subsequent payloads are subject to this and customers should be advised to handle crossorigin decoration\n  * */ invalidStylesheetsDetected = false;\n    failedToFix = 0;\n    /**\n   * this works by checking (only ever once) each cssRules obj in the style sheets array. The try/catch will catch an error if the cssRules obj blocks access, triggering the module to try to \"fix\" the asset`. Returns the count of incomplete assets discovered.\n   * @returns {Number}\n   */ evaluate() {\n        let incompletes = 0;\n        this.#brokenSheets = [];\n        if (0, $9EKMI.isBrowserScope) {\n            for(let i = 0; i < Object.keys(document.styleSheets).length; i++)if (!this.#evaluated.has(document.styleSheets[i]) && document.styleSheets[i] instanceof CSSStyleSheet) {\n                this.#evaluated.add(document.styleSheets[i]);\n                try {\n                    // eslint-disable-next-line\n                    const temp = document.styleSheets[i].cssRules;\n                } catch (err) {\n                    if (!document.styleSheets[i].href) return;\n                    incompletes++;\n                    this.#brokenSheets.push(document.styleSheets[i]);\n                }\n            }\n        }\n        if (incompletes) this.invalidStylesheetsDetected = true;\n        return incompletes;\n    }\n    /**\n   * Resolves promise once all stylesheets have been fetched and overridden\n   * @returns {Promise}\n   */ async fix() {\n        await Promise.all(this.#brokenSheets.map((sheet)=>this.#fetchAndOverride(sheet)));\n        this.#brokenSheets = [];\n        const failedToFix = this.failedToFix;\n        this.failedToFix = 0;\n        return failedToFix;\n    }\n    /**\n  * Fetches stylesheet contents and overrides the target getters\n  * @param {*} target - The stylesheet object target - ex. document.styleSheets[0]\n  * @param {*} href - The asset href to fetch\n  * @returns {Promise}\n  */ async #fetchAndOverride(target) {\n        if (!target?.href) return;\n        try {\n            const stylesheetContents = await (0, $juL0p.gosNREUMOriginals)().o.FETCH.bind(window)(target.href);\n            if (!stylesheetContents.ok) {\n                this.failedToFix++;\n                return;\n            }\n            const stylesheetText = await stylesheetContents.text();\n            try {\n                const cssSheet = new CSSStyleSheet();\n                await cssSheet.replace(stylesheetText);\n                Object.defineProperty(target, 'cssRules', {\n                    get () {\n                        return cssSheet.cssRules;\n                    }\n                });\n                Object.defineProperty(target, 'rules', {\n                    get () {\n                        return cssSheet.rules;\n                    }\n                });\n            } catch (err) {\n                // cant make new dynamic stylesheets, browser likely doesn't support `.replace()`...\n                // this is appended in prep of forking rrweb\n                Object.defineProperty(target, 'cssText', {\n                    get () {\n                        return stylesheetText;\n                    }\n                });\n                this.failedToFix++;\n            }\n        } catch (err) {\n            // failed to fetch\n            this.failedToFix++;\n        }\n    }\n}\nconst $57113d7053e688ae$export$fdabeb4af43679fc = new $57113d7053e688ae$var$StylesheetEvaluator();\n\n});\n\nparcelRegister(\"8tHcq\", function(module, exports) {\nmodule.exports = Promise.all([\n    $parcel$import(\"bolVv\"),\n    $parcel$import(\"7qhnc\")\n]).then(()=>parcelRequire('laqLT'));\n\n});\n\nparcelRegister(\"7YYUV\", function(module, exports) {\nmodule.exports = $parcel$import(\"gYIeX\").then(()=>parcelRequire('hIp1Z'));\n\n});\n\n\n\n//# sourceMappingURL=aggregate.cfb7ae34.js.map\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @file Records, aggregates, and harvests session replay data.\n */\n\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { ABORT_REASONS, FEATURE_NAME, QUERY_PARAM_PADDING, RRWEB_EVENT_TYPES, SR_EVENT_EMITTER_TYPES, TRIGGERS } from '../constants';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { sharedChannel } from '../../../common/constants/shared-channel';\nimport { obj as encodeObj } from '../../../common/url/encode';\nimport { warn } from '../../../common/util/console';\nimport { globalScope } from '../../../common/constants/runtime';\nimport { RRWEB_VERSION } from \"../../../common/constants/env.npm\";\nimport { MODE, SESSION_EVENTS, SESSION_EVENT_TYPES } from '../../../common/session/constants';\nimport { stringify } from '../../../common/util/stringify';\nimport { stylesheetEvaluator } from '../shared/stylesheet-evaluator';\nimport { now } from '../../../common/timing/now';\nimport { buildNRMetaNode } from '../shared/utils';\nimport { MAX_PAYLOAD_SIZE } from '../../../common/constants/agent-constants';\nimport { cleanURL } from '../../../common/url/clean-url';\nimport { canEnableSessionTracking } from '../../utils/feature-gates';\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  mode = MODE.OFF;\n\n  // pass the recorder into the aggregator\n  constructor(agentRef, args) {\n    super(agentRef, FEATURE_NAME);\n    /** Set once the recorder has fully initialized after flag checks and sampling */\n    this.initialized = false;\n    /** Set once the feature has been \"aborted\" to prevent other side-effects from continuing */\n    this.blocked = false;\n    /** populated with the gzipper lib async */\n    this.gzipper = undefined;\n    /** populated with the u8 string lib async */\n    this.u8 = undefined;\n\n    /** set by BCS response */\n    this.entitled = false;\n    /** set at BCS response, stored in runtime */\n    this.timeKeeper = undefined;\n    this.recorder = args?.recorder;\n    this.errorNoticed = args?.errorNoticed || false;\n    this.harvestOpts.raw = true;\n    this.isSessionTrackingEnabled = canEnableSessionTracking(agentRef.init) && !!agentRef.runtime.session;\n    this.reportSupportabilityMetric('Config/SessionReplay/Enabled');\n\n    // The SessionEntity class can emit a message indicating the session was cleared and reset (expiry, inactivity). This feature must abort and never resume if that occurs.\n    this.ee.on(SESSION_EVENTS.RESET, () => {\n      this.abort(ABORT_REASONS.RESET);\n    });\n\n    // The SessionEntity class can emit a message indicating the session was paused (visibility change). This feature must stop recording if that occurs.\n    this.ee.on(SESSION_EVENTS.PAUSE, () => {\n      this.recorder?.stopRecording();\n    });\n    // The SessionEntity class can emit a message indicating the session was resumed (visibility change). This feature must start running again (if already running) if that occurs.\n    this.ee.on(SESSION_EVENTS.RESUME, () => {\n      if (!this.recorder) return;\n      // if the mode changed on a different tab, it needs to update this instance to match\n      this.mode = agentRef.runtime.session.state.sessionReplayMode;\n      if (!this.initialized || this.mode === MODE.OFF) return;\n      this.recorder?.startRecording();\n    });\n    this.ee.on(SESSION_EVENTS.UPDATE, (type, data) => {\n      if (!this.recorder || !this.initialized || this.blocked || type !== SESSION_EVENT_TYPES.CROSS_TAB) return;\n      if (this.mode !== MODE.OFF && data.sessionReplayMode === MODE.OFF) this.abort(ABORT_REASONS.CROSS_TAB);\n      this.mode = data.sessionReplayMode;\n    });\n    registerHandler(SR_EVENT_EMITTER_TYPES.PAUSE, () => {\n      this.forceStop(this.mode === MODE.FULL);\n    }, this.featureName, this.ee);\n    registerHandler(SR_EVENT_EMITTER_TYPES.ERROR_DURING_REPLAY, e => {\n      this.handleError(e);\n    }, this.featureName, this.ee);\n    const {\n      error_sampling_rate,\n      sampling_rate,\n      autoStart,\n      block_selector,\n      mask_text_selector,\n      mask_all_inputs,\n      inline_images,\n      collect_fonts\n    } = agentRef.init.session_replay;\n    this.waitForFlags(['srs', 'sr']).then(([srMode, entitled]) => {\n      this.entitled = !!entitled;\n      if (!this.entitled) {\n        this.deregisterDrain();\n        if (this.recorder?.recording) {\n          this.abort(ABORT_REASONS.ENTITLEMENTS);\n          this.reportSupportabilityMetric('SessionReplay/EnabledNotEntitled/Detected');\n        }\n        return;\n      }\n      this.drain();\n      this.initializeRecording(srMode);\n    }).then(() => {\n      if (this.mode === MODE.OFF) {\n        this.recorder?.stopRecording(); // stop any conservative preload recording launched by instrument\n        while (this.recorder?.getEvents().events.length) this.recorder?.clearBuffer?.();\n      }\n      sharedChannel.onReplayReady(this.mode);\n    }); // notify watchers that replay started with the mode\n\n    /** Detect if the default configs have been altered and report a SM.  This is useful to evaluate what the reasonable defaults are across a customer base over time */\n    if (!autoStart) this.reportSupportabilityMetric('Config/SessionReplay/AutoStart/Modified');\n    if (collect_fonts === true) this.reportSupportabilityMetric('Config/SessionReplay/CollectFonts/Modified');\n    if (inline_images === true) this.reportSupportabilityMetric('Config/SessionReplay/InlineImages/Modifed');\n    if (mask_all_inputs !== true) this.reportSupportabilityMetric('Config/SessionReplay/MaskAllInputs/Modified');\n    if (block_selector !== '[data-nr-block]') this.reportSupportabilityMetric('Config/SessionReplay/BlockSelector/Modified');\n    if (mask_text_selector !== '*') this.reportSupportabilityMetric('Config/SessionReplay/MaskTextSelector/Modified');\n    this.reportSupportabilityMetric('Config/SessionReplay/SamplingRate/Value', sampling_rate);\n    this.reportSupportabilityMetric('Config/SessionReplay/ErrorSamplingRate/Value', error_sampling_rate);\n  }\n  replayIsActive() {\n    return Boolean(this.recorder && this.mode === MODE.FULL && !this.blocked && this.entitled);\n  }\n  handleError(e) {\n    if (this.recorder) this.recorder.currentBufferTarget.hasError = true;\n    // run once\n    if (this.mode === MODE.ERROR && globalScope?.document.visibilityState === 'visible') {\n      this.switchToFull();\n    }\n  }\n  switchToFull() {\n    if (!this.entitled || this.blocked) return;\n    this.mode = MODE.FULL;\n    // if the error was noticed AFTER the recorder was already imported....\n    if (this.recorder && this.initialized) {\n      if (!this.recorder.recording) this.recorder.startRecording();\n      this.syncWithSessionManager({\n        sessionReplayMode: this.mode\n      });\n    } else {\n      this.initializeRecording(MODE.FULL, true);\n    }\n  }\n\n  /**\n   * Evaluate entitlements and sampling before starting feature mechanics, importing and configuring recording library, and setting storage state\n   * @param {boolean} srMode - the true/false state of the \"sr\" flag (aka. entitlements) from RUM response\n   * @param {boolean} ignoreSession - whether to force the method to ignore the session state and use just the sample flags\n   * @returns {void}\n   */\n  async initializeRecording(srMode, ignoreSession) {\n    this.initialized = true;\n    if (!this.entitled) return;\n\n    // if theres an existing session replay in progress, there's no need to sample, just check the entitlements response\n    // if not, these sample flags need to be checked\n    // if this isnt the FIRST load of a session AND\n    // we are not actively recording SR... DO NOT import or run the recording library\n    // session replay samples can only be decided on the first load of a session\n    // session replays can continue if already in progress\n    const {\n      session,\n      timeKeeper\n    } = this.agentRef.runtime;\n    this.timeKeeper = timeKeeper;\n    if (this.recorder?.parent.trigger === TRIGGERS.API && this.recorder?.recording) {\n      this.mode = MODE.FULL;\n    } else if (!session.isNew && !ignoreSession) {\n      // inherit the mode of the existing session\n      this.mode = session.state.sessionReplayMode;\n    } else {\n      // The session is new... determine the mode the new session should start in\n      this.mode = srMode;\n    }\n    // If off, then don't record (early return)\n    if (this.mode === MODE.OFF) return;\n    if (!this.recorder) {\n      try {\n        // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n        const {\n          Recorder\n        } = await import(/* webpackChunkName: \"recorder\" */'../shared/recorder');\n        this.recorder = new Recorder(this);\n        this.recorder.currentBufferTarget.hasError = this.errorNoticed;\n      } catch (err) {\n        return this.abort(ABORT_REASONS.IMPORT);\n      }\n    } else {\n      this.recorder.parent = this;\n    }\n\n    // If an error was noticed before the mode could be set (like in the early lifecycle of the page), immediately set to FULL mode\n    if (this.mode === MODE.ERROR && this.errorNoticed) this.mode = MODE.FULL;\n\n    // FULL mode records AND reports from the beginning, while ERROR mode only records (but does not report).\n    // ERROR mode will do this until an error is thrown, and then switch into FULL mode.\n    // The makeHarvestPayload should ensure that no payload is returned if we're not in FULL mode...\n\n    // If theres preloaded events and we are in full mode, just harvest immediately to clear up space and for consistency\n    if (this.mode === MODE.FULL && this.recorder?.getEvents().type === 'preloaded') {\n      this.prepUtils().then(() => this.agentRef.runtime.harvester.triggerHarvestFor(this));\n    }\n    await this.prepUtils();\n    if (!this.recorder.recording) this.recorder.startRecording();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n  }\n  async prepUtils() {\n    try {\n      // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n      const {\n        gzipSync,\n        strToU8\n      } = await import(/* webpackChunkName: \"compressor\" */'fflate');\n      this.gzipper = gzipSync;\n      this.u8 = strToU8;\n    } catch (err) {\n      // compressor failed to load, but we can still record without compression as a last ditch effort\n    }\n  }\n  makeHarvestPayload(shouldRetryOnFail) {\n    const payloadOutput = {\n      targetApp: undefined,\n      payload: undefined\n    };\n    if (this.mode !== MODE.FULL || this.blocked) return;\n    if (!this.recorder || !this.timeKeeper?.ready || !this.recorder.hasSeenSnapshot) return;\n    const recorderEvents = this.recorder.getEvents();\n    // get the event type and use that to trigger another harvest if needed\n    if (!recorderEvents.events.length) return;\n    const payload = this.getHarvestContents(recorderEvents);\n    if (!payload.body.length) {\n      this.recorder.clearBuffer();\n      return [payloadOutput];\n    }\n    this.reportSupportabilityMetric('SessionReplay/Harvest/Attempts');\n    let len = 0;\n    if (!!this.gzipper && !!this.u8) {\n      payload.body = this.gzipper(this.u8(\"[\".concat(payload.body.map(({\n        __serialized,\n        ...e\n      }) => {\n        if (e.__newrelic && __serialized) return __serialized;\n        const output = {\n          ...e\n        };\n        if (!output.__newrelic) {\n          output.__newrelic = buildNRMetaNode(e.timestamp, this.timeKeeper);\n          output.timestamp = this.timeKeeper.correctAbsoluteTimestamp(e.timestamp);\n        }\n        return stringify(output);\n      }).join(','), \"]\")));\n      len = payload.body.length;\n    } else {\n      payload.body = payload.body.map(({\n        __serialized,\n        ...node\n      }) => {\n        if (node.__newrelic) return node;\n        const output = {\n          ...node\n        };\n        output.__newrelic = buildNRMetaNode(node.timestamp, this.timeKeeper);\n        output.timestamp = this.timeKeeper.correctAbsoluteTimestamp(node.timestamp);\n        return output;\n      });\n      len = stringify(payload.body).length;\n    }\n    if (len > MAX_PAYLOAD_SIZE) {\n      this.abort(ABORT_REASONS.TOO_BIG, len);\n      return [payloadOutput];\n    }\n    // TODO -- Gracefully handle the buffer for retries.\n    if (!this.agentRef.runtime.session.state.sessionReplaySentFirstChunk) this.syncWithSessionManager({\n      sessionReplaySentFirstChunk: true\n    });\n    this.recorder.clearBuffer();\n    if (recorderEvents.type === 'preloaded') this.agentRef.runtime.harvester.triggerHarvestFor(this);\n    payloadOutput.payload = payload;\n    return [payloadOutput];\n  }\n  getCorrectedTimestamp(node) {\n    if (!node?.timestamp) return;\n    if (node.__newrelic) return node.timestamp;\n    return this.timeKeeper.correctAbsoluteTimestamp(node.timestamp);\n  }\n  getHarvestContents(recorderEvents) {\n    recorderEvents ??= this.recorder.getEvents();\n    let events = recorderEvents.events;\n    const agentRuntime = this.agentRef.runtime;\n    const endUserId = this.agentRef.info.jsAttributes?.['enduser.id'];\n\n    // do not let the first node be a full snapshot node, since this NEEDS to be preceded by a meta node\n    // we will manually inject it if this happens\n    const payloadStartsWithFullSnapshot = events?.[0]?.type === RRWEB_EVENT_TYPES.FullSnapshot;\n    if (payloadStartsWithFullSnapshot && !!this.recorder.lastMeta) {\n      recorderEvents.hasMeta = true;\n      events.unshift(this.recorder.lastMeta); // --> pushed the meta from a previous payload into newer payload... but it still has old timestamps\n      this.recorder.lastMeta = undefined;\n    }\n\n    // do not let the last node be a meta node, since this NEEDS to precede a snapshot\n    // we will manually inject it later if we find a payload that is missing a meta node\n    const payloadEndsWithMeta = events[events.length - 1]?.type === RRWEB_EVENT_TYPES.Meta;\n    if (payloadEndsWithMeta) {\n      this.recorder.lastMeta = events[events.length - 1];\n      events = events.slice(0, events.length - 1);\n      recorderEvents.hasMeta = !!events.find(x => x.type === RRWEB_EVENT_TYPES.Meta);\n    }\n    const relativeNow = now();\n    const firstEventTimestamp = this.getCorrectedTimestamp(events[0]); // from rrweb node\n    const lastEventTimestamp = this.getCorrectedTimestamp(events[events.length - 1]); // from rrweb node\n    // from rrweb node || from when the harvest cycle started\n    const firstTimestamp = firstEventTimestamp || Math.floor(this.timeKeeper.correctAbsoluteTimestamp(recorderEvents.cycleTimestamp));\n    const lastTimestamp = lastEventTimestamp || Math.floor(this.timeKeeper.correctRelativeTimestamp(relativeNow));\n    const agentMetadata = agentRuntime.appMetadata?.agents?.[0] || {};\n    return {\n      qs: {\n        browser_monitoring_key: this.agentRef.info.licenseKey,\n        type: 'SessionReplay',\n        app_id: this.agentRef.info.applicationID,\n        protocol_version: '0',\n        timestamp: firstTimestamp,\n        attributes: encodeObj({\n          // this section of attributes must be controllable and stay below the query param padding limit -- see QUERY_PARAM_PADDING\n          // if not, data could be lost to truncation at time of sending, potentially breaking parsing / API behavior in NR1\n          ...(!!this.gzipper && !!this.u8 && {\n            content_encoding: 'gzip'\n          }),\n          ...(agentMetadata.entityGuid && {\n            entityGuid: agentMetadata.entityGuid\n          }),\n          harvestId: [agentRuntime.session?.state.value, agentRuntime.ptid, agentRuntime.harvestCount].filter(x => x).join('_'),\n          'replay.firstTimestamp': firstTimestamp,\n          'replay.lastTimestamp': lastTimestamp,\n          'replay.nodes': events.length,\n          'session.durationMs': agentRuntime.session.getDuration(),\n          agentVersion: agentRuntime.version,\n          session: agentRuntime.session.state.value,\n          rst: relativeNow,\n          hasMeta: recorderEvents.hasMeta || false,\n          hasSnapshot: recorderEvents.hasSnapshot || false,\n          hasError: recorderEvents.hasError || false,\n          isFirstChunk: agentRuntime.session.state.sessionReplaySentFirstChunk === false,\n          decompressedBytes: recorderEvents.payloadBytesEstimation,\n          invalidStylesheetsDetected: stylesheetEvaluator.invalidStylesheetsDetected,\n          inlinedAllStylesheets: recorderEvents.inlinedAllStylesheets,\n          'rrweb.version': RRWEB_VERSION,\n          'payload.type': recorderEvents.type,\n          // customer-defined data should go last so that if it exceeds the query param padding limit it will be truncated instead of important attrs\n          ...(endUserId && {\n            'enduser.id': this.obfuscator.obfuscateString(endUserId)\n          }),\n          currentUrl: this.obfuscator.obfuscateString(cleanURL('' + location))\n          // The Query Param is being arbitrarily limited in length here.  It is also applied when estimating the size of the payload in getPayloadSize()\n        }, QUERY_PARAM_PADDING).substring(1) // remove the leading '&'\n      },\n      body: events\n    };\n  }\n  postHarvestCleanup(result) {\n    // The mutual decision for now is to stop recording and clear buffers if ingest is experiencing 429 rate limiting\n    if (result.status === 429) {\n      this.abort(ABORT_REASONS.TOO_MANY);\n    }\n  }\n\n  /**\n   * Forces the agent into OFF mode so that changing tabs or navigating\n   * does not restart the recording. This is used when the customer calls\n   * the stopRecording API.\n   */\n  forceStop(forceHarvest) {\n    if (forceHarvest) this.agentRef.runtime.harvester.triggerHarvestFor(this);\n    this.mode = MODE.OFF;\n    this.recorder?.stopRecording?.();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n  }\n\n  /** Abort the feature, once aborted it will not resume */\n  abort(reason = {}, data) {\n    warn(33, reason.message);\n    this.reportSupportabilityMetric(\"SessionReplay/Abort/\".concat(reason.sm), data);\n    this.blocked = true;\n    this.mode = MODE.OFF;\n    this.recorder?.stopRecording?.();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n    this.recorder?.clearTimestamps?.();\n    while (this.recorder?.getEvents().events.length) this.recorder?.clearBuffer?.();\n  }\n  syncWithSessionManager(state = {}) {\n    if (this.isSessionTrackingEnabled) {\n      this.agentRef.runtime.session.write(state);\n    }\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Keeps an object alive that is passed to all feature aggregate modules.\n * The purpose is to have a way for communication and signals to relay across features at runtime.\n * This object can hold any arbitrary values and should be treated as on-the-fly dynamic.\n */\n\nlet onReplayReady;\nconst sessionReplayInitialized = new Promise(resolve => {\n  onReplayReady = resolve;\n});\nexport const sharedChannel = Object.freeze({\n  onReplayReady,\n  sessionReplayInitialized\n});","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { gosNREUMOriginals } from '../../../common/window/nreum';\nimport { isBrowserScope } from '../../../common/constants/runtime';\nclass StylesheetEvaluator {\n  #evaluated = new WeakSet();\n  #brokenSheets = [];\n  /**\n  * Flipped to true if stylesheets that cannot be natively inlined are detected by the stylesheetEvaluator class\n  * Used at harvest time to denote that all subsequent payloads are subject to this and customers should be advised to handle crossorigin decoration\n  * */\n  invalidStylesheetsDetected = false;\n  failedToFix = 0;\n\n  /**\n   * this works by checking (only ever once) each cssRules obj in the style sheets array. The try/catch will catch an error if the cssRules obj blocks access, triggering the module to try to \"fix\" the asset`. Returns the count of incomplete assets discovered.\n   * @returns {Number}\n   */\n  evaluate() {\n    let incompletes = 0;\n    this.#brokenSheets = [];\n    if (isBrowserScope) {\n      for (let i = 0; i < Object.keys(document.styleSheets).length; i++) {\n        if (!this.#evaluated.has(document.styleSheets[i]) && document.styleSheets[i] instanceof CSSStyleSheet) {\n          this.#evaluated.add(document.styleSheets[i]);\n          try {\n            // eslint-disable-next-line\n            const temp = document.styleSheets[i].cssRules;\n          } catch (err) {\n            if (!document.styleSheets[i].href) return;\n            incompletes++;\n            this.#brokenSheets.push(document.styleSheets[i]);\n          }\n        }\n      }\n    }\n    if (incompletes) this.invalidStylesheetsDetected = true;\n    return incompletes;\n  }\n\n  /**\n   * Resolves promise once all stylesheets have been fetched and overridden\n   * @returns {Promise}\n   */\n  async fix() {\n    await Promise.all(this.#brokenSheets.map(sheet => this.#fetchAndOverride(sheet)));\n    this.#brokenSheets = [];\n    const failedToFix = this.failedToFix;\n    this.failedToFix = 0;\n    return failedToFix;\n  }\n\n  /**\n  * Fetches stylesheet contents and overrides the target getters\n  * @param {*} target - The stylesheet object target - ex. document.styleSheets[0]\n  * @param {*} href - The asset href to fetch\n  * @returns {Promise}\n  */\n  async #fetchAndOverride(target) {\n    if (!target?.href) return;\n    try {\n      const stylesheetContents = await gosNREUMOriginals().o.FETCH.bind(window)(target.href);\n      if (!stylesheetContents.ok) {\n        this.failedToFix++;\n        return;\n      }\n      const stylesheetText = await stylesheetContents.text();\n      try {\n        const cssSheet = new CSSStyleSheet();\n        await cssSheet.replace(stylesheetText);\n        Object.defineProperty(target, 'cssRules', {\n          get() {\n            return cssSheet.cssRules;\n          }\n        });\n        Object.defineProperty(target, 'rules', {\n          get() {\n            return cssSheet.rules;\n          }\n        });\n      } catch (err) {\n        // cant make new dynamic stylesheets, browser likely doesn't support `.replace()`...\n        // this is appended in prep of forking rrweb\n        Object.defineProperty(target, 'cssText', {\n          get() {\n            return stylesheetText;\n          }\n        });\n        this.failedToFix++;\n      }\n    } catch (err) {\n      // failed to fetch\n      this.failedToFix++;\n    }\n  }\n}\nexport const stylesheetEvaluator = new StylesheetEvaluator();","module.exports = Promise.all([parcelRequire.load(\"bolVv\"), parcelRequire.load(\"7qhnc\")]).then(() => parcelRequire('laqLT'));","module.exports = (parcelRequire.load(\"gYIeX\")).then(() => parcelRequire('hIp1Z'));"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$import","url","$parcel$distDir","parcelRequire","i","$parcel$global","globalThis","self","window","global","parcelRegister","register","module","exports","$625db035f0c28dc8$export$b9601df20779e14a","$4he1m","$6bsRh","$3DmF0","$5GJZE","$ikySP","$jkuUu","$9EKMI","$4wUr4","$44Lnf","$8KO5M","$7tsml","$1Z3KE","$24qgc","$iNTSX","$jWywI","$1orxZ","AggregateBase","featureName","FEATURE_NAME","mode","MODE","OFF","constructor","agentRef","args","initialized","blocked","gzipper","undefined","u8","entitled","timeKeeper","recorder","errorNoticed","harvestOpts","raw","isSessionTrackingEnabled","canEnableSessionTracking","init","runtime","session","reportSupportabilityMetric","ee","on","SESSION_EVENTS","RESET","abort","ABORT_REASONS","PAUSE","stopRecording","RESUME","state","sessionReplayMode","startRecording","UPDATE","type","data","SESSION_EVENT_TYPES","CROSS_TAB","registerHandler","SR_EVENT_EMITTER_TYPES","forceStop","FULL","ERROR_DURING_REPLAY","handleError","error_sampling_rate","sampling_rate","autoStart","block_selector","mask_text_selector","mask_all_inputs","inline_images","collect_fonts","session_replay","waitForFlags","then","srMode","deregisterDrain","recording","ENTITLEMENTS","drain","initializeRecording","getEvents","events","length","clearBuffer","sharedChannel","onReplayReady","replayIsActive","Boolean","currentBufferTarget","hasError","ERROR","globalScope","document","visibilityState","switchToFull","syncWithSessionManager","ignoreSession","parent","trigger","TRIGGERS","API","isNew","Recorder","err","IMPORT","prepUtils","harvester","triggerHarvestFor","gzipSync","strToU8","makeHarvestPayload","shouldRetryOnFail","payloadOutput","targetApp","payload","ready","hasSeenSnapshot","recorderEvents","getHarvestContents","body","len","concat","map","__serialized","__newrelic","output","buildNRMetaNode","timestamp","correctAbsoluteTimestamp","stringify","join","node","MAX_PAYLOAD_SIZE","TOO_BIG","sessionReplaySentFirstChunk","getCorrectedTimestamp","agentRuntime","endUserId","info","jsAttributes","RRWEB_EVENT_TYPES","FullSnapshot","lastMeta","hasMeta","unshift","Meta","slice","find","x","relativeNow","now","firstEventTimestamp","lastEventTimestamp","firstTimestamp","Math","floor","cycleTimestamp","lastTimestamp","correctRelativeTimestamp","agentMetadata","appMetadata","agents","qs","browser_monitoring_key","licenseKey","app_id","applicationID","protocol_version","attributes","obj","content_encoding","entityGuid","harvestId","value","ptid","harvestCount","filter","getDuration","agentVersion","version","rst","hasSnapshot","isFirstChunk","decompressedBytes","payloadBytesEstimation","invalidStylesheetsDetected","stylesheetEvaluator","inlinedAllStylesheets","RRWEB_VERSION","obfuscator","obfuscateString","currentUrl","cleanURL","location","QUERY_PARAM_PADDING","substring","postHarvestCleanup","result","status","TOO_MANY","forceHarvest","reason","warn","message","sm","clearTimestamps","write","$42448d51f724b7bf$var$onReplayReady","$42448d51f724b7bf$export$ef19b434e352183b","$42448d51f724b7bf$var$sessionReplayInitialized","Promise","resolve","freeze","sessionReplayInitialized","$57113d7053e688ae$export$fdabeb4af43679fc","$juL0p","$57113d7053e688ae$var$StylesheetEvaluator","WeakSet","failedToFix","evaluate","incompletes","isBrowserScope","keys","styleSheets","has","CSSStyleSheet","add","cssRules","href","push","fix","all","sheet","target","stylesheetContents","gosNREUMOriginals","o","FETCH","bind","ok","stylesheetText","text","cssSheet","replace","rules"],"version":3,"file":"aggregate.cfb7ae34.js.map"}